<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-04-28 Fri 17:16 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MineWeeper</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script type="text/javascript" src="./org-highlight.js"></script>
<link rel="icon" type="image/x-icon" href="../../../images/logo2.png">
<link rel="stylesheet" type="text/css" href="./style.css"/>
<link rel="stylesheet" type="text/css" href="./blog.css"/>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">MineWeeper</h1>
<p class="subtitle" role="doc-subtitle">A Linkspace Application Tutorial</p>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org45459a8">Bob's Hotseat MineWeeper</a></li>
<li><a href="#org8b15097">Game on</a></li>
<li><a href="#org9621459">Multiplayer</a></li>
<li><a href="#org2dfbfc1">Cheating</a>
<ul>
<li>
<ul>
<li><a href="#orge8e7331">Who cares?</a></li>
<li><a href="#org108120c">Emulate host/client</a></li>
<li><a href="#orgca9b7d7">Rng-esus died for your sins</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org116a513">A dose of reality</a></li>
</ul>
</div>
</nav>
<script type="text/javascript">
    // Setup clickable tabs
document.addEventListener('DOMContentLoaded', ()=>
    document.querySelectorAll(".ctabs").forEach((outer,i)=>
        [... outer.children].forEach((el,j) => {
        el.insertAdjacentHTML(
            "beforebegin",
            `<input name="tabs${i}" tabindex="${i}" type="radio" id="tab${i}x${j}" ${j == 0 ? "checked" : ""}>
                 <label for="tab${i}x${j}">${el.className}</label>`
        );
    el.setAttribute("tabindex",i);
        } )
    )
    );

    // Setup highlight js 

document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre.src').forEach((el) => {
            let lang = el.classList[1].slice(4)
            el.classList.add("language-" + lang)
            hljs.highlightElement(el);
        });
});

</script>

<p>
This is the first a series of tutorials to showcase linkspace.
Imagine what you might build if we all hashed, saved, and linked the packets on our networks.
Linkspace is such a <a href="https://antonsol919.github.io/linkspace/index.html">supernet</a>.
</p>

<p>
We'll follow Bob in his journey.
</p>


<figure id="orgfe43544">
<img src="../images/bob-hi.png" alt="bob-hi.png">

</figure>

<p>
He build the greatest and must impressive game ever.  
Or so he says.
</p>

<p>
The game is MineWeeper: A Multiplayer minesweeper clone where players take turns. 
</p>

<p>
To follow along, the follow knowledge/skills are assumed:
</p>

<ul class="org-ul">
<li>a basic level of python (You know what <code>val = int(input("value")</code> does)</li>
<li>basic devops (a terminal doesn't scare you, worst case you'll google what <code>xargs</code> does)</li>
<li>the difference between a string and bytes</li>
<li>What a RNG seed is.</li>
<li>What a hash and public keys is.</li>
<li>Curious enough to hack together tools to do what you want it to do (OpenGPT isn't going to solve this one)</li>
</ul>

<p>
In linkspace the responsibilities for things are different to what you might be used to.
</p>

<p>
An application developer has drastically fewer responsibilities.
Things like networking, servers, registration, users, groups, and read/write access are all outside the scope of what an application has to deal with. 
The app developer need only think about: bytes, linking to bytes, and reading bytes by link or path name.
</p>

<p>
This tutorial won't be about the user or group setup.
</p>

<p>
Linkspace aims to be simple compared to what an equivalent stack would look like.
If your usecase is streaming data between two points over a socket, linkspace will obviously lose that proposition.
But once more things are added to the mix, such as having 'user' and multiple people interacting, linkspace might be the simplest solution.
</p>

<p>
Note however, I do mean simple, not easy.
Linkspace is 30 years behind in tooling to make things as easy as the web is today.
</p>

<p>
Before you continue, please check this consent form to not hold Bob accountable for the dumb stuff you share and do.
</p>

<div> 
<input type="checkbox" id="consent" name="consent">
<fieldset id="consent-form">
    <legend>Consent form</legend>
    <label for="consent">Click to Consent [ ] </label>
</fieldset>
<div id="consent-ok">
<img src="../images/bob-cheer.png" alt="bob-cheer.png">
<p>With that piece of vital and productive administration out of the way, let's check out what Bob has build</p>
</div>
</div>


<div id="outline-container-org45459a8" class="outline-2">
<h2 id="org45459a8">Bob's Hotseat MineWeeper</h2>
<div class="outline-text-2" id="text-org45459a8">
<p>
Bob's game is perfect.
However, there is one tiny, little, detail missing.
</p>

<p>
It only works in hotseat mode.
That is, every player has to be at the same keyboard taking turns.
</p>

<p>
Bob's a friendly guy, but he doesn't want you coming to his house.
Instead, he'll build something real quick, such that anybody can play it with their friends over the internet.
</p>

<p>
No biggy.
</p>

<p>
First, how does the game work in hotseat mode?
</p>

<p>
It asks the user for a list of player names.
Players take turns entering which cell to reveal until someone reveals a mine or no more safe cells exist.
</p>

<p class="verse">
This post was made for version 0.2.0<br>
Download and extract the pkg zip.<br>
Paths and commands are relative to this directory.<br>
To give hotseat mineweeper a try:<br>
<code>python ./examples/mineweeper/mineweeper-hotseat.py</code><br>
</p>

<div class="py" id="org3d7911a">
<div class="org-src-container">
<pre class="src src-python">from mineweeper import MineWeeper, clear_screen, NoSuchCell,AlreadyRevealed
import re,random

player_count = int(input("Number of players?:"))
players = [ input("Enter name&gt;:") for _ in range(player_count)]
rows = 20 # int(input("rows"))
cols = 20 # int(input("cols"))
mine_rate = 0.3 # int(input("mine_rate"))

# A game started with the same (rows,cols,seed) will have the mines at the same location
seed = random.randbytes(4)

game = MineWeeper(players,rows,cols,mine_rate,seed=seed)

input("Coordinates are row/vertical, col/horizontal. [Enter to start]")
while game.print_game_state():
    try:
        [row,col] = re.split('[;|, :]',input("Reveal:"))
        clear_screen()
        game.reveal(int(row),int(col))
    except Exception as e:
        print(e)
</pre>
</div>

</div>

<p>
Bob's a little disappointed with the graphics.
He's waiting for those VC bucks to hire professionals to port it to the next Unreal Engine with RTX graphics in VR.
<img src="../images/bob-doubt.png" alt="bob-doubt.png">
</p>

<div class="ctabs" id="org9a9b98b">
<div class="info" id="org5f664d9">
<p>
Contrary to Bob, we don't care much for the details of MineWeeper.
In case you're interested checkout the tab or open the code in ./app/mineweeper-py/mineweeper.py
</p>

</div>

<div class="py" id="org90f4b30">
<div class="org-src-container">
<pre class="src src-python">import random
import itertools
import re
from dataclasses import dataclass

class NoSuchCell(Exception): pass
class AlreadyRevealed(Exception): pass

def clear_screen():
    print("\n"*100)

@dataclass
class Cell:
    mine: bool = False
    revealed: bool = False 
    neighbour_mines:int = 0
    def __str__(self):
        return (not self.revealed and ".") or (self.mine and "X") or str(self.neighbour_mines)


class MineWeeper():
    players: list[str]
    rows:int
    cols:int
    mine_rate:float
    seed: bytes
    grid:list[list[Cell]] =[]
    loser = None
    game_round = 0

    def __init__(self, players: list[str], rows: int, cols: int, mine_rate: float, seed: bytes) -&gt; object:
        self.players = players
        self.rows = rows;
        self.cols = cols
        self.mine_rate = mine_rate
        self.seed = seed
        self.grid =  [ [Cell(self.is_mine(i,j)) for j in range(self.cols)]  for i in range(self.rows)]
        for r,row in enumerate(self.grid):
            for c,cell in enumerate(row):
                for (dr,dc) in [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]:
                    neighbour = self.get_cell(r+dr,c+dc)
                    if neighbour:
                        cell.neighbour_mines += neighbour.mine

    def current_player(self) -&gt; tuple[int,str]:
        player_id = self.game_round % len(self.players)
        return (player_id,self.players[player_id])

    def is_mine(self,row:int,col:int) -&gt; bool:

        random.seed(self.seed + row.to_bytes(length=4) + col.to_bytes(length=4))
        return random.random() &lt; self.mine_rate


    def get_cell(self,row,col)  -&gt; Cell | None:
        if row &gt;= 0 and row &lt; self.rows and col &gt;= 0 and col &lt; self.cols:
            return self.grid[row][col]
        return None

    def print_grid(self):
        coord_fmt = "[{:&gt;2}]"
        print(*["[##]"] + [coord_fmt.format(c) for c in range(self.cols)])
        for r,row in enumerate(self.grid):
            print(*[coord_fmt.format(r)] + [ " {:&gt;2} ".format(str(cell)) for cell in row])

    def count_revealable(self) -&gt; int:
        """number of cells left to reveal"""
        return sum([
            not cell.revealed and not cell.mine
            for row in self.grid for cell in row
        ])


    def print_game_state(self) -&gt; bool:
        """Print board and current state. returns False if game is finished"""
        print(self.print_grid())
        print("Round ",self.game_round)
        if self.loser is not None:
            print("Game Finished!")
            print("The loser is {} ({})".format(self.players[self.loser],self.loser))
            return False
        if self.count_revealable() == 0:
           print("Everybody survived!")
           print("for now ...")
           return False
        print(self.count_revealable(),"options to not lose")
        (pid,name) = self.current_player()
        print("Player {} ({})".format(name,pid))
        return True

    def reveal(self,row,col):
        cell = self.get_cell(row,col)
        if cell is None:
            raise NoSuchCell
        elif cell.revealed:
            raise AlreadyRevealed
        else:
           cell.revealed = True
           (pid,_) = self.current_player()
           if cell.mine:
               print("Boom")
               self.loser = pid
           else:
               print("Phew")
           self.game_round += 1
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-org8b15097" class="outline-2">
<h2 id="org8b15097">Game on</h2>
<div class="outline-text-2" id="text-org8b15097">
<p>
After searching high and low, our friend Bob reaches for enlightenment.
</p>


<figure id="orga141099">
<img src="../images/bob-enlightend.png" alt="bob-enlightend.png">

</figure>


<p>
He finds linkspace.
</p>

<p>
A thoroughly untested protocol with very few users.
But he figures it's the best solution to make MineWeeper a true multiplayer game.
</p>

<p>
With linkspace:
</p>
<ul class="org-ul">
<li>his (user administrative) workload drops dramatically.</li>
<li>the game will stay playable without him spending a penny. Forever.</li>
<li>user network/account/group problems can be solved once (hopefully by someone else).</li>
</ul>

<p>
Bob might be a little biased. He suffers from PCSSD, or Post Customer Support Stress Disorder.
</p>

<p>
Developing linkspace system boils down to:
</p>

<ul class="org-ul">
<li>Gather some bytes you want sent around in a packet.</li>
<li>Optionally: set a path, add links to other packets, sign it.</li>
<li>Save that packet.</li>
<li>Build a query: a list of predicates for a packet (e.g. pubkey, hash, path).</li>
<li>Get or watch for those results.</li>
</ul>


<p>
For Bob, the linkspace library is an abstraction that moves bytes around between players.
</p>

<p>
In the linkspace world, Bob's game is a domain application.
A program providing a friendly interface reading/writing the bytes that the developer wants to be shared around.
</p>

<p class="verse">
When the program calls the 'lk_pull' function for a query, the requested bytes saved with lk_save on another machine eventually become available.<br>
This is done by a linkspace group exchange process. A group exchange process is build just like a domain application.<br>
But its role is to exchange all packets with its group ID to the members that require it.<br>
More on them another day.<br>
</p>

<p>
Bob recognizes that his game has two distinct phases.
</p>

<ul class="org-ul">
<li>Finding the people to start playing it with.</li>
<li>Actually taking turns to play the game.</li>
</ul>

<p>
He'll start with 'play the game', and build the lobby system for proposing/joining/starting a game later.
</p>

<p>
He's not set on the details, but every game starts with at least the players knowing:
</p>

<ul class="org-ul">
<li>a list of (player names, pubkey).</li>
<li>number of rows &amp; columns.</li>
<li>mine_rate.</li>
<li>RNG seed.</li>
</ul>

<p class="verse">
In this setup everybody knows the board, but we'll touch on <a href="#org2dfbfc1">Cheating</a> later.<br>
</p>

<p>
For an initial test, Bob will assume three players agreed that the following packet is the start of a game.
</p>

<pre class="example" id="org32d73b0">
type	LinkPoint
hash	VJPxHigyCAmXvPojLxAQzHGYOiZDHP46ztaPZzMm6to
group	[#:test]
domain	mineweeper
path	
pubkey	[@:none]
create	1682062494375521
links	0

data	278
{
    "rows":20,
    "columns": 20,
    "mine_rate":0.3,
    "players":[
        ["alice", "iyfplTMDFj3Jw8XwdfwvXs9ZVgwwYZNsQ3E7cS55kLQ"],
        ["bob", "qfurOQ2oTD1Xc9dQf_gX2MXbsbALdXQ_XemF0aTlj6U"],
        ["charlie", "2SYK3NlS8k4ELKWR6CmqIQAiPrMosr5LioK7456jnDY"]
    ]
}
</pre>

<p>
Bob decides to encode this as JSON.
A 'seed' field doesn't seem to be necessary, the hash of the packet can fill the role.
</p>

<div class="ctabs" id="orgbc7afd2">
<div class="info" id="org1147ba3">
<p>
Bob isn't infallible, so in building this he needs to test it locally.
The ./emulate folder contains two script to create and connect two instances locally.
It requires tmux to be installed (available in most package managers)
</p>

</div>

<div class="setup" id="org7b5a8ff">
<p>
You can create an instance with a simple exchange process running by starting:
</p>

<div class="org-src-container">
<pre class="src src-bash">./emulate/host.session.tmux.sh
</pre>
</div>


<p>
Open a terminal and execute the following to create additional instances automatically connect.
</p>

<div class="org-src-container">
<pre class="src src-bash">./emulate/session.tmux.sh bob #changing this name
</pre>
</div>

<p>
Finally, we have to create the initial packet and share them.
One method to do so is as follows:
</p>

<div class="org-src-container">
<pre class="src src-bash">cd private
cat ./*/name_key &gt; setup.json
# You'll have to edit this setup.json by hand to look like the json above. 
lk link mineweeper:[#:test] --data file:./setup.json &gt; setup.pkt

# Manually save this packet to each instance
find ./ -mindepth 1 -maxdepth 1 -type d -exec lk --dir "{}" save --pkt-in ./setup.pkt \;
</pre>
</div>

</div>

</div>
</div>
</div>


<div id="outline-container-org9621459" class="outline-2">
<h2 id="org9621459">Multiplayer</h2>
<div class="outline-text-2" id="text-org9621459">
<p>
The outline is as follows:
</p>

<ul class="org-ul">
<li>open the linkspace instance and a signing key.</li>
<li>read the 'game_pkt' that starts the game by its hash.</li>
<li>load the settings, including a list of [player names,pubkeys].</li>
</ul>

<p>
while not done:
</p>
<ul class="org-ul">
<li>Print the state.</li>
<li>If its our turn, make a choice and save the move info.</li>
<li>Else wait for the current player to make a move.</li>
</ul>

<div class="py" id="org13c70d7">
<div class="org-src-container">
<pre class="src src-python">#!/bin/env python3

import sys, json,re,functools

from mineweeper import MineWeeper, clear_screen
from linkspace import *

# The players have agreed on the game setup and players.
# The game setup was encoded in a linkspace.Pkt we agreed upon through some other system (like a game lobby)
# The argument to this script is the hash of this Pkt. 
game_hash = sys.argv[1] 

# Open the default instance and the default signing key
lk = lk_open() 
signing_key = lk_key(lk)

# Get the game setup packet.
game_pkt = lk_get(lk, lk_hash_query(game_hash)) or exit("No such game start")
"""
The data of this game pkt is a json encoding similar to:
{
    "rows":20,
    "columns": 20,
    "mine_rate":0.3,
    "players":[
        ["alice", "iyfplTMDFj3Jw8XwdfwvXs9ZVgwwYZNsQ3E7cS55kLQ"],
        ["bob", "qfurOQ2oTD1Xc9dQf_gX2MXbsbALdXQ_XemF0aTlj6U"],
        ["charlie", "2SYK3NlS8k4ELKWR6CmqIQAiPrMosr5LioK7456jnDY"]
    ]
}
"""
game_conf = json.loads(game_pkt.data.decode("utf-8"))

print("Starting game")
# To notify the user about the group used, lets print the group name corresponding to the bytes in the game_pkt linkpoint
# lk_encode takes bytes as an argument and tries various ways to print them in abe format.
print("group  :", lk_encode(game_pkt.group,"#/@/b"))
print(game_conf)

# The players are a subset of the users in a group.
# Not every user is interested in every packet.
# We have to make it obvious which packets are part of this game, so the players can query it and the others can ignore it.
# We'll use this unique path to do so.
game_path = path([b"game", game_pkt.hash])

# We'll use slightly different queries throughout this process, but much of their predicates remain static.
# This query will act as our template for more specific queries. 
common_q = lk_query_parse(lk_query(),"domain:=:mineweeper","group:=:[group]","path:=:[0]", pkt=game_pkt, argv=[game_path])

# The [group] and [0] resolved to the bytes from the pkt and argv arguments respectively.
# print(lk_query_print(common_q, True))

# The first use of our query is to signal the linkspace instance that we're interested in packets related to this game.
# This signaling is done by writing the query to [f:exchange]:[#:0]:/[q.group]/[q.domain]/[q.qid] 
# The lk_pull function encodes this convention and does some checking.  
pull_q = lk_query_push(common_q,"","qid", b"game"+game_pkt.hash)
lk_pull(lk, pull_q)

# An exchange process reads this request.  
# If everything is going to plan, all players will eventually receive packets saved by others that matches the query.

# A packet can be one of three types. ( Or to be exact, a packet is a [netheader,hash,point] and there are three types of points)
# A datapoint, linkpoint, or keypoint.
# A datapoint only holds data.
# A linkpoint has: data, a path name, and links (tag,hash) to other packets.
# A keypoint is a linkpoint with a cryptographic signature.
# For our case we'll only use keypoints.

# Its common to wrap the *point functions as we know the following arguments wont change.
new_keypoint = functools.partial(lk_keypoint, key=signing_key, domain=b"mineweeper", group=game_pkt.group, path=game_path)

player_count = len(game_conf['players'])
for i, e in enumerate(game_conf['players']):
    print(i, e)

players = list([e[0] for e in game_conf['players']])


# By setting the seed to be the game_pkt.hash, every player will generate the same map of mines.
game = MineWeeper(    players=players,
    rows=game_conf['rows'],
    cols=game_conf['columns'],
    mine_rate=game_conf['mine_rate'],
    seed=game_pkt.hash)
input("Coordinates are row/vertical, col/horizontal.")

# We expect the players to take turns in sequence until someone reveals a bomb.
# Alice -&gt; Bob -&gt; Charlie -&gt; Alice -&gt; Bob -&gt; ...

# Each turn will be a keypoint, signed by the player, with the data being a json encoded [x,y] for the cell the player revealed.
# By checking the pubkey of the Pkt we know who made the move, but we'll need a way to know which turn we're on.
# One option is to add a {turn:int} field to the json.
# We can be more strict and require each keypoint to link back to the prev turn.
# To start, the first turn will link back to the game_pkt
prev_turn = Link("prev", game_pkt.hash)

# We'll use a callback that receives packets matching (a subset of) our query. 
# If the pkt argument has a link equal to prev_ptr it contains the json for the next turn. 
def find_and_do_next_move(player_turn_pkt):
    global prev_turn, game
    if player_turn_pkt.links[0] == prev_turn:
        try:
            [row, col] = json.loads(player_turn_pkt.data.decode("utf-8"))
            clear_screen()
            game.reveal(row, col)
            # Update our prev_ptr to the this packet. 
            prev_turn = Link("prev", player_turn_pkt.hash)
            return True # stop looking
        except Exception as e :
            exit("Game was corrupted: " + str(e) )

while game.print_game_state():
    [pid,name] = game.current_player();
    [_name,b64_key] = game_conf['players'][pid]

    # We know whose turn it is, so we'll narrow our query down to packets signed by the current player.
    # We have the pubkey in base64 string encoding so we'll use lk_query_parse instead of lk_query_push
    q = lk_query_parse(common_q,"pubkey:=:"+b64_key)
    # (We don't have to lk_pull because it's a subset of what we're already pulling).

    # To start off, we'll check if any of the packets we have locally represent the turn we're looking for.
    # (As a side effect, we can close and open this script and continue were we left off)
    # lk_get_all returns a positive number if the callback was finished by returning True.
    if lk_get_all(lk,q,find_and_do_next_move) &gt; 0:
        continue

    # We don't have the packet for the current turn. 
    # If the current players key is our key, we should make a move.
    if b64_key == b64(signing_key.pubkey):
        print("Your turn")
        try:
            [row,col] = re.split('[;|, :]',input("Reveal:"))
            data=json.dumps([int(row),int(col)])
            pkt = new_keypoint(data=data,links=[prev_turn])
            print("Cheating ",game.is_mine(int(row),int(col)))
            if "y" in input("?"):
                # We save the packet. An exchange process will ensure the other players get it. 
                lk_save(lk,pkt)
                prev_turn = Link("prev",pkt.hash)
            # 'input("?")' might have taken the user a long time, 
            # and saving a packet doesn't update our local view of the database. 
            # To do so we have to process the new packets.
            # In our case that doesn't do anything else.  
            lk_process(lk)
        except Exception as e:
            print(e)
    else:
        # If its not our turn, we'll have to wait for the packet of the current player to arrive. 
        print("Waiting")

        # lk_watch is like lk_get_all, but in addition the callback will also get called for matches during lk_process or lk_process_while.

        # lk_watch requires we give our query a qid.
        # This allows us to remove or overwrite it later.
        # (in our case the cb will finish by returning True, so this isn't very relevant except for logging/debugging).
        # We'll name our query 'move' 
        q = lk_query_push(q,"","qid",b"move") # alternatively lk_query_parse(q,":qid:move")

        # lk_watch, just like lk_get_all, starts with the database.
        # We can skip this. We already used lk_get_all (and we haven't lk_process* since).
        # To skip the db phase we add a predicate that i_db should be &lt; 0 
        q = lk_query_push(q,"i_db","&lt;",int(0).to_bytes(4))

        # If we had not set i_db:&lt;:[u32:0] , lk_watch would check the database before saving the callback and returning. 
        lk_watch(lk,q,find_and_do_next_move)

        # lk_process_while is similar to lk_process but can wait for new packets until a condition is met.
        # Linkspace processes can get complex registering many callbacks with lk_watch and waiting for multiple unordered packets. 
        # Our case is simple.
        # There is only one watch, and only one reason for it to be done.
        lk_process_while(lk,qid=b"move")
        # The current player made a move, and we can continue to the next round

# Our game is done
print("Fin")
</pre>
</div>

</div>
</div>
</div>


<div id="outline-container-org2dfbfc1" class="outline-2">
<h2 id="org2dfbfc1">Cheating</h2>
<div class="outline-text-2" id="text-org2dfbfc1">
<p>
There are three ways to deal with cheating.
</p>

<p>
Four if you count Bobs disapproval as an option.
</p>


<figure id="orgb9e8912">
<img src="../images/bob-angry.png" alt="bob-angry.png">

</figure>

<p>
Keep in mind what is normal today.
</p>

<p>
Opening a game on your phone or browser usually means it connects to a single host.
This host receives your moves, it checks their local hidden state, and return you a result.
In one sense this is better, only the host can cheat.
On the other hand, only the host can cheat and nobody would know about it.
</p>
</div>

<div id="outline-container-orge8e7331" class="outline-4">
<h4 id="orge8e7331">Who cares?</h4>
<div class="outline-text-4" id="text-orge8e7331">
<p>
The option you should take by default.
Most games <span class="underline">can</span> be cheated, so the upside of making it more difficult has its limits.
</p>

<p>
Scrabble or Chess can use helper tools you can't detect.
Shooter games have aimbots and 'see-through-walls' cheats.
</p>

<p>
Most players are not cheaters, even if they could.
Trusting your peers save a lot of hassle.
For a game like MineWeeper that is usually enough.
</p>
</div>
</div>

<div id="outline-container-org108120c" class="outline-4">
<h4 id="org108120c">Emulate host/client</h4>
<div class="outline-text-4" id="text-org108120c">
<p>
One option is to emulate a host/client setup.
The first player could act as host and watch for turns and reply with the result.
</p>

<p>
A slight tweak already makes this more fair than what is normal today.
The host could have their game_pkt contain a link to a datapacket with the game field, without actually making it available.
Once the game is done, the host can release the packet and players could check if the host was honest.
</p>
</div>
</div>

<div id="outline-container-orgca9b7d7" class="outline-4">
<h4 id="orgca9b7d7">Rng-esus died for your sins</h4>
<div class="outline-text-4" id="text-orgca9b7d7">
<p>
There are a number of ways to define a set of rules that make the game random without anyone knowing the full mine map.
</p>

<p>
There are two obstacles:
</p>
<ul class="org-ul">
<li>Agreeing on a random value nobody can tamper with.</li>
<li>How to deal with the cell numbers that represent how many mines surround it.</li>
</ul>

<p>
One option for a random number is relatively simple.
Every player acknowledges the turn before applying it.
Once you have every ack packet you can combine the ack.hash bytes to get a random val nobody can tamper on their own.
</p>
<div class="org-src-container">
<pre class="src src-python">ack_link = Link("ack",player_turn_pkt.hash)
# Its best to enforce a value for the 'create' stamp so there is less ambigiouty on what the 'correct' packet must look like
ack_pkt = lk_keypoint( create=player_turn_pkt.create, link = [ack_link])~
acked = dict()
def collect_acks(ack_pkt):
    if list(ack_pkt.link) == [ack_link] and ack_pkt.create == ack_pkt.create:
        acked.insert(pkt.pubkey,pkt.hash)
        if len(acked) == players:
            return False

lk_watch(lk,lk_query_parse(q,":qid:acks"),collect_acks)
lk_process_while(qid="acks")
seed = itertools.reduce(lambda xored, hash: xored ^ hash, acked.values())

</pre>
</div>

<p>
That leaves us with the more difficult issue:
</p>

<p>
Showing the number of mines surrounding a cell, without letting cheaters peek into which ones are non-mines.
</p>

<p>
One solution is to postpone determining which cell has the mine.
We have to add a 'solver'.
Just like a non-cheater, the solver can calculate the probabilities of hidden fields based on the revealed cells.
</p>

<p>
With the random seed determined after making a move, and the cell mine probability adjusted for what is already revealed, cheating becomes impossible.
</p>
</div>
</div>
</div>

<div id="outline-container-org116a513" class="outline-2">
<h2 id="org116a513">A dose of reality</h2>
<div class="outline-text-2" id="text-org116a513">
<p>
In the next installment Bob will continue his journey to building the best game ever.
This time by building a lobby system so it's actually playable.
</p>

<p>
In the meantime, a little expectation management is in order.
</p>

<p>
Various components and systems required for linkspace are still in their early days.
It Works On My Machine<sup>tm</sup>.
Some tools and standards don't exist yet or are only partially implemented.
</p>

<p>
It's a project to rebuild the internet into something better.
That means taking some steps backwards before going forward.
At version 0.2.0 its reached the usability of 1980's email.
It works, but its not pretty nor user friendly.
</p>

<p>
That being said, there are currently no breaking changes to Bob's program planned.
And every improvement to other systems improves the experience of using a linkspace application.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2023-04-28 Fri 17:16</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>