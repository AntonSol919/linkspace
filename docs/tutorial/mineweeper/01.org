#+TITLE:  MineWeeper 
#+SUBTITLE: A Linkspace Application Tutorial
#+AUTHOR: Anton Sol

#+SETUPFILE: ../../utils.org
#+INCLUDE: "../../utils.js" export html 

#+HTML_HEAD: <link rel="icon" type="image/x-icon" href="../../../images/logo2.png">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./style.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./blog.css"/>

This is the first a series of tutorials to showcase linkspace.
A protocol designed to be a foundational layer for our digital space.
Linkspace is a [[https://antonsol919.github.io/linkspace/index.html][supernet]]. With it we can talk about data instead of at servers.

We'll follow Bob in his journey.

[[../images/bob-hi.png]]

He build the greatest and must impressive game ever.  
Or so he says.

The game is MineWeeper: A Multiplayer minesweeper clone where players take turns. 

To follow along, the follow knowledge/skills are assumed:

- a basic level of python (You know what ~val = int(input("value")~ does)
- basic devops (a terminal doesn't scare you, worst case you'll google what ~xargs~ does)
- the difference between a string and bytes
- What a RNG seed is.
- What a hash and public keys is.
- Curious enough to hack together tools to do what you want it to do (OpenGPT isn't going to solve this one)

In linkspace the responsibilities for things are different to what you might be used to.

An application developer has drastically fewer responsibilities.
Things like networking, servers, registration, users, groups, and read/write access are all outside the scope of what an application has to deal with. 
The app developer need only think about: bytes, linking to bytes, and reading bytes by link or path name.

This tutorial won't be about the user or group setup.

Linkspace aims to be simple compared to what an equivalent stack would look like.
If your usecase is streaming data between two points over a socket, linkspace will obviously lose that proposition.
But once more things are added to the mix, such as having 'user' and multiple people interacting, linkspace might be the simplest solution.

Note however, I do mean simple, not easy.
Linkspace is 30 years behind in tooling to make things as easy as the web is today.

Before you continue, please check this consent form to not hold Bob accountable for the dumb stuff you share and do.

#+BEGIN_EXPORT HTML
<div> 
<input type="checkbox" id="consent" name="consent">
<fieldset id="consent-form">
    <legend>Consent form</legend>
    <label for="consent">Click to Consent [ ] </label>
</fieldset>
<div id="consent-ok">
<img src="../images/bob-cheer.png" alt="bob-cheer.png">
<p>With that piece of vital and productive administration out of the way, let's check out what Bob has build</p>
</div>
</div>

#+END_export


* Bob's Hotseat MineWeeper

Bob's game is perfect.
However, there is one tiny, little, detail missing.

It only works in hotseat mode.
That is, every player has to be at the same keyboard taking turns.

Bob's a friendly guy, but he doesn't want you coming to his house.
Instead, he'll build something real quick, such that anybody can play it with their friends over the internet.

No biggy.

First, how does the game work in hotseat mode?

It asks the user for a list of player names.
Players take turns entering which cell to reveal until someone reveals a mine or no more safe cells exist.

#+begin_verse
This post was made for version 0.2.0
Download and extract the pkg zip.
Paths and commands are relative to this directory.
To give hotseat mineweeper a try: 
~python ./app/mineweeper-py/mineweeper-hotseat.py~
#+end_verse

#+begin_py
#+INCLUDE: "../../../examples/app/mineweeper-py/mineweeper-hotseat.py" src python
#+end_py

Bob's a little disappointed with the graphics.
He's waiting for those VC bucks to hire professionals to port it to the next Unreal Engine with RTX graphics in VR.
[[../images/bob-doubt.png]]

#+begin_ctabs
#+begin_info
Contrary to Bob, we don't care much for the details of MineWeeper.
In case you're interested checkout the tab or open the code in ./app/mineweeper-py/mineweeper.py
#+end_info

#+begin_py
#+INCLUDE: "../../../examples/app/mineweeper-py/mineweeper.py" src python
#+end_py
#+end_ctabs

* Game on

After searching high and low, our friend Bob reaches for enlightenment.

[[../images/bob-enlightend.png]]


He finds linkspace.

A thoroughly untested protocol with very few users.
But he figures it's the best solution to make MineWeeper a true multiplayer game.

With linkspace:
- his (user administrative) workload drops dramatically.
- the game will stay playable without him spending a penny. Forever.
- user network/account/group problems can be solved once (hopefully by someone else).

Bob might be a little biased. He suffers from PCSSD, or Post Customer Support Stress Disorder.
So Bob likes the idea of building the application experience wigame without being  game without pretending to be a fullstack developer or binding 

Developing linkspace system boils down to:

- Gather some bytes you want sent around in a packet.
- Optionally: set a path, add links to other packets, sign it.
- Save that packet.
- Build a query: a list of predicates for a packet (e.g. pubkey, hash, path). 
- Get or watch for those results.


For Bob, the linkspace library is an abstraction that moves bytes around between players.

In the linkspace world, Bob's game is a domain application.
A program providing a friendly interface reading/writing the bytes that the developer wants to be shared around.

#+begin_verse
When the program calls the 'lk_pull' function for a query, the requested bytes saved with lk_save on another machine eventually become available.
This is done by a linkspace group exchange process. A group exchange process is build just like a domain application.
But its role is to exchange all packets with its group ID to the members that require it.
More on them another day.
#+end_verse

Bob recognizes that his game has two distinct phases.

- Finding the people to start playing it with.
- Actually taking turns to play the game.

He'll start with 'play the game', and build the lobby system for proposing/joining/starting a game later.

He's not set on the details, but every game starts with at least the players knowing:

- a list of (player names, pubkey).
- number of rows & columns.
- mine_rate.
- RNG seed.

#+begin_verse
In this setup everybody knows the board, but we'll touch on [[Cheating][Cheating]] later.
#+end_verse

For an initial test, Bob will assume three players agreed that the following packet is the start of a game.

 # #+BEGIN_SRC bash :session cli0 :exports result :results output verbatim :cache yes
 # cat ../../../examples/private/setup.pkt  | lk p
 # #+END_SRC

#+RESULTS[120bdb7bb9e047a26774463083e95ad81197dd8c]:
#+begin_example
type	LinkPoint
hash	VJPxHigyCAmXvPojLxAQzHGYOiZDHP46ztaPZzMm6to
group	[#:test]
domain	mineweeper
path	
pubkey	[@:none]
create	1682062494375521
links	0

data	278
{
    "rows":20,
    "columns": 20,
    "mine_rate":0.3,
    "players":[
        ["alice", "iyfplTMDFj3Jw8XwdfwvXs9ZVgwwYZNsQ3E7cS55kLQ"],
        ["bob", "qfurOQ2oTD1Xc9dQf_gX2MXbsbALdXQ_XemF0aTlj6U"],
        ["charlie", "2SYK3NlS8k4ELKWR6CmqIQAiPrMosr5LioK7456jnDY"]
    ]
}
#+end_example

The data field is just bytes, and Bob decides to encode the fields as JSON.
A 'seed' field doesn't seem to be necessary, the hash of the packet can fill the role.

#+begin_ctabs
#+begin_info
Bob isn't infallible, so in building this he needs to test it locally.
The ./try-local folder contains two script to create a dummy network.
It requires tmux to be installed (available in most package managers)
#+end_info

#+begin_setup
You can create an instance with a simple exchange process running by starting:

#+begin_src bash
./try-local/host.session.tmux.sh
#+end_src


Open a terminal and execute the following to create additional instances automatically connect.

#+begin_src bash
./try-local/session.tmux.sh bob #changing this name
#+end_src

Finally, we have to create the initial packet and share them.
One method to do so is as follows:

#+begin_src bash 
  cd private
  cat ./*/name_key > setup.json
  # You'll have to edit this setup.json by hand to look like the json above. 
  lk link mineweeper:[#:test] --data file:./setup.json > setup.pkt

  # Manually save this packet to each instance
  find ./ -mindepth 1 -maxdepth 1 -type d -exec lk --dir "{}" save --pkt-in ./setup.pkt \;
#+end_src

#+end_setup
#+end_ctabs


* Multiplayer

The outline is as follows:

- open the linkspace instance and a signing key. 
- read the 'game_pkt' that starts the game by its hash.
- load the settings, including a list of [player names,pubkeys]

while not done:
- Print the state
- If its our turn, make a choice and save the move info
- Else wait for the packet encoding the turn from the current player.

#+begin_py
#+INCLUDE: "../../../examples/app/mineweeper-py/mineweeper-multiplayer.py" src python
#+end_py


* Cheating

There are three ways to deal with cheating.

Four if you count Bobs disapproval as an option.

[[../images/bob-angry.png]]

Keep in mind what is normal today.

Opening a game on your phone or browser usually means it connects to a single host.
This host receives your moves, it checks his local hidden state, and return you a result.
In one sense this is better, only the host can cheat.
On the other hand, only the host can cheat and nobody would know about it.

*** Who cares?
The option you should take by default.
Most games _can_ be cheated, so the upside of making it more difficult has its limits.

Scrabble or Chess can use helper tools you can't detect.
Shooter games have aimbots and 'see-through-walls' cheats.

Most players are not cheaters, even if they could.
Trusting your peers save a lot of hassle.
For a game like MineWeeper that seems like a good solution.

*** Emulate host/client
One option is to emulate a host/client setup.
The first player could act as host and watch for turns and reply with the result.

A slight tweak already makes this more fair than what is normal today.
The host could have their game_pkt contain a link to a datapacket with the game field, without actually making it available.
Once the game is done, the host can release the packet and players could check if the host was honest.

*** Rng-esus died for your sins

There are a number of ways to define a set of rules that make the game random without anyone knowing the full mine map.

There are two obstacles:
- Agreeing on a random value nobody can tamper with.
- How to deal with the cell numbers that represent how many mines surround it.

One option for a random number is relatively simple.
Every player acknowledges the turn before applying it.
Once you have every ack packet you can combine the ack.hash generate a random val.
#+begin_src python
  ack_link = Link("ack",player_turn_pkt.hash)
  # Its best to enforce a value for the 'create' stamp so there is less ambigiouty on what the 'correct' packet must look like
  ack_pkt = lk_keypoint( create=player_turn_pkt.create, link = [ack_link])~
  acked = dict()
  def collect_acks(ack_pkt):
      if list(ack_pkt.link) == [ack_link] and ack_pkt.create == ack_pkt.create:
          acked.insert(pkt.pubkey,pkt.hash)
          if len(acked) == players:
              return False

  lk_watch(lk,lk_query_parse(q,":qid:acks"),collect_acks)
  lk_process_while(qid="acks")
  seed = itertools.reduce(lambda xored, hash: xored ^ hash, acked.values())

#+end_src

That leaves us with the more difficult issue:

Showing a number of surrounding mines, without letting cheaters peek into which ones are non-mines.

Not impossible, just annoying.
One solution is adding a 'solver' into game.
Just like a non-cheater, it can calculate the probabilities of hidden fields based on the revealed cells.
By using a the random seed as shown above and adjusting for a cell's probability of holding a mine cheating becomes impossible.

* A dose of reality

In the next installment Bob will continue his journey to building the best game ever.
This time by building a lobby system so it's actually playable.

In the meantime, a little expectation management is in order.

Various components and systems required for linkspace are still in their early days.
It Works On My Machine^{tm}.
Some tools and standards don't exist yet or are only partially implemented.

It's a project to rebuild the internet into something better.
That means taking some steps backwards before going forward.
At version 0.2.0 it has reached parity with early 1980s. Email works, but not particularly well.

That being said, there are currently no breaking changes to Bob's program planned.
And every improvement to other systems improves the experience of using a linkspace application.
