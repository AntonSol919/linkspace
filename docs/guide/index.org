#+TITLE: The Linkspace Protocol Guide
#+AUTHOR: Anton Sol
#+OPTIONS: H:3 num:nil \n:nil ::nil |:t ^:{}  *:t author:nil email:nil creator:nil 
#+OPTIONS: html-style:nil

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>

#+LANGUAGE: en



#+BEGIN_VERSE
This is a living document, it is not yet finished, things are broken, and is kept up to date on a best effort basis.
Sometimes the [[../cargo-doc/liblinkspace/index.html][liblinkspace]] docs is ahead of this guide.
#+END_VERSE

* Introduction

The Linkspace Protocol provides a structure to build multi-user applications.
[[../cargo-doc/liblinkspace/index.html][liblinkspace]] implements this protocol.
At its core it is a packet layout which are indexed by their hash and their path.

If those words mean little you should begin at [[../../eli5.html][eli5]].

Projects such as Git, BitTorrent, Matrix, IPFS, and various blockchains already proof that addressing content is a powerful abstraction.
It sidesteps or solves a number of difficulties inherent in organizing data as a stream in multi-user applications.
When the content in such a system includes objects that link other content by its hash the system can be classified as a supernet.

The issue with supernets so far, is that they are bound to their use-case.
The Linkspace Protocol is a general purpose solution.
It is built to be fast and simple.
#+BEGIN_VERSE
Supernet  [ˈsü-pərˌnet]

A self-referential multi-user data organization protocol whose primary
addressing method uses hashes instead of endpoint identifiers.
A communication protocol where the method of exchange is an extraneous concern.
e.g. git, bitcoin, nostr, the linkspace protocol
#+END_VERSE

The supernet paradigm is a trade-off.
Instead of processing ordered streams of network data, an application is a function over the partial watch of (potentially noisy) interlinked state.

The Linkspace Protocol is best understood as 4 ideas.

- [[Point]] - Three types of packets
- [[ABE]] - (Byte) templating
- [[Query]] - Query for selecting packets
- [[Linkspace]] - Packet index and callbacks

A big addition compared to similar systems is the split between domains and groups.
It separates the responsibility of 'User Interface & Data Structure' with the 'Members and the exchange of data'.
This split and other standard problems, are supported by a set of (growing) [[Conventions]].

There are a number of ideas that built on each other.
To see what they allow you to do checkout the [[#imageboard][imageboard]] example


* Setup

This guide uses Python and (Bash) CLI snippets.
You can get the latest version from [[https://github.com/AntonSol919/linkspace][GitHub]]

** linkspace-cli

~make install-lk~ or:

#+BEGIN_SRC bash
cd cli/linkspace
cargo install --path .
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim
lk --version
#+END_SRC

#+RESULTS:
#+begin_example
linkspace-cli 0.1.0
#+end_example


** lkpy - linkspace python bindings

~make install-lkpy~ or: 

#+BEGIN_SRC bash
cd ffi/liblinkspace-py
make
source ./.env/bin/activate
python -i
>>> import * from lkpy
#+END_SRC

* API overview
:PROPERTIES:
:CUSTOM_ID: api
:END:

The liblinkspace API is a small set of functions that is mostly stable.
It is available as a Rust crate ~liblinkspace~ and binding for other languages follow this API.

It consists of the following functions:

- [[Point]] creation
  - [[file:::#datapoint-py][lk_datapoint]]
  - [[#lk_linkpoint][lk_linkpoint]]
  - [[lk_keypoint]]

- [[ABE]] - ascii byte expressions - a language for manipulating and templating bytes
  - [[lk_eval]]
  - [[lk_encode]]

- [[Query]] - Addressing and filtering of packets with predicates and options
  - [[lk_query]]
  - [[lk_query_parse]]
  - [[lk_query_push]]
  - [[lk_query_print]]

- [[Linkspace]] - Locally indexed packets and new packet processing functions
  - [[lk_open]]
  - [[lk_save]]
  - [[lk_read]]
  - [[lk_watch]]
  - [[lk_process]]
  - [[lk_process_while]]

- [[Conventions]] - functions
  - [[lk_status_set]]
  - [[lk_status_poll]]
  - [[lk_pull]]
  - [[lk_key]]


* Point
:PROPERTIES:
:CUSTOM_ID: Point
:END:

#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/point/index.html][Rust docs]]
#+END_VERSE

Points are the basic units in linkspace.
They carry data, link to other points, and might contain information about the who, what, when, and how.
There are 3 kinds of points. datapoints, linkpoints, and keypoints.
A point has a maximum size of 2^{16}-512 bytes.

Building a point is always combined with generating a hash and prepending a netheader.
Together the [netheader, hash, point] form a netpacket.
All functions deal in netpacket.

Writing an application is the art of defining a relationship between the points.



** lk_datapoint

**** Bash


#+BEGIN_SRC bash :session cli2 :exports both :results output verbatim
echo -n "Hello, Sol" | lk data | lk printf "[hash:str]\n[data]"
#+END_SRC

#+RESULTS:
#+begin_example
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
#+end_example



**** Python
:PROPERTIES:
:CUSTOM_ID: datapoint-py
:END:
#+begin_src python :session lkpy :exports both :results value verbatim
from lkpy import *
datap = lk_datapoint(b"Hello, Sol")
lk_eval2str("[hash:str]\\n[data]", datap)
#+END_SRC

#+RESULTS:
#+begin_example
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
#+end_example



** lk_linkpoint
:PROPERTIES:
:CUSTOM_ID: lk_linkpoint
:END:


A linkpoint creates relations between packets by their hash and its location.

It consists of these fields:

| Field_{size}      |                                                   |
|-------------------+---------------------------------------------------|
| Group_{32}        | the intended recipients.                          |
| Domain_{16}       | the intended application.                         |
| Path_{var<240}    | Sequence of bytes. e.g. '/dir1/dir2/thing'        |
| Stamp_{8}         | Big endian UNIX timestamp in microseconds.        |
| Links_{48*n}      | A variable length list of (Tag_{16}, Pointer_{32}) |
| Data_{var<2^{16}} |                                                   |

A packets' location refers to its (Domain, Group, Path) triple.
All values, including the Path, contain arbitrary bytes.

#+BEGIN_VERSE
Packet hashes, GroupID's, and public keys are 32 bytes.
They are usually encoded in URL-safe no-padding base64, e.g. ~RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF~.
These hashes quickly make things unreadable.
The ~[...]~ syntax ([[ABE]]) allows us to name and manipulate bytes.
This following example shows that ~[#:pub]~ resolves to the bytes ~RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF~ in both the Group and the second link
Furthermore, If no group was provided it defaults to ~[#:pub]~
#+END_VERSE

**** Bash
The command ~lk link~ can build linkpoint packets and output's them to stdout by default.
Whenever a cli commands deal with (domain, group, path) tuples, they can be set as the first argument: ~DOMAIN:GROUP:PATH~.
Two links are added with the tags ~first_tag_1~ and ~another_tag~


#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim
    lk link "a_domain:[#:pub]:/dir1/dir2/thing" \
              -l first_tag_1:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0 \
              -l another_tag:[#:pub] \
    | lk printf
#+END_SRC

**** Python

The library requires the actual bytes. We can get them directly from fields or evaluate a string with [[lk_eval]].

#+begin_src python :session lkpy :exports both :results value verbatim 
  ptr1 = lk_eval("[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]")
  ptr2 = lk_eval("[#:pub]")
  datap = lk_datapoint(b"Hello example");
  assert(ptr1 == ptr2)
  link1 = Link(tag=b"first tag 1",ptr=ptr1)
  link2 = Link(b"another tag",ptr2)
  link3 = Link(b"a datapacket",datap.hash)
  linkp = lk_linkpoint(domain=b"example domain", group=lk_eval("[#:pub]"), 
                       data=b"Hello, World!",
                       links=[link1,link2,link3]
                       )
  str(linkp)
#+END_SRC

#+RESULTS:


#+BEGIN_VERSE
Datapoints do not have a 'create' field, so they get the same hash given the same data.
If we had forced a specific 'create' stamp for both the python and bash example it would have produced the same hash for both.
Instead, 'create' defaults to the current time ( microseconds since epoch ), and thus the hash is different.
#+END_VERSE



** lk_keypoint 
:PROPERTIES:
:CUSTOM_ID: lk_keypoint
:END:

A key point is a linkpoint with an additional publickey and signature.


**** Bash

#+CAPTION: Set up an instance and generate a key

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim
  export LINKSPACE=/tmp/linkspace
  lk --init key --insecure --password "my secret" 
#+END_SRC

#+RESULTS[ef50fbd3a064bdc4806047f0b94c0b4dd96a1473]:
#+begin_example
$argon2d$v=19$m=8,t=1,p=1$nImq4QuSChPuxOTxSAn1M50ufSPtJS0B3PStyfrLWsw$WPLlUlenQiN264nt64DGxKE3k5LNl3C9RGrgIG575nU=
nImq4QuSChPuxOTxSAn1M50ufSPtJS0B3PStyfrLWsw
#+end_example
 

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk keypoint "example::" --password "my secret" | lk printf
#+END_SRC

#+BEGIN_VERSE
The CLI also accepts ~lk link --sign~ instead of ~lk keypoint~
#+END_VERSE


#+RESULTS:
**** Python


#+begin_src python :session lkpy :exports both :results value verbatim
  lk = lk_open("/tmp/linkspace")
  key = lk_key(lk,b"my secret");
  example_keypoint = lk_keypoint(key=key,domain=b"example")
  str(example_keypoint)
#+END_SRC

#+BEGIN_VERSE
[[lk_key]] is a function combining lk_keygen, lk_keystring, lk_keyopen, that stores the encrypted string in a linkpoint
such that you can later reference it as ~[@local:me]~ ( [[#ABELNS][ABE]] ) or ~[@:me:local]~
#+END_VERSE


** Notes

Groups conceptually indicate the intended set of recipients and practically the method of data exchange.
Domains conceptually indicate the activity, and practically the application used to present an interface to the user.

I.e. The groups bytes are simply chosen and membership is enforced by its members.
They can have a special meaning, such as public key or a pointer to a list of publickeys that act as administrators.

The following do have a meaning.
The [0;32] null group ( ~[#:0]~ ), i.e. the local only group, is never transmitted to other devices and is never accepted from outside sources.
Everything in the ~[#:pub]~ group[fn:: the hash of ~lk_datapoint(b"Hello, Sol")~] is meant for everybody. e.g. the public.

By convention the group created by pubkey1 XOR pubkey2 forms a group with those keys as its only two members.

#+BEGIN_VERSE
The ~[#:...]~ is part of the Linkspace Naming System ( [[LNS]] ).
A public registry for assigning names and naming rights.
e.g. ~[#:sales:mycomp:com]~ for groups and ~[@:alicekey:mycomp:com]~ for keys.
#+END_VERSE

* ABE
:PROPERTIES:
:CUSTOM_ID: ABE
:END:

#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/abe/index.html][Rust docs]]
#+END_VERSE



ABE (Ascii-Byte-Expr) is a tiny byte templating language.
Its primary purpose is to make it easy for developers to read and write arbitrary (0..=255) bytes in plain ascii,
but it can add context's ( such as a linkspace instance) and evaluate expressions ( such as a 'name' for a public key ).

Linkspace has no concept of encoding.
Fields have a fixed length or prefix their exact length.
The ~null~ (0) byte is not special.

Things like [[Query]] or simply printing a text representation of a packet use ABE.

#+BEGIN_VERSE
Note that its up to the application how to display the bytes to the end user.
For instance, they could demand the bytes are valid UTF8 containing one emoji and ignore packets otherwise.
#+END_VERSE

** Parsing

- Most printable ascii letters are as is.
- The external delimiters ~'\n'~ (newline) and ~'\t'~ (tab) are invalid characters.
- the internal delimiters ~:~ , ~/~.
- ~[~ and ~]~ wrap an expression
- ~:~, ~/~, ~\~, ~[~, ~]~  can be escaped with a ~\~.
- ~\x00~ up-to ~\xFF~ for bytes.
- ~\0~ equals  ~\x00~,  ~\f~ equals ~\xFF~

** lk_eval

ABE is evaluated by substituting an expressions ( ~[..]~ ) with its result.
For example in ~[u8:97]~, the function 'u8' parses "97" and prints it.
The byte 97 equals the character 'a'. 


#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk eval "ab[u8:99]" | xxd
#+END_SRC
The result of an ABE is a list of (bytes, ?delimiter). 

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk eval --json "h[u8:101]ll[u8:111] / world:etc" 
#+END_SRC

#+RESULTS[2ec16903cc5e3a32f07215dd1f2a5ad514fa17ac]:
#+begin_example
[[[104,101,108,108,111,32],"/"],[[32,119,111,114,108,100],":"],[[101,116,99],null]]
#+end_example

Note that bytes are joined after evaluating. In the example this results in the component ~('hello ', /)~.
The delimiters ('\n' '\t' ':' '/') are interpreted depends on the context.
In the top level of the template given to ~eval~ they are printed as is.

In other words: ~eval "hello/:[u8:99]\n"~ == ~hello/:c\n~ ,
but within brackets they have a special meaning:  ~eval "hello/:[hello/ \n :]"~ will error.

#+Begin_VERSE
The rest of this chapter goes further in depth.
Understanding the ABE language in depth is not critical.
With basic knowledge of expression substitution (~[..]~) and the ~':'~, ~'/'~ delimiters the reader can choose to
skip to the next chapter [[Query]] and return here for reference later.
#+end_VERSE


*** Sub-expressions

A list of functions/evaluators be found by evaluating [[Help][[help]].

**** Functions

- ~[fn]~
- ~[fn:arg0]~
- ~[fn:arg0:arg1]~

The arguments are bytes. They take upto 8 arguments.
The resulting bytes are concatenated with their surrounding.
The empty function ~'[:...]'~ resolves to its first argument.

- ~hello [:world]~ == ~hello world~

Arguments are evaluated before application.
~[fn0:[fn1]]~ will call fn1 and use its result as the first argument to fn0.

You can carry results with ~/~.
It uses the result as the first argument to the next function.

- ~[:97/u8]~ == ~[u8:97]~ == ~a~
- ~[:97/u8/?u]~ == ~[?u:[u8:97]]~ == ~97~
  
You can think of ABE functions as a translation of conventional function calling.

| ~[name:arg1:arg2]~              | ~name(arg1,arg2)~                  |
| ~[name:[other_name:argA]:arg2]~ | ~name( other_name(argA) , arg2 )~  |
| ~[other_name:argA/name:arg2]~   | ~name ( other_name(argA) , arg2 )~ |


#+BEGIN_VERSE
Functions are aware if they are first or not.
The vast majority of functions do not care.
#+END_VERSE

#+BEGIN_VERSE
~[[:u8]:97]~ is explicitly not allowed. Variable function identifiers are conceptually interesting but practically begging for bugs.
#+END_VERSE

**** Evaluators
The second type of operation is calling an evaluator.
Whereas functions are called after their arguments are evaluated.
Evaluators are called without evaluation ~[..]~ expressions.

- ~[/re]~
- ~[/re:arg0:arg1]~
- ~[/re:[fn:arg0]:arg1]~

The ~/re~ evaluator operates on ~:[fn:arg0]:arg1~ without it being evaluatedd.[fn:: similar to some definition of 'macros']

The most common use-case for evaluators is extending the scope.

*** Scope & context

Functions and evaluators are defined in a scope.
The standard scope contains functions to manipulate bytes.
Some scopes require a context.

**** Packet scope

By providing a packet, the packet scope is added.
This adds operations to evaluate packet fields such as ~hash~, ~group~, ~path~ etc.
These are bytes that you can use as arguments.

e.g ~[hash/?b]~ encodes the hash in base 64.

For convenience all packet fields accept 'str' and 'abe' as a first argument to print them in a default format.
| ~[hash:str]~     | ~[hash/?b]~      |
| ~[group:str]~    | ~[group/?b]~     |
| ~[create:str]~   | ~[create/?u]~    |
| ~[links_len:str] | ~[links_len/?u]~ |
| ...              |                  |

The ~[/links:...]~ evaluator iterates over every link in a packet.
It evaluates the inner scope for each link with setting the ~tag~ and ~ptr~ function.

**** bash
~printf~ is similar to ~eval~ except that it reads packets from stdin and uses them as context.

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
  lk link "::" -l tag1:[#:0] -l tag2:[#:pub] | \
      lk printf "HASH:[hash/?b]\n[/links:TAG = [tag:str] PTR = [ptr:str] \n]"
#+END_SRC

**** python

#+begin_src python :session lkpy :exports both :results value verbatim
datap = lk_datapoint(b"hello")
lk_eval2str("[data] or in base64 [data/?b]",datap)
#+END_SRC

- Linkspace scope

Having a linkspace instance in the scope gives you access to functions like:

- ~?~ to access packets by their hash
- ~#~ and ~@~ ( see [[LNS]] ) for publicly named groups, keys, and other data
- ~#local~ and ~@local~ for privately named groups, keys, and other data.
- ~readhash~

In the library [[lk_open]] does this automatically.

*** Usage notes

ABE expressions evaluate into a list of [ (bytes,?sep) ].
Sometimes each element has a different meaning, e.g. [ ( domain , : ) , (group , _) ] in the CLI arguments.
It's also common to turn the result directly into bytes. 
~lk_eval~ does just that. To interpret each item use the ~lk_split_abe~ function.

Finally, consider what you would expect to happen when an evaluator takes a ABE expression as its final argument:

- ~[/links:abc[:hello]/world]~
- ~[/readhash:[#:pub]:the pkt:[pkt]]~
- ~[/:hello/world]~
- ~lk link :: --write 'file:./afolder:with/colons'~

The choice was made that if the final argument is a abe expression that will be evaluated, the separators are interpreted as is.
Thereby greatly reducing the need to escape ':' and '/', but complicating some other expressions.

#+BEGIN_VERSE
We can add an expression to --write arguments
~lk link :: --write "stdout-expr:hello world:/ [hash:str]"~
In case of ~file~ this leaves us in the situation that second argument is the file and the tail of the expression will be evaluated
The simplest way to ignore all escapes is to use empty evaluator ~[/:..]~. 
~lk link :: --write "file-expr:[/:./afolder:with/colons]:hello world:/ [hash:str]"~
#+END_VERSE


*** Help
:PROPERTIES:
:CUSTOM_ID: abe-help
:END:

A full list of active scopes can be viewed with the ~help~ function.

#+BEGIN_VERSE
The following naming conventions are used:

- ending with '?' is a predicate to check a property.
- starting with '?' is a basic reverse operation , e.g. ~'?a'~, the less powerful [[lk_encode]] ( This is different but related to [lk_encode], the more powerful reverse op)
- b_RADIX_ ( b2, b8, b16 ) 'b' defaults to base64 radix
- u_SIZE_  ( u8, .., u128 ) parse decimal into big endian bytes. ?u interpret as big endian print to decimal
#+END_VERSE

**** python

#+name:abe-help-py
#+custom_id:abe-help-pyid

#+begin_src python :session lkpy :exports both :results value verbatim
lk_eval2str("[help]",lk_linkpoint())
#+END_SRC

** lk_encode
:PROPERTIES:
:CUSTOM_ID: lk_encode
:END:

Translate bytes into abe such that ~lk_eval(lk_encode(X)) == X~
**** python


#+begin_src python :session lkpy :exports both :results output verbatim
  data = bytes([0,0,0,255])
  abe = lk_encode(data)
  assert data == lk_eval(abe)
  print("ab  text:", abe)
  abe = lk_encode(data,"u8/u32/b") # Try to encode as expression
  print("abe text:", abe)
#+END_SRC

We can get meta. lk_encode is available as the evaluator ~[/?:bytes:options]~


** lk_split_abe
:PROPERTIES:
:CUSTOM_ID: lk_split_abe
:END:



** LNS
:PROPERTIES:
:CUSTOM_ID: ABELNS
:END:

LNS is a system for publicly naming keys and groups, (or adding auxiliary data to them).
It allows you to register as ~@:Alice:nl~, ~#:sales:company:com~, etc.

LNS is easy to use from an abe expression.
Both to lookup and do a reverse lookup.
To get a name for a group or public key you can do:

#+begin_src python :session lkpy :exports both :results output verbatim
  group = example_keypoint.group
  print("The bare bytes:", group)
  
  # encode as b64
  b64 = lk_encode(group,"b") 
  print("b64 encoded   :", b64)

  # Try to express as a [#:..], on failure try as [@:..], try the local, fallback to [b:...]
  try_name = lk_encode(group,"#/@/#local/@local/b") 
  print("Or through lns:", try_name)

  print("Pkt's pubkey  :",example_keypoint.pubkey)
  try_keyname = lk_encode(example_keypoint.pubkey,"#/@/#local/@local/b")
  print("Similarly lns :", try_keyname)


#+END_SRC

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
  lk eval "[#:pub]" | lk encode "@/#/@local/b"
#+END_SRC

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
  lk eval "[@local:me]" | lk encode "@/#/@local/b"
#+END_SRC


Currently, the following are available:

~[#:pub]~ for the public group.
~[#:0]~ for the local only group.
~[@:none]~ 

It will allow you to do a lookup ~

See the [[../../lns.html][lns]] for info.


#+BEGIN_VERSE
You can name keys in your local index, allowing you to reference ~[@local:my_identity]~ or ~[#local:friends]~
By default [[lk_key]] sets up the ~[@local:me]~ identity.
The function to do so is not yet exported (crates/common/protocol/lns/local.rs::build_local_lns_points)
#+END_VERSE



* Query
:PROPERTIES:
:CUSTOM_ID: Query
:END:


#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/query/index.html][Rust docs]]
#+END_VERSE

A query is a list of predicates and options used to select a set of packets.
They are used by the local index ( [[lk_watch]] and [[lk_read]] ),
or to signal what packets should be found looked for in the group ( [[lk_pull]] ),
or as a filter function.

** lk_query
:PROPERTIES:
:CUSTOM_ID: lk_query
:END:


Queries are newline separated.
Predicates are an [[ABE]] 3-tuple ~field ':' test-operation ':' value~ and constrain the set of accepted packets.
Options are context dependent and start with ':'

#+Caption: select everything signed by me in ~example:[#:pub]:/hello/world/**~ with a max data size of 255, with between 2 and 8 links from the tree index and follow it's the links
#+BEGIN_EXAMPLE
group:=:[#:pub]
domain:=:example
data_size:<=:[u16:256]
prefix:=:/hello/world
pubkey:=:[@local:me]
link_len:>=:[u16:2]
link_len:<=:[u16:8]

:mode:tree-asc
:follow
:watch:gethellos
#+END_EXAMPLE

A predicate can be set multiple times.
They are designed such that you can concatenate two queries.
If the result can only ever be the empty set an error is returned.

There are only 4 basic test operations.

| Basic Op |                                   |
|----------+-----------------------------------|
| >        | greater eq                        |
| <        | less eq                           |
| 0        | all '0' in value are '0' in field |
| 1        | all '1' in value are '1' in field |

The following are shorthand and resolve to one or more of the basic tests.

| Derived Ops |                          |
|-------------+--------------------------|
| =           | >(val-1) and <(val+1)    |
| >=          | >(val-1)                 |
| <=          | <(val+1)                 |
| *=          | Last n-bytes must eq val |
| =*          | First n-bytes must eq val |


The CLI has various aliases that can act as a guide in creating queries by using ~print-query~.

**** bash

#+Caption: A query that matches keypoints with domain 'my' , group '[#:pub]' , path with 2 components starting with  '/hello'

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk print-query "my:[#:pub]:/hello:*" --signed
#+END_SRC

#+BEGIN_VERSE 
Note that many cli commands (e.g. ~print-statemnt~, ~watch~ ) take as the first argument a ~domain:group:path:(?depth)~
If no depth is set the path_len is constraint by default.
Except for ~watch-tree~ which sets the depth to unconstrained by default
#+END_VERSE 

#+begin_src python :session lkpy :exports both :results value verbatim
  q = lk_query()
#+END_SRC

#+RESULTS:


** lk_query_parse
:PROPERTIES:
:CUSTOM_ID: lk_query_parse
:END:

Add multiple constraints to a query. Returns an error if the resulting set is empty.

#+begin_src python :session lkpy :exports both :results value verbatim
  lk_query_parse(q,"group:=:[#:pub]\ndomain:=:example","path_len:<:[u8:4]\ndata_size:<:[u16:10]")
  lk_query_print(q,True) # see next sections
#+END_SRC

** lk_query_push
:PROPERTIES:
:CUSTOM_ID: lk_query_push
:END:

Add a single statement to a query, with the last field in byte format.

#+begin_src python :session lkpy
  lk_query_push(q,"data_size","<",bytes([0,9]))
  lk_query_push(q,"data_size","<",lk_eval("[u16:20]")) 
#+END_SRC

The second predicate is less strict than previous, and will be ignored.

#+CAPTION: Adding contradictions/defining an empty set, returns an error.
#+begin_src python :session lkpy
  try:
    lk_query_push(q,"data_size",">",bytes([0,100]))
  except:
    print("thats not possible")
#+END_SRC



** lk_query_print
:PROPERTIES:
:CUSTOM_ID: lk_query_print
:END:

Print a query as text.
The query will have merged overlapping predicates
The last argument sets whether to create abe expressions or stick to ab-text with out the expressions

#+begin_src python :session lkpy :exports both :results value verbatim
  lk_query_print(q,True)
#+END_SRC

#+BEGIN_VERSE
The ~b2~ function read a binary representation.
The types are: datapoint=[b2:0000_0001], linkpoint [b2:0000_0011], keypoint [b2:0000_0111].
Setting 'group', 'domain', 'path', 'links', or 'create' predicates automatically exclude the datapoint type.
Setting pubkey or signature excludes link and data points.
#+END_VERSE



** More on predicates

#+Begin_VERSE
~group~ requires 32 bytes but will try to parse base64.
~domain~ requires 16 bytes but will prepend '\0' if too few bytes are given
~path~ and ~prefix~ only take the "\=" op, and take spath bytes. I.e. ~path:=:[//hello/world]~, but will accept ~/hello/world~ as well
#+end_VERSE

Besides the fields in a point, predicates also apply to the hash and variable net header fields.
These fields are useful when writing an exchange processes.

The netheader fields can be mutated.
It is 32 bytes consisting of the following field. 
The netheader fields are :

|              |                               |
| Field_{size} |                               |
|--------------+-------------------------------|
| Prefix_{3}   | magic bytes 'LS0'             |
| NetFlags_{1} | See source code               |
| hop_{2}      | number of hops since creation |
| stamp_{8}    |                               |
| ubits0_{4}   |                               |
| ubits1_{4}   |                               |
| ubits2_{4}   |                               |
| ubits3_{4}   |                               |


*** Predicates & options

The full list of options and predicates:

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim 
 lk print-query --help
#+end_src


* Linkspace
:PROPERTIES:
:CUSTOM_ID: Linkspace
:END:
#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/linkspace/index.html][Rust docs]]
#+END_VERSE


The linkspace is a local log and index that one or more processes connect to.
It is the place you save and retrieve data from.
Either by read or watch.
The latter lets you callback for each currently known and future packet matching a specific set of predicates.
This is done in the [[lk_process]] stage.
You can nest calling ~lk_watch~ and ~lk_read~.

** lk_open
:PROPERTIES:
:CUSTOM_ID: lk_open
:END:

** lk_save
:PROPERTIES:
:CUSTOM_ID: lk_save
:END:

** lk_read
:PROPERTIES:
:CUSTOM_ID: lk_read
:END:

** lk_watch
:PROPERTIES:
:CUSTOM_ID: lk_watch
:END:


** lk_process
:PROPERTIES:
:CUSTOM_ID: lk_process
:END:

** lk_process_while
:PROPERTIES:
:CUSTOM_ID: lk_process_while
:END:


** lk_close_watch
:PROPERTIES:
:CUSTOM_ID: lk_close_watch
:END:


* Conventions
:PROPERTIES:
:CUSTOM_ID: Conventions
:END:
#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/linkspace/conventions.html][Rust docs]]
#+END_VERSE

Conventions are functions built on top of the other linkspace functions.
They provide interop for processes by encoding data into linkspace packets.

One general conventions is that domains and paths starting with \xff are for meta stuff, such as status queries.

** lk_status_set
:PROPERTIES:
:CUSTOM_ID: lk_status_set
:END:
Status queries allow us to communicate if a process exists that is handling a specific type and a specific instance.

The function signature is `DOMAIN GROUP OBJ_TYPE INSTANCE`.

- A request is a packet in the form DOMAIN:[#:0]:/\fstatus/GROUP/type(/instance?) and has no data and no links.
- A reply is of the form DOMAIN:[#:0]/\status/GROUP/type/instance with some data and at least one link.

Note that the packets are in `#:0`.
This function is only for local status updates.

The group argument does not ask inside GROUP, it only signals which group the query is about.
Other processes are meant to answer a request.

The following are statuses that the exchange process should set:

- exchange GROUP process
- exchange GROUP connection PUBKEY
- exchange GROUP pull PULL PULL_HASH

** lk_status_poll
:PROPERTIES:
:CUSTOM_ID: lk_status_poll
:END:

Request the status of a `domain group obj_type ?instance timeout`.


** lk_pull
:PROPERTIES:
:CUSTOM_ID: lk_pull
:END:
A pull request is made by a domain application and signals the set of packets it wants.

#+BEGIN_VERSE
Note that from a domain's perspective, there is no such thing as 'fully synchronized'.
The most straight forwards way to emulate such a thing is to create 'log' packets that link to
known packets from a single device's perspective.
#+END_VERSE

Pull queries must have the predicates 'domain:=:..' and 'group:=:..', and ':watch'

It is up to an exchange process (e.g. [[#anyhost][anyhost]] ) to fulfill the query.
The exchange is only responsible for pull requests received when it is running.
The exchange will drop requests when you reuse the 'watch'.
( use :watch:[now] to ensure it is unique. )
The function returns the hash of the request.

The domain should be conservative with its query.
Requesting too much can add significant overhead.

** lk_key
:PROPERTIES:
:CUSTOM_ID: lk_key
:END:

Read ( or creates ) an encrypted private key from lns:[#:0]:/local/NAME.
Also writes into the local LNS lookup table such that the public key can be requested with ~[@local:NAME]~

* LNS
:PROPERTIES:
:CUSTOM_ID: lns
:END:

See [[../../lns.html][LNS]] for some general information.
See [[#ABELNS][abe#lns]] for how to use LNS for lookup and reverse lookup.

* Q&A
:PROPERTIES:
:CUSTOM_ID: qa
:END:


**** Why Big Endian?
The tree index is in the expected order when using the numbers as path components.
E.g. ~lk linkpoint ::/some/dir/[now]~ will come after ~lk linkpoint ::/some/dir/[now:-1D]~ because ~now > (now - one day)~

**** Why can't I own a group? / I'm not in control of the user! / Anybody in my group can leak data from it!?
I don't make the rules, I just make them obvious.

**** I want to add advertisements to my domain app/Every user of my domain app needs X from my server.
You hardcode a public key into the app, and also publish a group exchange service.
There are two primary ways to centralize information.
Either they connect over the public group, or you can connect over their-key XOR your-key group.

**** A domain can write outside its own domain space.
Yes, the current API has no restriction.
The best thing I think would be to build a wasm runtime interface and restrict access entirely.
That will take some time before we reached that point.

**** Why not use an SQL backend? / Why invent queries?
That is a complex question.
First off, if all you want is SQL queries it is relatively straight forward to stream packets into a SQL table and query them.
But SQL isn't magic, and its non-trivial price to pay for something that is not a great fit for a few fundamental problems including:
1) What is the index peers agree on?
2) How to constrain a query as it travels across a group?
Both can be solved in a number of ways, but most solutions are quickly going to bloat.
I've tried.

Queries have two desirable properties.
You can do a form of algebra on them with concatenation and equality.
They're powerful enough for where they're used.

**** Will it handle spam?
You can require proof of work or a proof of association.
POW is as simple as adding a predicate on the hash.
AI Generated spam only makes this association more important than it is now, and the linkspace protocol can help there.
Will it solve it entirely? Never.
But existing solutions can be adapted and we get more tools to do better.

* Example Domain App - Imageboard
:PROPERTIES:
:CUSTOM_ID: imageboard
:END:

#+BEGIN_VERSE
Available in the repository/examples/app
#+END_VERSE

This is a very simplified example.
It shows what is required to write an instantly accessible multi-user indestructible serverless scalable (... etc)
app for everybody (or just your friends) using linkspace.

Should you build applications in bash? Fuck no.

The goal is to create an image collage with multiple people.
The data structure is as follows:

Adding an image is done by creating a linkpoint where the first path component indicates the name of the image.
The link tag's are decimal encoded [X, Y] coordinates.
It's ptr is a datapoint packet hash.
Building the collage is done by adding all images to a base image in 'create' order.

**** placing images
TODO: Should probably add a 'prev' pointer to indicate what the user currently has.
#+INCLUDE: "../../examples/app/imageboard/imageboard.place.sh" src bash


**** viewing images
#+INCLUDE: "../../examples/app/imageboard/imageboard.view.sh" src bash

**** streaming images
#+INCLUDE: "../../examples/app/imageboard/imageboard.stream.sh" src bash

* Example Group Exchange - Anyhost
:PROPERTIES:
:CUSTOM_ID: anyhost
:END:

#+BEGIN_VERSE
Available in the repo/examples/exchange
See repo/dev/exchange.md for some open design issues/notes.
#+END_VERSE

This is currently unfinished and inefficient.
Anybody can read any group/domain.
Eventually the client will add a bloom filter and counter to the query.

**** anyhost client
#+INCLUDE: "../../examples/exchange/anyhost/bin/connect.sh" src bash
#+INCLUDE: "../../examples/exchange/anyhost/bin/client_io.sh" src bash

**** handshake
#+INCLUDE: "../../examples/exchange/anyhost/bin/handshake.sh" src bash

**** anyhost server
#+INCLUDE: "../../examples/exchange/anyhost/bin/serve.sh" src bash
#+INCLUDE: "../../examples/exchange/anyhost/bin/serve_io.sh" src bash
