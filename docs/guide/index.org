#+TITLE: The Linkspace Protocol Guide
#+AUTHOR: Anton Sol
#+OPTIONS: H:4 num:nil \n:nil ::nil |:t ^:{}  *:t author:nil email:nil creator:nil 
#+OPTIONS: html-style:nil

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./style.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="./tabs.js"></script>

#+LANGUAGE: en



#+BEGIN_VERSE
This is a living document, it is not yet finished, things are broken, and is kept up to date on a best effort basis.
Sometimes the [[../cargo-doc/liblinkspace/index.html][liblinkspace]] docs is ahead of this guide.
#+END_VERSE

* Introduction

The Linkspace Protocol provides a structure to build multi-user applications.
[[../cargo-doc/liblinkspace/index.html][liblinkspace]] implements this protocol.
At its core it is a packet layout which are indexed by their hash and their path.

If those words mean little you should begin at [[../../eli5.html][eli5]].

Projects such as Git, BitTorrent, Matrix, IPFS, and various blockchains already proof that addressing content is a powerful abstraction.
It sidesteps or solves a number of difficulties inherent in organizing data as a stream in multi-user applications.
When the content in such a system includes objects that link other content by its hash the system can be classified as a supernet.

The issue with supernets so far, is that they are bound to their use-case.
The Linkspace Protocol is a general purpose solution.
It is built to be fast and simple.
#+BEGIN_VERSE
Supernet  [ˈsü-pərˌnet]

A self-referential multi-user data organization protocol whose primary
addressing method uses hashes instead of endpoint identifiers.
A communication protocol where the method of exchange is an extraneous concern.
e.g. git, bitcoin, nostr, the linkspace protocol
#+END_VERSE

The supernet paradigm is a trade-off.
Instead of processing ordered streams of network data, an application is a function over the partial view of potentially noisy interlinked state.

#+HTML: <a id="state-complexity"></a>
The readme contains technical properties this provides.
However, there is one I lack a word for.
Both the process of view-database state synchronization, and dealing with networks have this in common:
They're well designed if they run under the assumption of incomplete/bad state.
The linkspace protocol makes this an obvious requirement, and liblinkspace attempts to make it simple[fn:: that's not to imply orchestration becomes simple, or the abstraction does not leak. I fear those are the facts of life.]

The Linkspace Protocol is best understood as 4 ideas.

- [[Point]] - Three types of packets
- [[ABE]] - (Byte) templating
- [[Query]] - Query for selecting packets
- [[Linkspace]] - Packet index and callbacks

A big addition compared to similar systems is the split between domains and groups.
It separates the responsibility of 'User Interface & Data Structure' with the 'Members and the exchange of data'.
This split and other standard problems, are supported by a set of (growing) [[Conventions]].

You can checkout the [[#imageboard][imageboard]] example to see it in action.
But bare with me as some stuff is still in development.

* Setup

This guide uses Python and (Bash) CLI snippets.
You can get the latest version from [[https://github.com/AntonSol919/linkspace][GitHub]]

** linkspace-cli

~make install-lk~ or:

#+BEGIN_SRC bash
cd cli/linkspace
cargo install --path .
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim
lk --version
#+END_SRC

#+RESULTS:
#+begin_example
linkspace-cli 0.1.0
#+end_example


** lkpy - linkspace python bindings

~make install-lkpy~ or: 

#+BEGIN_SRC bash
cd ffi/liblinkspace-py
make
source ./.env/bin/activate
python -i
>>> import * from lkpy
#+END_SRC

#+RESULTS:

* API overview
:PROPERTIES:
:CUSTOM_ID: api
:END:

The liblinkspace API is a small set of functions that is mostly stable.
It is available as a Rust crate ~liblinkspace~ and binding for other languages follow this API.

It consists of the following functions:

- [[Point]] creation
  - [[file:::#datapoint-py][lk_datapoint]]
  - [[#lk_linkpoint][lk_linkpoint]]
  - [[lk_keypoint]]

- [[ABE]] - ascii byte expressions - a language for manipulating and templating bytes
  - [[lk_eval]]
  - [[lk_encode]]

- [[Query]] - Addressing and filtering of packets with predicates and options
  - [[lk_query]]
  - [[lk_query_parse]]
  - [[lk_query_push]]
  - [[lk_query_print]]

- [[Linkspace]] - Locally indexed packets and new packet processing functions
  - [[lk_open]]
  - [[lk_save]]
  - [[lk_read]]
  - [[lk_watch]]
  - [[lk_process]]
  - [[lk_process_while]]

- [[Conventions]] - functions
  - [[lk_status_set]]
  - [[lk_status_poll]]
  - [[lk_pull]]
  - [[lk_key]]


* Point
:PROPERTIES:
:CUSTOM_ID: Point
:END:

#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/point/index.html][Rust docs]]
#+END_VERSE

Points are the basic units in linkspace.
They carry data, link to other points, and might contain information about the who, what, when, and how.
There are 3 kinds of points. datapoints, linkpoints, and keypoints.
A point has a maximum size of 2^{16}-512 bytes.

Building a point is always combined with generating a hash and prepending a netheader.
Together the [netheader, hash, point] form a netpacket.
All functions deal in netpacket.

Writing an application is the art of defining a relationship between the points.



** lk_datapoint
:PROPERTIES:
:CUSTOM_ID: datapoint
:END:

#+begin_ctabs
#+begin_sh

#+BEGIN_SRC bash :session cli2 :exports both :results output verbatim
echo -n "Hello, Sol" | lk data | lk printf "[hash:str]\n[data]"
#+END_SRC

#+RESULTS:
#+begin_example
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
#+end_example

#+end_sh

#+begin_py

#+begin_src python :session lkpy :exports both :results value verbatim
from lkpy import *
datap = lk_datapoint(b"Hello, Sol")
lk_eval2str("[hash:str]\\n[data]", datap)
#+END_SRC

#+RESULTS:
#+begin_example
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
#+end_example

#+end_py

#+end_ctabs

** lk_linkpoint
:PROPERTIES:
:CUSTOM_ID: lk_linkpoint
:END:


A linkpoint creates relations between packets by their hash and its location.

It consists of these fields:

| Field_{size}      |                                                    |
|-------------------+----------------------------------------------------|
| Group_{32}        | the intended recipients.                           |
| Domain_{16}       | the intended application.                          |
| Path_{var<240}    | Sequence of bytes. e.g. '/dir1/dir2/thing'         |
| Stamp_{8}         | Big endian UNIX timestamp in microseconds.         |
| Links_{48*n}      | A variable length list of (Tag_{16}, Pointer_{32}) |
| -Link[0]_{48}     |                                                    |
| -Link[1]_{48}     |                                                    |
| -Link[2]_{48}     |                                                    |
| -Link[...]_{48}   |                                                    |
| Data_{var<2^{16}} |                                                    |

A packets' location refers to its (Domain, Group, Path) triple.
All values, including the Path, contain arbitrary bytes.

The max space is shared between the links and data so beware that too much data and link wont fit into a single packet. 

#+BEGIN_VERSE
Packet hashes, GroupID's, and public keys are 32 bytes.
They are usually encoded in URL-safe no-padding base64, e.g. ~RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF~.
These hashes quickly make things unreadable.
The ~[...]~ syntax ([[ABE]]) allows us to name and manipulate bytes.
This following example shows that ~[#:pub]~ resolves to the bytes ~RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF~ in both the Group and the second link
Furthermore, If no group was provided it defaults to ~[#:pub]~
#+END_VERSE

Datapoints do not have a 'create' field, so they get the same hash given the same data.
If we had forced a specific 'create' stamp for both the python and bash example it would have produced the same hash for both.
Instead, 'create' defaults to the current time ( microseconds since epoch ), and thus the hash is different.

#+begin_ctabs
#+begin_sh

The command ~lk link~ can build linkpoint packets and output's them to stdout by default.
Whenever a cli commands deal with (domain, group, path) tuples, they can be set as the first argument: ~DOMAIN:GROUP:PATH~.
Two links are added with the tags ~first_tag_1~ and ~another_tag~


#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim
  lk link "a_domain:[#:pub]:/dir1/dir2/thing" \
            -l first_tag_1:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0 \
            -l another_tag:[#:pub] \
  | lk printf
  
#+END_SRC

#+RESULTS:
#+begin_example
type	LinkPoint
hash	RFozuOGykWwsEqkENDUqVChme5mgjP1yMplvvyWWge4
group	[#:pub]
domain	\0\0\0\0\0\0\0\0a_domain
path	/dir1/dir2/thing
pubkey	[@:none]
create	1677572856319727
links	2
	\0\0\0\0\0first_tag_1 RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	\0\0\0\0\0another_tag RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0

data	0
#+end_example

#+END_sh


#+begin_py

The library requires bytes. 
We can ~"some string".encode()"~, use the ~b"byte notation"~, a packet field, or evaluate an ABE string with [[lk_eval]].

#+begin_src python :session lkpy :exports both :results value verbatim 
  ptr1 = lk_eval("[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]")
  ptr2 = lk_eval("[#:pub]")
  datap = lk_datapoint(b"Hello example");
  assert(ptr1 == ptr2)
  link1 = Link(tag=b"first tag 1",ptr=ptr1)
  link2 = Link(b"another tag",ptr2)
  link3 = Link(b"a datapacket",datap.hash)
  linkp = lk_linkpoint(
      domain=b"example domain",
      group=lk_eval("[#:pub]"),
      data=b"Hello, World!",
      links=[link1,link2,link3]
  )
  str(linkp)
#+END_SRC

#+RESULTS:
#+begin_example
{pkt}
#+end_example

#+END_py

#+END_ctabs



** lk_keypoint 
:PROPERTIES:
:CUSTOM_ID: lk_keypoint
:END:

A key point is a linkpoint with an additional publickey and signature.

There are functions to generate, encrypt, and decrypt a linkspace key.
Leaving you to deal with the saving.
Alternatively there is the [[lk_key]] function that does it all for you.
With the added benefit that you can address your own public key as ~[@:me:local]~ an ABE expr

#+begin_ctabs
#+begin_sh
#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim
  export LINKSPACE=/tmp/linkspace
  lk --init key --insecure --password "my secret" # remove the --insecure. it speeds up building this doc
#+END_SRC

#+RESULTS:
#+begin_example
$argon2d$v=19$m=8,t=1,p=1$7GXypB0u3AxuVdtmqZmDg4WNYeMPU/sqrCBf+Erw0OU$1+Nbkp9cEHmYbChCneUZblzzrfhpyes2RkDQBojKl30=
7GXypB0u3AxuVdtmqZmDg4WNYeMPU_sqrCBf-Erw0OU
#+end_example

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk keypoint "example::" --password "my secret" | lk printf
#+END_SRC

#+RESULTS[9deef8d2b6607fd6b9d806e306cea7e877c146fc]:
#+begin_example
type	KeyPoint
hash	EatNxpCcokPrKrB42gKn15OZzIxKoYl_lwGOnwlZn1s
group	[#:pub]
domain	\0\0\0\0\0\0\0\0\0example
path	
pubkey	[@local:me]
create	1677572856815708
links	0

data	0
#+end_example

#+BEGIN_VERSE
The CLI also accepts ~lk link --sign~ instead of ~lk keypoint~
#+END_VERSE


#+END_sh
#+begin_py
#+begin_src python :session lkpy :exports both :results value verbatim
  lk = lk_open("/tmp/linkspace",create=True)
  key = lk_key(lk,b"my secret");
  example_keypoint = lk_keypoint(key=key,domain=b"example")
  str(example_keypoint)
#+END_SRC

#+RESULTS:
#+begin_example
{pkt}
#+end_example

#+END_py
#+END_ctabs


** Notes

Groups signals the intended set of recipients.
Domains signal the activity, and practically the application used to present an interface to the user.

The groups bytes are simply chosen and membership is enforced by its members.
They exists because we say they exists.
Its up to the user (or some automatic management tool) to pick a method of data exchange.
They can have a special meaning, such as public key or a pointer to a list of publickeys that act as administrators.

The following do have a meaning.
The [0;32] null group ( ~[#:0]~ ), i.e. the local only group, is never transmitted to other devices and is never accepted from outside sources.
Everything in the ~[#:pub]~ group[fn:: the hash of ~lk_datapoint(b"Hello, Sol")~] is meant for everybody. e.g. the public.

By convention the group created by pubkey1 XOR pubkey2 forms a group with those keys as its only two members.

#+BEGIN_VERSE
The ~[#:...]~ is part of the [[LNS]].
A public registry for assigning names and naming rights.
e.g. ~[#:sales:mycomp:com]~ for groups and ~[@:alicekey:mycomp:com]~ for keys.
#+END_VERSE

* ABE
:PROPERTIES:
:CUSTOM_ID: ABE
:END:

#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/abe/index.html][Rust docs]]
#+END_VERSE



ABE (Ascii-Byte-Expr) is a tiny byte templating language.
Its primary purpose is to make it easy for developers to read and write arbitrary (0..=255) bytes in plain ascii,
but it can add context's ( such as a linkspace instance) and evaluate expressions ( such as a 'name' for a public key ).

Linkspace has no concept of encoding.
Fields have a fixed length or prefix their exact length.
The ~null~ (0) byte is not special.

Things like [[Query]] or simply printing a text representation of a packet use ABE.

ABE is not a proramming language!
Its a way for _developers_ to read and write arbitrary bytes in some context and quickly beat them into shape.
Its not meant to be powerful or elegant beyond that.
The limitations and constraints are by design.

Its up to the application how to display the bytes to the end user.
For instance, they could demand the bytes are valid UTF8 containing one emoji and ignore packets otherwise.

** Parsing

- Most printable ascii letters are as is.
- The external delimiters ~'\n'~ (newline) and ~'\t'~ (tab) are invalid characters.
- the internal delimiters ~:~ , ~/~.
- ~[~ and ~]~ wrap an expression
- ~:~, ~/~, ~\~, ~[~, ~]~  can be escaped with a ~\~.
- ~\x00~ up-to ~\xFF~ for bytes.
- ~\0~ equals  ~\x00~,  ~\f~ equals ~\xFF~

** lk_eval

ABE is evaluated by substituting an expressions ( ~[..]~ ) with its result.
For example in ~[u8:97]~, the function 'u8' parses "97" and prints it.
The byte 99 equals the character 'c'.


#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk eval "ab[u8:99]" | xxd
#+END_SRC

#+RESULTS[7273b79da3eb3a7a7c65c56794847096c71a4b08]:
#+begin_example
00000000: 6162 63                                  abc
#+end_example

The result of an ABE is a list of (bytes, ?delimiter). 

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk eval --json "h[u8:101]ll[u8:111] / world:etc" 
#+END_SRC

#+RESULTS[6fa8e739e281512d9289b534440f07aef1d8f108]:
#+begin_example
[[[104,101,108,108,111,32],"/"],[[32,119,111,114,108,100],":"],[[101,116,99],null]]
#+end_example

Note that bytes are joined after evaluating. In the example this results in the component ~('hello ', /)~.
The delimiters ('\n' '\t' ':' '/') are interpreted depends on the context.
In the top level of the template given to ~eval~ they are printed as is.

In other words: ~eval "hello/:[u8:99]\n"~ == ~hello/:c\n~ ,
but within brackets they have a special meaning:  ~eval "hello/:[hello/ \n :]"~ will error.

#+Begin_VERSE
The rest of this chapter goes further in depth.
Understanding the ABE language in depth is not critical.
With basic knowledge of expression substitution (~[..]~) and the ~':'~, ~'/'~ delimiters the reader can choose to
skip to the next chapter [[Query]] and return here for reference later.
#+end_VERSE


*** Sub-expressions

A list of functions/evaluators be found by evaluating
[[Help][[[help]]][\[help\]]].

**** Functions

- ~[fn]~
- ~[fn:arg0]~
- ~[fn:arg0:arg1]~

The arguments are bytes. They take upto 8 arguments.
The resulting bytes are concatenated with their surrounding.
The empty function ~'[:...]'~ resolves to its first argument.

- ~hello [:world]~ == ~hello world~

Arguments are evaluated before application.
~[fn0:[fn1]]~ will call fn1 and use its result as the first argument to fn0.

You can carry results with ~/~.
It uses the result as the first argument to the next function.

- ~[:97/u8]~ == ~[u8:97]~ == ~a~
- ~[:97/u8/?u]~ == ~[?u:[u8:97]]~ == ~97~
  
You can think of ABE functions as a translation of conventional function calling.

| ~[name:arg1:arg2]~              | ~name(arg1,arg2)~                  |
| ~[name:[other_name:argA]:arg2]~ | ~name( other_name(argA) , arg2 )~  |
| ~[other_name:argA/name:arg2]~   | ~name ( other_name(argA) , arg2 )~ |


#+BEGIN_VERSE
Functions are aware if they are first or not.
The vast majority of functions do not care.
#+END_VERSE

#+BEGIN_VERSE
~[[:u8]:97]~ is explicitly not allowed. Variable function identifiers are conceptually interesting but practically begging for bugs.
#+END_VERSE

**** Evaluators
The second type of operation is calling an evaluator.
Whereas functions are called after their arguments are evaluated.
Evaluators are called without evaluation ~[..]~ expressions.

- ~[/re]~
- ~[/re:arg0:arg1]~
- ~[/re:[fn:arg0]:arg1]~

The ~/re~ evaluator operates on ~:[fn:arg0]:arg1~ without it being evaluatedd.[fn:: similar to some definition of 'macros']

The most common use-case for evaluators is extending the scope.

*** Scope & context

Functions and evaluators are defined in a scope.
The standard scope contains functions to manipulate bytes.
Some scopes require a context.

You can see all active scopes with the help function.

**** Argv

A straightforward scope is the argument vector.

#+BEGIN_ctabs
#+begin_py

#+begin_src python :session lkpy :exports both :results value verbatim
data = "Rm9ycmVzdA"
# Try and decode arg[1] as base 64
lk_eval("[0] [1/b], [0]!",argv=["Run",data])
#+end_src

#+RESULTS:
#+begin_example
b'Run Forrest, Run!'
#+end_example

#+end_py
#+end_ctabs



**** Packet scope

By providing a packet, the packet scope is added.
This adds operations to evaluate packet fields such as ~hash~, ~group~, ~path~ etc.
These are bytes that you can use as arguments.

e.g ~[hash/?b]~ encodes the hash in base 64.

For convenience all packet fields accept 'str' and 'abe' as a first argument to print them in a default format.
| ~[hash:str]~      | ~[hash/?b]~      |
| ~[group:str]~     | ~[group/?b]~     |
| ~[create:str]~    | ~[create/?u]~    |
| ~[links_len:str]~ | ~[links_len/?u]~ |
| ...               |                  |

The ~[/links:...]~ evaluator iterates over every link in a packet.
It evaluates the inner scope for each link with setting the ~tag~ and ~ptr~ function.

#+BEGIN_ctabs
#+begin_sh
~printf~ is ~eval~ that reads packets from stdin and puts them in scope.

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
  lk link "::" -l tag1:[#:0] -l tag2:[#:pub] | \
      lk printf "HASH:[hash/?b]\n[/links:TAG = [tag:str] PTR = [ptr:str] \n]"
#+END_SRC

#+RESULTS[228919a64a8b7e88e169877faae1a3a8040748de]:
#+begin_example
HASH:XR5TUcO277Ojz4JUkuho3UzzpzoHmwAnP26aB2GD53k
TAG = \0\0\0\0\0\0\0\0\0\0\0\0tag1 PTR = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
TAG = \0\0\0\0\0\0\0\0\0\0\0\0tag2 PTR = RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
#+end_example

#+end_sh

#+begin_py
#+begin_src python :session lkpy :exports both :results value verbatim
  lp = lk_linkpoint(links=[Link("hello",PUBLIC),Link("world",PRIVATE)])
  lk_eval2str("hash:[hash:str]\n[/links:[tag:str] [ptr:str]\n]",pkt=lp)
#+END_SRC

#+RESULTS:

#+end_py
#+end_ctabs

**** Linkspace

Having a linkspace instance in the scope gives you access to functions like:

- ~#~ and ~@~ ( see [[LNS]] ) for named groups, keys, and other data
- ~readhash~

When using [[lk_open]] , the instance is automatically setup as scope.

~readhash~ is considered bad practice, fine to hack something together, but it doesn't give you much room to process errors or async.
But you can do some wizardry combining it with ~[/links]~.

*** Usage notes

ABE expressions evaluate into a list of [ (bytes,?sep) ].
Sometimes each element has a different meaning, e.g. [ ( domain , : ) , (group , _) ] in the CLI arguments.
You can process this list with ~lk_split_abe~. 

But in the majority of cases we don't care about the list and just want a single result.
~lk_eval~ does just that. It interprets the separators as plain characters.

Finally, consider what you would expect to happen when an evaluator takes a ABE expression as its final argument:

- ~[/links:abc[:hello]/world]~
- ~[/readhash:[#:pub]:the pkt:[pkt]]~
- ~[/:hello/world]~
- ~lk link :: --write 'file:./afolder:with/colons'~

The choice was made that if the final argument is a abe expression that will be evaluated, it doesn't need wrapping ~[]~.
Instead it interprets the entire tail as is.
This reduces the need to escape ':' and '/', but complicating some other expressions.

#+BEGIN_VERSE
We can add an expression to --write arguments
~lk link :: --write "stdout-expr:hello world:/ [hash:str]"~
In case of ~file~ this leaves us in the situation that second argument is the file and the tail of the expression will be evaluated
The simplest way to ignore all escapes is to use empty evaluator ~[/:..]~. 
~lk link :: --write "file-expr:[/:./afolder:with/colons]:hello world:/ [hash:str]"~
#+END_VERSE


*** Help
:PROPERTIES:
:CUSTOM_ID: abe-help
:END:

A full list of active scopes can be viewed with the ~help~ function.
#+BEGIN_ctabs
#+begin_misc
#+BEGIN_VERSE
The following naming conventions are used:

- ending with '?' is a predicate to check a property.
- starting with '?' is a basic reverse operation , e.g. ~'?a'~, the less powerful [[lk_encode]] ( This is different but related to [lk_encode], the more powerful reverse op)
- b_RADIX_ ( b2, b8, b16 ) 'b' defaults to base64 radix
- u_SIZE_  ( u8, .., u128 ) parse decimal into big endian bytes. ?u interpret as big endian print to decimal
#+END_VERSE
#+end_misc

#+begin_py
#+name:abe-help-py
#+custom_id:abe-help-pyid
#+begin_src python :session lkpy :exports both :results value verbatim
lk_eval2str("[help]",pkt=lk_linkpoint(),argv=["hello"]) # the help won't show up if no scope is set. 
#+END_SRC
#+end_py
#+end_ctabs

** lk_encode
:PROPERTIES:
:CUSTOM_ID: lk_encode
:END:

Translate bytes into abe such that ~lk_eval(lk_encode(X)) == X~

#+begin_verse
We can get meta. lk_encode is available as the evaluator ~[/?:bytes:options]~
#+end_verse

#+begin_ctabs
#+begin_py

#+begin_src python :session lkpy :exports both :results output verbatim
  data = bytes([0,0,0,255])
  abe = lk_encode(data)
  assert data == lk_eval(abe)
  print("ab  text:", abe)
  abe = lk_encode(data,"u8/u32/b") # Try to encode as expression
  print("abe text:", abe)
#+END_SRC

#+RESULTS:
#+begin_example
ab  text: \0\0\0\f
abe text: [u32:255]
#+end_example


#+end_py
#+end_ctabs

** lk_split_abe
:PROPERTIES:
:CUSTOM_ID: lk_split_abe
:END:



** LNS
:PROPERTIES:
:CUSTOM_ID: ABELNS
:END:

LNS (Lovely name system) is a system for publicly naming keys and groups, and adding auxiliary data to them.
It allows you to register as ~@:Alice:nl~, ~#:sales:company:com~, etc.

LNS is easy to use from an abe expression.
Both to lookup and do a reverse lookup.

See the [[../../lns.html][lns]] for info.

#+BEGIN_VERSE
You can name keys in your local index, allowing you to reference ~[@:my_identity:local]~ or ~[#:friends:local]~
By default [[lk_key]] sets up the ~[@:me:local]~ identity.
The convention to do so is currently not (crates/common/protocol/lns/local.rs::build_local_lns_points)
#+END_VERSE

#+begin_ctabs
#+begin_sh
#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
  lk eval "[#:pub]" | lk encode "@/#/b"
#+END_SRC

#+RESULTS[97387c1a1e65870757106810b87d3391af7b1d53]:

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
  lk eval "[@:me:local]" | lk encode "@/#/b"
#+END_SRC

#+RESULTS[6bf16396d6677cbaa47664441185e8f02b490ee6]:
#+begin_example
[@local:me]
#+end_example

#+end_sh

#+begin_py
#+begin_src python :session lkpy :exports both :results output verbatim
  group = example_keypoint.group
  print("The bare bytes:", group)
  
  # encode as b64
  b64 = lk_encode(group,"b")
  print("b64 encoded   :", b64)

  # Try to express as a [#:..], on failure try as [@:..], fallback to [b:...]
  try_name = lk_encode(group,"#/@/b")
  print("Or through lns:", try_name)

  print("Pkt's pubkey  :",example_keypoint.pubkey)
  try_keyname = lk_encode(example_keypoint.pubkey,"#/@/b")
  print("Similarly lns :", try_keyname)


#+END_SRC

#+RESULTS:
#+begin_example
The bare bytes: b'D=\xe5\xb4\xe8^\x1b\x80\xab\x06\xea\xd42{g\x85\x9f\x0f\xb5\x9e\xb2\x01\x81\x7f\x0b[\xab(ft\x04\x1d'
b64 encoded   : [b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]
Or through lns: [#:pub]
Pkt's pubkey  : b'\xece\xf2\xa4\x1d.\xdc\x0cnU\xdbf\xa9\x99\x83\x83\x85\x8da\xe3\x0fS\xfb*\xac _\xf8J\xf0\xd0\xe5'
Similarly lns : [b:7GXypB0u3AxuVdtmqZmDg4WNYeMPU_sqrCBf-Erw0OU]
#+end_example

#+end_py
#+end_ctabs


* Query
:PROPERTIES:
:CUSTOM_ID: Query
:END:


#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/query/index.html][Rust docs]]
#+END_VERSE

A query is a list of predicates and options used to select a set of packets.
They are used by the local index ( [[lk_watch]] and [[lk_read]] ),
or to signal what packets should be found looked for in the group ( [[lk_pull]] ),
or as a filter function.

** lk_query
:PROPERTIES:
:CUSTOM_ID: lk_query
:END:


Queries are newline separated.
Predicates are an [[ABE]] 3-tuple ~field ':' test-operation ':' value~ and constrain the set of accepted packets.
Options are context dependent and start with ':'

#+Caption: select everything signed by me in ~example:[#:pub]:/hello/world/**~ with a max data size of 255, with between 2 and 8 links from the tree index and follow it's the links
#+BEGIN_EXAMPLE
group:=:[#:pub]
domain:=:example
data_size:<=:[u16:256]
prefix:=:/hello/world
pubkey:=:[@local:me]
link_len:>=:[u16:2]
link_len:<=:[u16:8]

:mode:tree-asc
:follow
:watch:gethellos
#+END_EXAMPLE

A predicate can be set multiple times.
They are designed such that you can concatenate two queries.
If the result can only ever be the empty set an error is returned.

There are only 4 basic test operations.

| Basic Op |                                   |
|----------+-----------------------------------|
| >        | greater eq                        |
| <        | less eq                           |
| 0        | all '0' in value are '0' in field |
| 1        | all '1' in value are '1' in field |

The following are shorthand and resolve to one or more of the basic tests.

| Derived Ops |                          |
|-------------+--------------------------|
| =           | >(val-1) and <(val+1)    |
| >=          | >(val-1)                 |
| <=          | <(val+1)                 |
| *=          | Last n-bytes must eq val |
| =*          | First n-bytes must eq val |


The CLI has various aliases that can act as a guide in creating queries by using ~print-query~.

#+begin_ctabs
#+begin_sh

#+BEGIN_VERSE 
Many cli commands (e.g. ~print-statemnt~, ~watch~ ) take as the first argument a ~domain:group:path:(?depth)~
If no depth is set the path_len is constraint by default.
Except for ~watch-tree~ which sets the depth to unconstrained by default
#+END_VERSE 

#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim :cache yes
lk print-query "my:[#:pub]:/hello:*" --signed
#+END_SRC
#+end_sh
#+begin_py

#+begin_src python :session lkpy :exports both :results value verbatim
  q = lk_query()
#+END_SRC

#+end_py
#+end_ctabs

** lk_query_parse
:PROPERTIES:
:CUSTOM_ID: lk_query_parse
:END:

Add multiple constraints to a query. Returns an error if the resulting set is empty.
The full list of predicates and their byte size can be found [[#predicatelist][here]].

#+begin_src python :session lkpy :exports both :results value verbatim
        # parse runs eval and can take pkt and argv as argument.
        lk_query_parse(q,
                       """group:=:[#:pub]\ndomain:=:example,
                       path_len:<:[u8:4]\ndata_size:<:[0]
                       """, argv=[10.to_bytes(4)])
        lk_query_print(q,True) 
#+END_SRC

** lk_query_push
:PROPERTIES:
:CUSTOM_ID: lk_query_push
:END:

Add a single statement to a query, with the last field in byte format.

The second predicate is less strict than previous, and will be ignored.

#+begin_ctabs
#+begin_py
#+begin_src python :session lkpy
  lk_query_push(q,"data_size","<",bytes([0,4]))
  lk_query_push(q,"data_size","<",lk_eval("[u16:20]")) 
  lk_query_push(q,"data_size","<",int(2).to_bytes(4)) 
#+END_SRC

#+CAPTION: Adding contradictions/defining an empty set, returns an error.
#+begin_src python :session lkpy
  try:
    lk_query_push(q,"data_size",">",bytes([0,100]))
  except:
    print("thats not possible")
#+END_SRC

#+end_py
#+end_ctabs


** lk_query_print
:PROPERTIES:
:CUSTOM_ID: lk_query_print
:END:

Print a query as text.
The query will have merged overlapping predicates
The last argument sets whether to create abe expressions or stick to ab-text with out the expressions

#+begin_src python :session lkpy :exports both :results value verbatim
  lk_query_print(q,True)
#+END_SRC

#+BEGIN_VERSE
The ~b2~ function read a binary representation.
The types are: datapoint=[b2:0000_0001], linkpoint [b2:0000_0011], keypoint [b2:0000_0111].
Setting 'group', 'domain', 'path', 'links', or 'create' predicates automatically exclude the datapoint type.
Setting pubkey or signature excludes link and data points.
#+END_VERSE



** More on predicates

#+Begin_VERSE
~group~ requires 32 bytes but will try to parse base64.
~domain~ requires 16 bytes but will prepend '\0' if too few bytes are given
~path~ and ~prefix~ only take the "\=" op, and take spath bytes. I.e. ~path:=:[//hello/world]~, but will accept ~/hello/world~ as well
#+end_VERSE

Besides the fields in a point, predicates also apply to the hash and variable net header fields.
These fields are useful when writing an exchange processes.

The netheader fields can be mutated.
It is 32 bytes consisting of the following field. 
The netheader fields are :

|              |                               |
| Field_{size} |                               |
|--------------+-------------------------------|
| Prefix_{3}   | magic bytes 'LK1'             |
| NetFlags_{1} | See source code               |
| hop_{2}      | number of hops since creation |
| stamp_{8}    |                               |
| ubits0_{4}   |                               |
| ubits1_{4}   |                               |
| ubits2_{4}   |                               |
| ubits3_{4}   |                               |


*** Predicates & options
:PROPERTIES:
:CUSTOM_ID: predicatelist
:END:

The full list of options and predicates:

#+begin_ctabs
#+begin_rs

Current set of [[../cargo-doc/liblinkspace/query/enum.PredicateType.html][predicates]] and 
[[../cargo-doc/liblinkspace/query/enum.KnownOptions.html][options]].

Predicates must be known, unknown options are added but ignored.
An exchange process will for instance add a ':boomfilter' only it understands.
#+end_rs

#+begin_sh
#+BEGIN_SRC bash :session cli0 :exports both :results output verbatim 
 lk print-query --help
#+end_src

#+RESULTS:
#+begin_example
hash         - the point hash e.g. [b:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA]
group        - group id e.g. [#:pub]
domain       - domain - if fewer then 16 bytes, prepadded with   e.g. [a:example]
prefix       - path prefix - only accepts '=' op e.g. /hello/world
path         - exact path - only accepts '=' op e.g. /hello/world
pubkey       - public key used to sign point e.g. [@local:me]
create       - the create stamp e.g. [now:-1H]
path_len     - the total number of path components - max 8 e.g. [u8:0]
links_len    - the number of links in a packet e.g. [u16:0]
data_size    - the byte size of the data field e.g. [u16:0]
recv         - the recv time of a packet e.g. [now:+1D]
i_branch     - total packets per uniq (group,domain,path,key) - only applicable during local tree index, ignored otherwise e.g. [u32:0]
i_index      - total packets read from local index e.g. [u32:0]
i_new        - total newly received packets e.g. [u32:0]
i            - total matched packets e.g. [u32:0]
hop          - (mutable) number of hops e.g. [u16:5]
stamp        - (mutable) variable stamp e.g. [now]
ubits0       - (mutable) user defined bits e.g. [u32:0]
ubits1       - (mutable) user defined bits e.g. [u32:0]
ubits2       - (mutable) user defined bits e.g. [u32:0]
ubits3       - (mutable) user defined bits e.g. [u32:0]
type         - the field type bits - implied by other predicates e.g. [b2:00000001]
netflags     - (mutable) netflags e.g. [b2:00000000]
point_size   - exact point size - (netpkt_size - 32b header - 32b hash) e.g. [u16:4]

The following options are available

	:mode
	:watch
	:follow
	:notify-close


query - print full query from common aliases

Usage: lk print-query [OPTIONS] [DGPD] [-- <EXPRS>...]

Arguments:
  [DGPD]      
  [EXPRS]...  

Options:
  -p, --print-expr               print the query
      --print-text               print in ascii-byte-text format (ABE without '{..}' expressions)
      --id <ID>                  [default: default]
      --private                  enable io of linkpoints in [#:0] [env: PRIVATE_GROUP=]
      --mode <MODE>              [default: tree-desc]
  -b, --bare                     
      --index                    only match locally indexed pkts           | i_new:=:{u32:0}
      --new                      only match new unindexed pkts             | i_index:=:{u32:0}
      --max <MAX>                match upto max packets.                   | i:<:{u32:max}
      --max-branch <MAX_BRANCH>  match upto max per (dm,grp,path,key) pkts | i:<:{u32:max_branch}
      --max-index <MAX_INDEX>    match upto max from local index           | i_index:<:{u32:max_index}
      --max-new <MAX_NEW>        match upto max unindexed pkts             | i_new:<:{u32:max_new}
      --signed                   match only signed pkts                    | pubkey:>:{@:none}
      --unsigned                 match only unsigned pkts                  | pubkey:=:{@:none}
      --watch                    Add :watch option
      --watch-id <WATCH_ID>      set :watch option id (implies --watch)
      --follow                   Add :follow option
      --ttl <TTL>                add recv:<:{now:+..}
  -h, --help                     Print help
#+end_example

#+end_sh
#+end_ctabs


* Linkspace
:PROPERTIES:
:CUSTOM_ID: Linkspace
:END:
#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/linkspace/index.html][Rust docs]]
#+END_VERSE


The linkspace is a local log and index that one or more processes connect to.
It is the place you save and retrieve data from.
Either by read or watch.
The latter lets you callback for each currently known and future packet matching a specific set of predicates.
This is done in the [[lk_process]] stage.
You can nest calling ~lk_watch~ and ~lk_read~.

** lk_open
:PROPERTIES:
:CUSTOM_ID: lk_open
:END:

** lk_save
:PROPERTIES:
:CUSTOM_ID: lk_save
:END:

** lk_read
:PROPERTIES:
:CUSTOM_ID: lk_read
:END:

** lk_watch
:PROPERTIES:
:CUSTOM_ID: lk_watch
:END:


** lk_process
:PROPERTIES:
:CUSTOM_ID: lk_process
:END:

** lk_process_while
:PROPERTIES:
:CUSTOM_ID: lk_process_while
:END:


** lk_close_watch
:PROPERTIES:
:CUSTOM_ID: lk_close_watch
:END:


* Conventions
:PROPERTIES:
:CUSTOM_ID: Conventions
:END:
#+BEGIN_VERSE
[[../cargo-doc/liblinkspace/conventions/index.html][Rust docs]]
#+END_VERSE

Conventions are functions built on top of the other linkspace functions.
They provide interop for processes by encoding data into linkspace packets.

One general conventions is that domains and paths starting with \xff are for meta stuff, such as status queries.

** lk_status_set
:PROPERTIES:
:CUSTOM_ID: lk_status_set
:END:
Status queries allow us to communicate if a process exists that is handling a specific type and a specific instance.

The function signature is `DOMAIN GROUP OBJ_TYPE INSTANCE`.

- A request is a packet in the form DOMAIN:[#:0]:/\fstatus/GROUP/type(/instance?) and has no data and no links.
- A reply is of the form DOMAIN:[#:0]/\status/GROUP/type/instance with some data and at least one link.

Note that the packets are in `#:0`.
This function is only for local status updates.

The group argument does not ask inside GROUP, it only signals which group the query is about.
Other processes are meant to answer a request.

The following are statuses that the exchange process should set:

- exchange GROUP process
- exchange GROUP connection PUBKEY
- exchange GROUP pull PULL PULL_HASH

** lk_status_poll
:PROPERTIES:
:CUSTOM_ID: lk_status_poll
:END:

Request the status of a `domain group obj_type ?instance timeout`.


** lk_pull
:PROPERTIES:
:CUSTOM_ID: lk_pull
:END:
A pull request is made by a domain application and signals the set of packets it wants.

#+BEGIN_VERSE
Note that from a domain's perspective, there is no such thing as 'fully synchronized'.
The most straight forwards way to emulate such a thing is to create 'log' packets that link to
known packets from a single device's perspective.
#+END_VERSE

Pull queries must have the predicates 'domain:=:..' and 'group:=:..', and ':watch'

It is up to an exchange process (e.g. [[#anyhost][anyhost]] ) to fulfill the query.
The exchange is only responsible for pull requests received when it is running.
The exchange will drop requests when you reuse the 'watch'.
( use :watch:[now] to ensure it is unique. )
The function returns the hash of the request.

The domain should be conservative with its query.
Requesting too much can add significant overhead.

** lk_key
:PROPERTIES:
:CUSTOM_ID: lk_key
:END:

Read ( or creates ) an encrypted private key from lns:[#:0]:/local/NAME.
Also writes into the local LNS lookup table such that the public key can be requested with ~[@local:NAME]~

* LNS
:PROPERTIES:
:CUSTOM_ID: lns
:END:

See [[../../lns.html][LNS]] for some general information.
See [[#ABELNS][abe#lns]] for how to use LNS for lookup and reverse lookup.

* Q&A
:PROPERTIES:
:CUSTOM_ID: qa
:END:


**** Why Big Endian?
The tree index is in the expected order when using the numbers as path components.
E.g. ~lk linkpoint ::/some/dir/[now]~ will come after ~lk linkpoint ::/some/dir/[now:-1D]~ because ~now > (now - one day)~

**** Why can't I own a group? / I'm not in control of the user! / Anybody in my group can leak data from it!?
I don't make the rules, I just make them obvious.

**** I want to add advertisements to my domain app/Every user of my domain app needs X from my server.
You hardcode a public key into the app, and also publish a group exchange service.
There are two primary ways to centralize information.
Either they connect over the public group, or you can connect over their-key XOR your-key group.

**** A domain can write outside its own domain space.
Yes, the current API has no restriction.
The best thing I think would be to build a wasm runtime interface and restrict access entirely.
That will take some time before we reached that point.

**** Why not use an SQL backend? / Why invent queries?
That is a complex question.
First off, if all you want is SQL queries it is relatively straight forward to stream packets into a SQL table and query them.
But SQL isn't magic, and its non-trivial price to pay for something that is not a great fit for a few fundamental problems including:
1) What is the index peers agree on?
2) How to constrain a query as it travels across a group?
Both can be solved in a number of ways, but most solutions are quickly going to bloat.
I've tried.

Queries have two desirable properties.
You can do a form of algebra on them with concatenation and equality.
They're powerful enough for where they're used.

**** Will it handle spam?
You can require proof of work or a proof of association.
POW is as simple as adding a predicate on the hash.
AI Generated spam only makes this association more important than it is now, and the linkspace protocol can help there.
Will it solve it entirely? Never.
But existing solutions can be adapted and we get more tools to do better.

* Example Domain App - Imageboard
:PROPERTIES:
:CUSTOM_ID: imageboard
:END:

#+begin_ctabs
#+begin_info

#+BEGIN_VERSE
Available in the repository/examples/app
#+END_VERSE

This is a very simplified example.
It shows what is required to write an instantly accessible multi-user indestructible serverless scalable (... etc)
app for everybody (or just your friends) using linkspace.

Should you build applications in bash? Fuck no.

The goal is to create an image collage with multiple people.
The data structure is as follows:

Adding an image is done by creating a linkpoint where the first path component indicates the name of the image.
The link tag's are decimal encoded [X, Y] coordinates.
It's ptr is a datapoint packet hash.
Building the collage is done by adding all images to a base image in 'create' order.
#+end_info

#+begin_sh

- placing images
  
#+INCLUDE: "../../examples/app/imageboard/imageboard.place.sh" src bash

- viewing images
#+INCLUDE: "../../examples/app/imageboard/imageboard.view.sh" src bash

- streaming images
#+INCLUDE: "../../examples/app/imageboard/imageboard.stream.sh" src bash
#+end_sh


#+begin_py
- placing images
#+INCLUDE: "../../examples/app/imageboard-py/imageboard.place.py" src bash

- viewing images
#+INCLUDE: "../../examples/app/imageboard-py/imageboard.view.py" src bash

- streaming images
#+INCLUDE: "../../examples/app/imageboard-py/imageboard.stream.py" src bash
#+end_py
#+end_ctabs

* Example Group Exchange - Anyhost
:PROPERTIES:
:CUSTOM_ID: anyhost
:END:

#+begin_ctabs
#+begin_info
#+BEGIN_VERSE
Available in the repo/examples/exchange
See repo/dev/exchange.md for some open design issues/notes.
#+END_VERSE

This is a rather dumb client & host.
It simply forwards requests.
It does no pruning before sending or receiving.
#+end_info
#+begin_sh

- anyhost client
#+INCLUDE: "../../examples/exchange/anyhost/bin/connect.sh" src bash
#+INCLUDE: "../../examples/exchange/anyhost/bin/client_io.sh" src bash

- handshake
#+INCLUDE: "../../examples/exchange/anyhost/bin/handshake.sh" src bash

- anyhost server
#+INCLUDE: "../../examples/exchange/anyhost/bin/serve.sh" src bash
#+INCLUDE: "../../examples/exchange/anyhost/bin/serve_io.sh" src bash
#+end_sh
#+end_ctabs
