<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-04-03 Mon 17:26 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Linkspace Guide</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="./style.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript" src="./tabs.js"></script>
<link rel="icon" type="image/x-icon" href="../../images/logo2.png">
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">The Linkspace Guide</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge550f52">Introduction</a></li>
<li><a href="#org6e3b0c3">Setup</a>
<ul>
<li><a href="#orge9cc9c5">linkspace-cli</a></li>
<li><a href="#orgd96a88b">lkpy - linkspace python bindings</a></li>
</ul>
</li>
<li><a href="#api">API overview</a></li>
<li><a href="#Point">Point</a>
<ul>
<li><a href="#datapoint">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
<li><a href="#org955854f">Fields</a></li>
<li><a href="#orgb884d61">Notes</a></li>
<li><a href="#orgbc8534f">lk_write and lk_read</a></li>
</ul>
</li>
<li><a href="#ABE">ABE</a>
<ul>
<li><a href="#org8298e58">Parsing</a></li>
<li><a href="#orga43ce17">lk_eval</a>
<ul>
<li><a href="#orgd43c685">Sub-expressions</a>
<ul>
<li><a href="#org877e3c8">Functions</a></li>
<li><a href="#org2978764">Evaluators</a></li>
</ul>
</li>
<li><a href="#orga6fafdb">Scope &amp; context</a>
<ul>
<li><a href="#org46f53e1">Argv</a></li>
<li><a href="#org3c6b122">Packet scope</a></li>
<li><a href="#orge18e756">Linkspace</a></li>
</ul>
</li>
<li><a href="#orgcb5ac03">Usage notes</a></li>
<li><a href="#abe-help">Help</a></li>
</ul>
</li>
<li><a href="#lk_encode">lk_encode</a>
<ul>
<li><a href="#org6eb1868">DEFAULT_FMT</a></li>
</ul>
</li>
<li><a href="#lk_split_abe">lk_split_abe</a></li>
<li><a href="#ABELNS">LNS</a></li>
</ul>
</li>
<li><a href="#Query">Query</a>
<ul>
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
<li><a href="#org6e10dfc">More on predicates</a>
<ul>
<li><a href="#predicatelist">Predicates &amp; options</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Linkspace">Linkspace</a>
<ul>
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_get">lk_get</a></li>
<li><a href="#lk_get_all">lk_get_all</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
<li><a href="#lk_close_watch">lk_close_watch</a></li>
</ul>
</li>
<li><a href="#Conventions">Conventions</a>
<ul>
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul>
</li>
<li><a href="#lns">LNS</a></li>
<li><a href="#qa">Q&amp;A</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#orgc8eb964">Why Big Endian?</a></li>
<li><a href="#org48c6679">Every user of my domain app needs X from my server/I want to add advertisements to my domain app.</a></li>
<li><a href="#org19a5078">I'm not in control of the user! / Anybody in my group can leak data from it!?</a></li>
<li><a href="#orgb67f0c4">A domain application can write outside its own domain space.</a></li>
<li><a href="#org364dcdc">Why not use an SQL backend? / Why invent queries?</a></li>
<li><a href="#org3c38b29">Will it handle spam?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#linkmail">Example Domain App - linkmail</a></li>
<li><a href="#imageboard">Example Domain App - Imageboard</a></li>
<li><a href="#anyhost">Example Group Exchange - Anyhost</a></li>
</ul>
</div>
</nav>
<p class="verse">
This document is kept up to date on a best effort basis.<br>
Sometimes the <a href="../cargo-doc/liblinkspace/index.html">liblinkspace</a> docs is ahead of this guide.<br>
</p>

<div id="outline-container-orge550f52" class="outline-2">
<h2 id="orge550f52">Introduction</h2>
<div class="outline-text-2" id="text-orge550f52">
<p>
Linkspace is a way to structure interlinked data into packets, addressable with a query, in order to build multi-participant applications.
<a href="../cargo-doc/liblinkspace/index.html">liblinkspace</a> is the authoritative implementation.
</p>

<p>
You should be familiar with the <a href="../../basics.html">basics</a>.
</p>

<p>
Projects such as Git, BitTorrent, Matrix, IPFS, and various blockchains already proof that addressing content by hash is a powerful abstraction.
It sidesteps or solves a number of difficulties inherent in organizing data as streams in applications.
Such a system is classified as a supernet when hashed entries include hashes to other entries<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<p>
The issue with supernets so far, is that they are bound to their use-case.
Linkspace is general purpose.
It is built to be fast and simple.
</p>
<p class="verse">
Supernet  [ˈsü-pərˌnet]<br>
<br>
A self-referential multi-participant data organization protocol whose primary<br>
addressing method uses hashes instead of endpoint identifiers.<br>
A communication protocol where the method of exchange is an extraneous concern.<br>
e.g. git, bitcoin, nostr, linkspace<br>
</p>

<p>
The supernet paradigm is a trade-off.
Instead of processing ordered streams of network data, an application is a function over the partial view of potentially noisy interlinked state.
This has upsides<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> and downsides.
</p>

<p>
liblinkspace is best understood as 4 ideas.
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> - Three types of packets</li>
<li><a href="#ABE">ABE</a> - (Byte) templating</li>
<li><a href="#Query">Query</a> - Query for selecting packets</li>
<li><a href="#Linkspace">Linkspace</a> - Reading, writing, and reacting to packets</li>
</ul>

<p>
A big addition compared to similar systems is the split between domains and groups.
It separates the responsibility of 'User Interface &amp; Data Structure' with the 'Members and the exchange of data'.
This split and other standard problems, are supported by a set of <a href="#Conventions">Conventions</a>.
</p>

<p>
The end of this document contains an example of both.
</p>
</div>
</div>

<div id="outline-container-org6e3b0c3" class="outline-2">
<h2 id="org6e3b0c3">Setup</h2>
<div class="outline-text-2" id="text-org6e3b0c3">
<p>
This guide uses Python and (Bash) CLI snippets.
You can get the latest version from <a href="https://github.com/AntonSol919/linkspace">GitHub</a>
</p>
</div>

<div id="outline-container-orge9cc9c5" class="outline-3">
<h3 id="orge9cc9c5">linkspace-cli</h3>
<div class="outline-text-3" id="text-orge9cc9c5">
<p>
<code>make install-lk</code> or:
</p>

<div class="org-src-container">
<pre class="src src-bash">cd cli/linkspace
cargo install --path .
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">lk --version
</pre>
</div>

<pre class="example" id="org3104c10">
linkspace-cli 0.1.3
</pre>
</div>
</div>


<div id="outline-container-orgd96a88b" class="outline-3">
<h3 id="orgd96a88b">lkpy - linkspace python bindings</h3>
<div class="outline-text-3" id="text-orgd96a88b">
<p>
<code>make install-lkpy</code> or: 
</p>

<div class="org-src-container">
<pre class="src src-bash">cd ffi/liblinkspace-py
make
source ./.env/bin/activate
python -i
&gt;&gt;&gt; import * from lkpy
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-api" class="outline-2">
<h2 id="api">API overview</h2>
<div class="outline-text-2" id="text-api">
<p>
The liblinkspace API is a small set of functions that is mostly stable.
It is available as a Rust crate <code>liblinkspace</code> and binding for other languages follow this API.
</p>

<p>
It consists of the following functions:
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> creation
<ul class="org-ul">
<li><a href="#datapoint-py">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
</ul></li>

<li><a href="#ABE">ABE</a> - ascii byte expressions - a language for manipulating and templating bytes
<ul class="org-ul">
<li><a href="#orga43ce17">lk_eval</a></li>
<li><a href="#lk_encode">lk_encode</a></li>
</ul></li>

<li><a href="#Query">Query</a> - Addressing and filtering of packets with predicates and options
<ul class="org-ul">
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
</ul></li>

<li><a href="#Linkspace">Linkspace</a> - Locally indexed packets and new packet processing functions
<ul class="org-ul">
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_get">lk_get</a></li>
<li><a href="#lk_get_all">lk_get_all</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
</ul></li>

<li><a href="#Conventions">Conventions</a> - functions
<ul class="org-ul">
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-Point" class="outline-2">
<h2 id="Point">Point</h2>
<div class="outline-text-2" id="text-Point">
<p class="verse">
<a href="../cargo-doc/liblinkspace/point/index.html">Rust docs</a><br>
</p>

<p>
Points are the basic units in linkspace.
They carry data, link to other points, and might contain information about the who, what, when, and how.
There are 3 kinds of points. datapoints, linkpoints, and keypoints.
A point has a maximum size of 2<sup>16</sup>-512 bytes.
</p>

<p>
Building a point is always combined with generating a hash and prepending a netheader.
Together the [netheader, hash, point] form a netpacket.
Functions usually deal with netpacket.
</p>
</div>

<div id="outline-container-datapoint" class="outline-3">
<h3 id="datapoint">lk_datapoint</h3>
<div class="outline-text-3" id="text-datapoint">
<div class="ctabs" id="orgce9af99">
<div class="sh" id="org17ac001">
<p>

</p>

<div class="org-src-container">
<pre class="src src-bash">echo -n "Hello, Sol" | lk data | lk printf "[hash:str]\n[data]"
</pre>
</div>

<pre class="example" id="org410166a">
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
</pre>

</div>

<div class="py" id="orgf5c8de4">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">from lkpy import *
datap = lk_datapoint(b"Hello, Sol")
lk_eval2str("[hash:str]\\n[data]", datap)
</pre>
</div>

<pre class="example" id="org1e61452">
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_linkpoint" class="outline-3">
<h3 id="lk_linkpoint">lk_linkpoint</h3>
<div class="outline-text-3" id="text-lk_linkpoint">
<p>
A linkpoint creates relations between packets by their hash and its location.
</p>

<p>
It consists of these fields:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Group<sub>32</sub></td>
<td class="org-left">the intended recipients.</td>
</tr>

<tr>
<td class="org-left">Domain<sub>16</sub></td>
<td class="org-left">the intended application.</td>
</tr>

<tr>
<td class="org-left">Path<sub>var&lt;240</sub></td>
<td class="org-left">Sequence of bytes. e.g. '/dir1/dir2/thing'</td>
</tr>

<tr>
<td class="org-left">Stamp<sub>8</sub></td>
<td class="org-left">Big endian UNIX timestamp in microseconds.</td>
</tr>

<tr>
<td class="org-left">Links<sub>48*n</sub></td>
<td class="org-left">A variable length list of (Tag<sub>16</sub>, Pointer<sub>32</sub>)</td>
</tr>

<tr>
<td class="org-left">-Link[0]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[1]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[2]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[&#x2026;]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Data<sub>var&lt;2<sup>16</sup></sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
A packets' location refers to its (Domain, Group, Path) triple.
All values, including the Path, contain arbitrary bytes.
</p>

<p>
The max space is shared between the links and data so beware that too much data and links won't fit into a single packet
<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> .
</p>

<p class="verse">
Packet hashes, GroupID's, and public keys are 32 bytes.<br>
They are usually encoded in URL-safe no-padding base64, e.g. <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code>.<br>
These hashes quickly make things unreadable.<br>
The <code>[...]</code> syntax (<a href="#ABE">ABE</a>) allows us to name and manipulate bytes.<br>
This following example shows that <code>[#:pub]</code> resolves to the bytes <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code> in both the Group and the second link<br>
Furthermore, If no group was provided it defaults to <code>[#:pub]</code><br>
</p>

<p>
Datapoints do not have a 'create' field, so they get the same hash given the same data.
If we had forced a specific 'create' stamp for both the python and bash example it would have produced the same hash for both.
Instead, 'create' defaults to the current time ( microseconds since epoch ), and thus the hash is different.
</p>

<div class="ctabs" id="org0ef9efc">
<div class="sh" id="org9b761f6">
<p>

</p>

<p>
The command <code>lk link</code> builds a linkpoint packets and output's it to stdout by default.
Whenever a cli commands deal with (domain, group, path) tuples, they are set from the first argument: <code>DOMAIN:GROUP:PATH</code>.
Here two links are added with the tags <code>first_tag_1</code> and <code>another_tag</code>
</p>


<div class="org-src-container">
<pre class="src src-bash">lk link "a_domain:[#:pub]:/dir1/dir2/thing" \
          -l first_tag_1:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0 \
          -l another_tag:[#:pub] \
| lk printf

</pre>
</div>

<pre class="example" id="orgc60e148">
type	LinkPoint
hash	H_I17gRmSeofg8X2tau23ka_giO5CXcCLy8OAlmtd_4
group	[#:pub]
domain	a_domain
path	/dir1/dir2/thing
pubkey	[@:none]
create	1680535581052268
links	2
	first_tag_1 RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	another_tag RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0

data	0
</pre>

</div>


<div class="py" id="org7393b33">
<p>

</p>

<p>
The API deals with arbitrary bytes, not encoded strings.
In python, we have 4 common ways to get bytes.
</p>

<ul class="org-ul">
<li><code>"some string".encode()"</code></li>
<li>the <code>b"byte notation"</code></li>
<li>fields like <code>apkt.group</code>, <code>apkt.hash</code> <code>apkt.domain</code> etc</li>
<li>evaluate an ABE string with <a href="#orga43ce17">lk_eval</a>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">ptr1 = lk_eval("[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]")
link1 = Link(tag=b"first tag 1",ptr=ptr1)

ptr2 = lk_eval("[#:pub]")
link2 = Link(b"another tag",ptr2)

assert(link1.ptr == link2.ptr)

datap = lk_datapoint(b"Hello example");
link3 = Link(b"a datapacket",datap.hash)

linkp = lk_linkpoint(
    domain=b"example-domain",
    group=lk_eval("[#:pub]"),
    data=b"Hello, World!",
    links=[link1,link2,link3]
)
str(linkp)
</pre>
</div>

<pre class="example" id="org4e19d50">
type	LinkPoint
hash	NG9hX5iwiE_FiJh-ays5AwLlwsUcN-MkE2MmKg6XVzk
group	[#:pub]
domain	example-domain
path	
pubkey	[@:none]
create	1680535581225226
links	3
	first tag 1 RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	another tag RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	a datapacket Y1DQDTA7NP1f6IwzPW2wKF6duXw00fE5fR30WhJz6pg

data	13
Hello, World!
</pre>

</div>

</div>
</div>
</div>



<div id="outline-container-lk_keypoint" class="outline-3">
<h3 id="lk_keypoint">lk_keypoint</h3>
<div class="outline-text-3" id="text-lk_keypoint">
<p>
A key point is a linkpoint with an additional publickey and signature.
</p>

<p>
There are functions to generate, encrypt, and decrypt a linkspace key.
Leaving you to deal with the saving.
Alternatively there is the <a href="#lk_key">lk_key</a> function that does it all for you.
With the added benefit that you can address your own public key as <code>[@:me:local]</code>.
</p>

<div class="ctabs" id="orgf620177">
<div class="sh" id="org94e1068">
<div class="org-src-container">
<pre class="src src-bash">export LINKSPACE=/tmp/linkspace
lk --init key --decrypt-cost 0 --password "my secret" # remove the --decrypt-cost. it speeds up building this doc
</pre>
</div>

<pre class="example" id="orgec941b0">
$argon2d$v=19$m=8,t=1,p=1$fS076URQr3MdOeZcVlsnHAahvjUC0ug6JnVMOLi7h5U$tsCwXCnwyAaTLBKcheRU2T++Jv5T4MNVKOZZ5XPGu+w=
fS076URQr3MdOeZcVlsnHAahvjUC0ug6JnVMOLi7h5U
</pre>

<div class="org-src-container">
<pre class="src src-bash">lk keypoint "example::" --password "my secret" | lk printf
</pre>
</div>

<pre class="example" id="orgbb369bb">
type	KeyPoint
hash	9fDdryDiFU5aCJWd-uOW_CNnsRBh3EiLh8nERfUaSuA
group	[#:pub]
domain	example
path	
pubkey	[@:me:local]
create	1680535581292008
links	0

data	0
</pre>

<p class="verse">
The CLI also accepts <code>lk link --sign</code> instead of <code>lk keypoint</code><br>
</p>

</div>
<div class="py" id="orgf2b3fa6">
<div class="org-src-container">
<pre class="src src-python">lk = lk_open("/tmp/linkspace",create=True)
key = lk_key(lk,b"my secret");
example_keypoint = lk_keypoint(key=key,domain=b"example")
str(example_keypoint)
</pre>
</div>

<pre class="example" id="org0153c8b">
type	KeyPoint
hash	86dpXcyaCtTAXHEIy6qXh9HTDF9eeV3ZiZBxp5mnuAg
group	[#:pub]
domain	example
path	
pubkey	[@:me:local]
create	1680535581536169
links	0

data	0

</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-org955854f" class="outline-3">
<h3 id="org955854f">Fields</h3>
<div class="outline-text-3" id="text-org955854f">
<p>
In python you can access these fields directly as bytes.
The fields included in the hash are not writable.
</p>

<div class="org-src-container">
<pre class="src src-python">[attr for attr in dir(lk_linkpoint())  if not "__" in attr]
</pre>
</div>

<pre class="example" id="org6c8d06e">
['comp0', 'comp1', 'comp2', 'comp3', 'comp4', 'comp5', 'comp6', 'comp7', 'create', 'data', 'domain', 'group', 'hash', 'hop', 'ipath', 'links', 'netflags', 'path_len', 'path_list', 'pkt_type', 'point_size', 'pubkey', 'recv', 'signature', 'spath', 'ubits0', 'ubits1', 'ubits2', 'ubits3', 'until']
</pre>

<p>
Where comp[0..7] are the path components, 
</p>
</div>
</div>

<div id="outline-container-orgb884d61" class="outline-3">
<h3 id="orgb884d61">Notes</h3>
<div class="outline-text-3" id="text-orgb884d61">
<p>
Groups signals the intended set of recipients.
Domains signal the activity, and practically the application used to present an interface to the user.
</p>

<p>
The groups bytes are simply chosen and membership is enforced by its members.
They exist because we say they exist.
It's up to the user (or some to be build management tool) to pick a method of data exchange.
Group bytes can be chosen to have a special meaning, such as public key or a pointer to a list of publickeys that act as group administrators.
</p>

<p>
The following do have a meaning.
The [0;32] null group ( <code>[#:0]</code> ), i.e. the local only group, is never transmitted to other devices and is never accepted from outside sources.
Everything in the <code>[#:pub]</code> group<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> is meant for everybody. e.g. the public.
</p>

<p>
By convention the group created by pubkey1 XOR pubkey2 forms a group with those keys as its only two members.
</p>

<p class="verse">
The <code>[#:...]</code> is part of the <a href="#lns">LNS</a>.<br>
A public registry for assigning names and naming rights.<br>
e.g. <code>[#:sales:mycomp:com]</code> for groups and <code>[@:alicekey:mycomp:com]</code> for keys.<br>
</p>
</div>
</div>


<div id="outline-container-orgbc8534f" class="outline-3">
<h3 id="orgbc8534f">lk_write and lk_read</h3>
<div class="outline-text-3" id="text-orgbc8534f">
<p>
The vast majority of developers should not have to deal with IO and the byte representation of packets.
Unless you're writing an exchange process.
</p>
</div>
</div>
</div>

<div id="outline-container-ABE" class="outline-2">
<h2 id="ABE">ABE</h2>
<div class="outline-text-2" id="text-ABE">
<p class="verse">
<a href="../cargo-doc/liblinkspace/abe/index.html">Rust docs</a><br>
</p>

<p>
ABE (Ascii-Byte-Expr) is a tiny byte templating language.
A stringly representation of delimited bytes.  
Its primary purpose is to make it easy for developers to read and write sequences of arbitrary (0..=255) bytes in plain ascii.
In addition, it supports evaluation of functions that act as shorthand for long sequences of bytes. 
</p>

<p>
Linkspace has no concept of encoding.
Fields have a fixed length or prefix their exact length.
The <code>null</code> (0) byte is not special.
</p>

<p>
ABE is used for things like <a href="#Query">Query</a> or simply <a href="#org6eb1868">printing</a> to talk about these bytes.
</p>

<p>
ABE is not meant to be a proramming language!
It's primarily meant to read and write arbitrary bytes in some context and quickly beat them into a desired shape.
Some things are limited by design.
Prefer to use the language you're developing in.
</p>

<p>
When building an application its up to the developer to define what the bytes in the data, link and path components mean.
And subsequently what the end user sees.
</p>

<p>
If the goal is to display, you should stick with UTF-8.
But if a value is just bytes, avoid adding an additional base64(bytes).
</p>
</div>

<div id="outline-container-org8298e58" class="outline-3">
<h3 id="org8298e58">Parsing</h3>
<div class="outline-text-3" id="text-org8298e58">
<ul class="org-ul">
<li>Most printable ascii letters are as is.</li>
<li>Newline and Tab are external delimiters. Separating two blocks.</li>
<li><code>:</code> and <code>/</code> are internal delimiters. Separating two byte expressions.</li>
<li><code>[</code> and <code>]</code> wrap an expression</li>
<li><code>:</code>, <code>/</code>, <code>\</code>, <code>[</code>, <code>]</code>  can be escaped with a <code>\</code>. (Use <code>'\n'</code> and <code>'\t'</code> for newline and tab )</li>
<li><code>\x00</code> up-to <code>\xFF</code> for bytes.</li>
<li><code>\0</code> equals  <code>\x00</code>,  <code>\f</code> equals <code>\xFF</code></li>
</ul>

<p>
We can encode binary into valid abtxt as follows:
</p>
<p class="verse">
We'll get back to <a href="#lk_encode">encode</a> later.<br>
</p>

<div class="ctabs" id="orgd7a08dd">
<div class="bash" id="org09f4e3d">
<div class="org-src-container">
<pre class="src src-bash">printf "hello" | lk encode -i
printf "world/" | lk encode -i
printf "nl \n tab \t" | lk encode -i
printf "open [ close ]" | lk encode -i
printf "smiley 😍" | lk encode -i
</pre>
</div>

<pre class="example" id="org2876350">
hello
world\/
nl \n tab \t
open \[ close \]
smiley \xf0\x9f\x98\x8d
</pre>

</div>

<div class="py" id="orgc89cfb4">
<p>
All packet fields are arbitrary bytes, and lk_encode can print them as abtext
</p>

<div class="org-src-container">
<pre class="src src-python">multiline = """newline
tab	""".encode()

lkp = lk_linkpoint(path=[b"hello",b"world/",multiline,b"open [ close ]", "smiley 😍".encode()])

print(lk_encode(lkp.comp0),"\t",list(lkp.comp0))
print(lk_encode(lkp.comp1),"\t",list(lkp.comp1))
print(lk_encode(lkp.comp2),"\t",list(lkp.comp2))
print(lk_encode(lkp.comp3),"\t",list(lkp.comp3))
print(lk_encode(lkp.comp4),"\t",list(lkp.comp4))

</pre>
</div>

<pre class="example" id="org7e5eba9">
hello 	 [104, 101, 108, 108, 111]
world\/ 	 [119, 111, 114, 108, 100, 47]
newline\ntab\t 	 [110, 101, 119, 108, 105, 110, 101, 10, 116, 97, 98, 9]
open \[ close \] 	 [111, 112, 101, 110, 32, 91, 32, 99, 108, 111, 115, 101, 32, 93]
smiley \xf0\x9f\x98\x8d 	 [115, 109, 105, 108, 101, 121, 32, 240, 159, 152, 141]
</pre>

</div>

</div>
</div>
</div>


<div id="outline-container-orga43ce17" class="outline-3">
<h3 id="orga43ce17">lk_eval</h3>
<div class="outline-text-3" id="text-orga43ce17">
<p>
ABE is evaluated by substituting an expressions ( <code>[..]</code> ) with its result.
For example in <code>[u8:97]</code>, the function 'u8' parses "97" and prints it.
The byte 99 equals the character 'c'.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk eval "ab[u8:99]" | xxd
</pre>
</div>

<pre class="example" id="org02936fc">
00000000: 6162 63                                  abc
</pre>

<p>
The result of an ABE is a list of (bytes, ?delimiter). 
</p>

<div class="org-src-container">
<pre class="src src-bash">lk eval --json "h[u8:101]ll[u8:111] / world:etc" 
</pre>
</div>

<pre class="example" id="org38a5d10">
[["hello ","/"],[" world",":"],["etc",null]]
</pre>


<p>
Note that bytes are joined after evaluating. In the example this results in the component <code>('hello ', /)</code>.
The delimiters ('\n' '\t' ':' '/') are interpreted depends on the context.
In the top level of the template given to <code>lk eval</code> they are printed as is.
</p>

<p>
In other words: <code>eval "hello/:[u8:99]\n"</code> == <code>hello/:c\n</code> ,
but within brackets they have a special meaning:  <code>eval "hello/:[hello/ \n :]"</code> will error.
</p>

<p class="verse">
The rest of this chapter goes further in depth.<br>
Understanding ABE in depth is not critical.<br>
With basic knowledge of its purpose, expression substitution (<code>[..]</code>), and the <code>':'</code>, <code>'/'</code> delimiters the reader can choose to<br>
skip to the next chapter <a href="#Query">Query</a> and return here for reference later.<br>
</p>
</div>


<div id="outline-container-orgd43c685" class="outline-4">
<h4 id="orgd43c685">Sub-expressions</h4>
<div class="outline-text-4" id="text-orgd43c685">
<p>
A list of functions/evaluators be found by evaluating
<a href="#abe-help">[[help</a>][\[help\]]].
</p>
</div>

<div id="outline-container-org877e3c8" class="outline-5">
<h5 id="org877e3c8">Functions</h5>
<div class="outline-text-5" id="text-org877e3c8">
<ul class="org-ul">
<li><code>[fn]</code></li>
<li><code>[fn:arg0]</code></li>
<li><code>[fn:arg0:arg1]</code></li>
</ul>

<p>
The arguments are bytes. They take upto 8 arguments.
The resulting bytes are concatenated with their surrounding.
The empty function <code>'[:...]'</code> resolves to its first argument.
</p>

<ul class="org-ul">
<li><code>hello [:world]</code> == <code>hello world</code></li>
</ul>

<p>
Arguments are evaluated before application.
<code>[fn0:[fn1]]</code> will call fn1 and use its result as the first argument to fn0.
</p>

<p>
You can carry results with <code>/</code>.
It uses the result as the first argument to the next function.
</p>

<ul class="org-ul">
<li><code>[:97/u8]</code> <code>= ~[u8:97]~ =</code> <code>a</code></li>
<li><code>[:97/u8/?u]</code> <code>= ~[?u:[u8:97]]~ =</code> <code>97</code></li>
</ul>

<p>
You can think of ABE functions as a translation of conventional function calling.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>[name:arg1:arg2]</code></td>
<td class="org-left"><code>name(arg1,arg2)</code></td>
</tr>

<tr>
<td class="org-left"><code>[name:[other_name:argA]:arg2]</code></td>
<td class="org-left"><code>name( other_name(argA) , arg2 )</code></td>
</tr>

<tr>
<td class="org-left"><code>[other_name:argA/name:arg2]</code></td>
<td class="org-left"><code>name ( other_name(argA) , arg2 )</code></td>
</tr>
</tbody>
</table>


<p class="verse">
Functions are aware if they are first or not.<br>
The vast majority of functions do not care.<br>
</p>

<p class="verse">
<code>[[:u8]:97]</code> is explicitly not allowed. Variable function identifiers are conceptually interesting but practically begging for bugs.<br>
</p>
</div>
</div>

<div id="outline-container-org2978764" class="outline-5">
<h5 id="org2978764">Evaluators</h5>
<div class="outline-text-5" id="text-org2978764">
<p>
The second type of operation is calling an evaluator.
Whereas functions are called after their arguments are evaluated.
Evaluators are called without evaluation <code>[..]</code> expressions.
</p>

<ul class="org-ul">
<li><code>[/re]</code></li>
<li><code>[/re:arg0:arg1]</code></li>
<li><code>[/re:[fn:arg0]:arg1]</code></li>
</ul>

<p>
The <code>/re</code> evaluator operates on <code>:[fn:arg0]:arg1</code> without it being evaluatedd.<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>
</p>

<p>
The most common use-case for evaluators is extending the scope.
</p>
</div>
</div>
</div>

<div id="outline-container-orga6fafdb" class="outline-4">
<h4 id="orga6fafdb">Scope &amp; context</h4>
<div class="outline-text-4" id="text-orga6fafdb">
<p>
Functions and evaluators are defined in a scope.
The standard scope contains functions to manipulate bytes.
Some scopes require a context.
</p>

<p>
You can see all active scopes with the help function.
</p>
</div>

<div id="outline-container-org46f53e1" class="outline-5">
<h5 id="org46f53e1">Argv</h5>
<div class="outline-text-5" id="text-org46f53e1">
<p>
A straightforward scope is the argument vector.
</p>

<div class="ctabs" id="orgfa09872">
<div class="py" id="org8f6dc4b">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">inp = "Rm9ycmVzdA" # the base 64 encoding of the word "Forrest"
lk_eval("[0] [1/b], [0]!",argv=["Run",inp])
</pre>
</div>

<pre class="example" id="org874df1f">
b'Run Forrest, Run!'
</pre>

</div>

</div>
</div>
</div>



<div id="outline-container-org3c6b122" class="outline-5">
<h5 id="org3c6b122">Packet scope</h5>
<div class="outline-text-5" id="text-org3c6b122">
<p>
By providing a packet, the packet scope is added.
This adds operations to evaluate packet fields such as <code>hash</code>, <code>group</code>, <code>path</code> etc.
These are bytes that you can use as arguments.
</p>

<p>
e.g <code>[hash/?b]</code> encodes the hash in base 64.
</p>

<p>
For convenience all packet fields accept 'str' and 'abe' as a first argument to print them in a default format.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>[hash:str]</code></td>
<td class="org-left"><code>[hash/?b]</code></td>
</tr>

<tr>
<td class="org-left"><code>[group:str]</code></td>
<td class="org-left"><code>[group/?b]</code></td>
</tr>

<tr>
<td class="org-left"><code>[create:str]</code></td>
<td class="org-left"><code>[create/?u]</code></td>
</tr>

<tr>
<td class="org-left"><code>[links_len:str]</code></td>
<td class="org-left"><code>[links_len/?u]</code></td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The <code>[/links:...]</code> evaluator iterates over every link in a packet.
It evaluates the inner scope for each link with setting the <code>tag</code> and <code>ptr</code> function.
</p>

<div class="ctabs" id="orgf68fd13">
<div class="sh" id="orga395fa2">
<p>
<code>printf</code> is <code>eval</code> that reads packets from stdin and puts them in scope.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk link "::" -l tag1:[#:0] -l tag2:[#:pub] | \
    lk printf "HASH:[hash/?b]\n[/links:TAG = [tag:str] PTR = [ptr:str] \n]"
</pre>
</div>

<pre class="example" id="org6291e07">
HASH:GArlCecuk4eFpbYJspgE9wkY4cZNK0ziHi6KadC0q4I
TAG = tag1 PTR = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
TAG = tag2 PTR = RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
</pre>

</div>

<div class="py" id="orgd3ffe6f">
<div class="org-src-container">
<pre class="src src-python">lp = lk_linkpoint(links=[Link("hello",PUBLIC),Link("world",PRIVATE)])
lk_eval2str("hash:[hash:str]\\n[/links:[tag:str] [ptr:str]\\n]",pkt=lp)
</pre>
</div>

<pre class="example" id="org7c5add9">
hash:qkHF5jH1lVz08xG_yEySlQCXgX--qWDPojYS3VEyTpc
hello RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
world AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-orge18e756" class="outline-5">
<h5 id="orge18e756">Linkspace</h5>
<div class="outline-text-5" id="text-orge18e756">
<p>
Having a linkspace instance in the scope gives you access to functions like:
</p>

<ul class="org-ul">
<li><code>#</code> and <code>@</code> ( see <a href="#lns">LNS</a> ) for named groups, keys, and other data</li>
<li><code>readhash</code></li>
</ul>

<p>
When using <a href="#lk_open">lk_open</a> , the instance is automatically setup as scope.
</p>

<p>
<code>readhash</code> is considered bad practice, fine to hack something together, but it doesn't give you much room to process errors or async.
But you can do some wizardry combining it with <code>[/links]</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcb5ac03" class="outline-4">
<h4 id="orgcb5ac03">Usage notes</h4>
<div class="outline-text-4" id="text-orgcb5ac03">
<p>
ABE expressions evaluate into a list of [ (bytes,?sep) ].
Sometimes each element has a different meaning, e.g. [ ( domain , : ) , (group , _) ] in the CLI arguments.
You can process this list with <code>lk_split_abe</code>. 
</p>

<p>
But in the majority of cases we don't care about the list and just want a single result.
<code>lk_eval</code> does just that. It interprets the separators as plain characters.
</p>

<p>
Finally, consider what you would expect to happen when an evaluator takes a ABE expression as its final argument:
</p>

<ul class="org-ul">
<li><code>[/links:abc[:hello]/world]</code></li>
<li><code>[/readhash:[#:pub]:the pkt:[pkt]]</code></li>
<li><code>[/:hello/world]</code></li>
<li id="~lk link">&#x2013;write 'file:./afolder:with/colons'~</li>
</ul>

<p>
The choice was made that if the final argument is an abe expression that will be evaluated, it doesn't need wrapping <code>[]</code>.
Instead, it interprets the entire tail as is.
This reduces the need to escape ':' and '/', but complicating some other expressions.
</p>

<p class="verse">
We can add an expression to &#x2013;write arguments<br>
<code>lk link :: --write "stdout-expr:hello world:/ [hash:str]"</code><br>
In case of <code>file</code> this leaves us in the situation that second argument is the file and the tail of the expression will be evaluated<br>
The simplest way to ignore all escapes is to use empty evaluator <code>[/:..]</code>.<br>
<code>lk link :: --write "file-expr:[/:./afolder:with/colons]:hello world:/ [hash:str]"</code><br>
</p>
</div>
</div>


<div id="outline-container-abe-help" class="outline-4">
<h4 id="abe-help">Help</h4>
<div class="outline-text-4" id="text-abe-help">
<p>
A full list of active scopes can be viewed with the <code>help</code> function.
</p>
<div class="ctabs" id="orga97ec3b">
<div class="misc" id="orgb5f3bec">
<p class="verse">
The following naming conventions are used:<br>
<br>
- ending with '?' is a predicate to check a property.<br>
- starting with '?' is a basic reverse operation. [u8:97/?u] == 97. Its similar but less powerful then <a href="#lk_encode">lk_encode</a> and lacking '[]' brackets.<br>
- b_RADIX_ ( b2, b8, b16 ) 'b' defaults to base64 radix<br>
- u_SIZE_  ( u8, .., u128 ) parse decimal into big endian bytes. ?u interpret as big endian print to decimal<br>
</p>

</div>

<div class="py" id="orge14607c">
<div class="org-src-container">
<pre class="src src-python">lk_eval2str("[help]",pkt=lk_linkpoint(),argv=["hello"]) # the help won't show up if no scope is set. 
</pre>
</div>

<pre class="example" id="orgdd8e98e">
==scopes==
# bytes
Byte padding/trimming
## functions
-                  /:?          1..=16     the '' (empty) fnc can be used to start an expr such as {:12/u8} which is the same as {u8:12}  
- ?a               /:?          1..=1     encode bytes into ascii-bytes format  
- ?a0              /:?          1..=1     encode bytes into ascii-bytes format but strip prefix '0' bytes  
- a                /:?          1..=3     [bytes,length = 16,pad_byte = \0] - alias for 'lpad'  
- f                /:?          1..=3     same as 'a' but uses \xff as padding   
- lpad             /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad input bytes  
- rpad             /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad input bytes  
- ~lpad            /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad input bytes  
- ~rpad            /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad input bytes  
- lcut             /:?          1..=2     [bytes,length = 16] - left cut input bytes  
- rcut             /:?          1..=2     [bytes,length = 16] - right cut input bytes  
- ~lcut            /:?          1..=2     [bytes,length = 16] - lcut without error  
- ~rcut            /:?          1..=2     [bytes,length = 16] - lcut without error  
- lfixed           /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad and cut input bytes  
- rfixed           /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad and cut input bytes  
- slice            /:?          1..=4     [bytes,start=0,stop=len,step=1] - python like slice indexing  
- b2               /:?          1..=1     decode binary  
- b8               /:?          1..=1     decode octets  
- b16              /:?          1..=1     decode hex  

# UInt
Unsigned integer functions
## functions
- +                /:?          1..=16     Saturating addition. Requires all inputs to be equal size  
- -                /:?          1..=16     Saturating subtraction. Requires all inputs to be equal size  
- u8               /:?          1..=1     parse 1 byte  
- u16              /:?          1..=1     parse 2 byte  
- u32              /:?          1..=1     parse 4 byte  
- u64              /:?          1..=1     parse 8 byte  
- u128             /:?          1..=1     parse 16 byte  
- ?u               /:?          1..=1     Print big endian bytes as decimal  
- lu               /:?          1..=1     parse little endian byte (upto 16)  
- lu8              /:?          1..=1     parse 1 little endian byte  
- lu16             /:?          1..=1     parse 2 little endian byte  
- lu32             /:?          1..=1     parse 4 little endian byte  
- lu64             /:?          1..=1     parse 8 little endian byte  
- lu128            /:?          1..=1     parse 16 little endian byte  
- ?lu              /:?          1..=1     print little endian number  

# b64
base64 url-safe no-padding
## functions
- ?b               /:?          1..=1     encode base64  
- 2mini            /:?          1..=1     encode mini  
- b                /:?          1..=1     decode base64  

# comment function / void function. evaluates to nothing

## functions
- C                /:?          1..=16     the comment function. all arguments are ignored. evaluates to ''  

# help

## functions
- help             /:           0..=16     help  
## eval
- help             desribe current eval context  

# logic ops
ops are : &lt; &gt; = 0 1 
## functions
- size?            /:?          3..=3     [in,OP,VAL] error unless size passes the test ( UNIMPLEMENTED )  
- val?             /:?          3..=3     [in,OP,VAL] error unless value passes the test ( UNIMPLMENTED)  
## eval
- or               :{EXPR}[:{EXPR}]* short circuit evaluate until valid return. Empty is valid, use {_/minsize?} to error on empty  

# encode
attempt an inverse of a set of functions
## functions
- eval             /:           1..=1     parse and evaluate  
## eval
- ?                find an abe encoding for the value trying multiple reversal functions - [/fn:{opts}]*   
- ~?               same as '?' but ignores all errors  
- e                eval inner expression list. Useful to avoid escapes: eg file:{/e:/some/dir:thing}:opts does not require escapes the '/'   

# static-lns
static lns for local only [#:0] and public [#:pub]
## functions
- #                / ?          1..=16     resolve #:0 , #:pub, and #:test without a db  
- @                / ?          1..=16     resolve @:none  

# stamp
utilities for stamp values (big endian u64 microsecond since unix epoch)
arguments consists of ( [+-][YMWDhmslu]usize : )* (str | delta | ticks | val)?

## functions
- s                /:           0..=16     if chained, mutate 8 bytes input as stamp (see scope help). if used as head assume stamp 0  
- now              / ?          0..=16     current systemtime  
- epoch            / ?          0..=16     unix epoch / zero time  
- s++              / ?          0..=16     max stamp  

# path
spath and ipath utils. Usually [//some/path] is the most readable
## functions
- ?sp              /:?          1..=1     decode spath  
- ?ip              /:?          1..=1     decode ipath  
- ipcomp           /:?          2..=3     ipath select [start,?end]  
- spcomp           /:?          2..=3     ipath select [start,?end]  
- ip               /:?          1..=8     build ipath from arguments  
- sp               /:?          1..=8     build spath from arguments  
## eval
-                  the 'empty' eval for build spath. i.e. [//some/spath/val] creates the byte for /some/spath/val  
- ~                similar to '//' but forgiving on empty components  

# lns

## functions
- #                / ? &lt;partial&gt; 1..=7     (namecomp)* - get the associated lns group  
- ?#               /:?          1..=1     find by group# tag  
- @                / ? &lt;partial&gt; 1..=7     (namecomp)* - get the associated lns key  
- ?@               /:?          1..=1     find by pubkey@ tag  
## eval
- lns              [:comp]*/expr  

# private-lns
Only look at the private claims lookup tree. Makes no requests
## functions
- private#         / ?          1..=7     (namecomp)* - get the associated lns group  
- ?private#        /:?          1..=1     find by group# tag  
- private@         / ?          1..=7     (namecomp)* - get the associated lns key  
- ?private@        /:?          1..=1     find by pubkey@ tag  
## eval
- private-lns      [:comp]*/expr  

# filesystem env
read files from Ok("/tmp/linkspace") 
## functions
- conf             /:           1..=1     read a file from the conf directory  

# database
get packets from the local db.
e-funcs evaluate their args as if in pkt scope.
funcs evaluate as if [/[func + args]:[rest]]. (e.g. [/readhash:HASH:[group:str]] == [readhash:..:group:str])
## functions
- readhash         /:           1..=16     open a pkt by hash and use tail args as if calling in a netpkt scope  
- read             /:           2..=16     read but accesses open a pkt by dgpk path and apply args. e.g. [read:mydomain:[#:pub]:[//a/path]:[@:me]::data:str], prefer eval ctx  
## eval
- readhash         HASH ':' expr (':' alt if not found)   

# netpkt field
get a field of a netpkt. also used in watch predicates.
## functions
- netflags         /            0..=1     ?(str|abe) - netpkt.netflags  
- hop              /            0..=1     ?(str|abe) - netpkt.hop  
- stamp            /            0..=1     ?(str|abe) - netpkt.stamp  
- ubits0           /            0..=1     ?(str|abe) - netpkt.ubits0  
- ubits1           /            0..=1     ?(str|abe) - netpkt.ubits1  
- ubits2           /            0..=1     ?(str|abe) - netpkt.ubits2  
- ubits3           /            0..=1     ?(str|abe) - netpkt.ubits3  
- hash             /            0..=1     ?(str|abe) - netpkt.hash  
- type             /            0..=1     ?(str|abe) - netpkt.type  
- point_size       /            0..=1     ?(str|abe) - netpkt.point_size  
- pubkey           /            0..=1     ?(str|abe) - netpkt.pubkey  
- signature        /            0..=1     ?(str|abe) - netpkt.signature  
- group            /            0..=1     ?(str|abe) - netpkt.group  
- domain           /            0..=1     ?(str|abe) - netpkt.domain  
- create           /            0..=1     ?(str|abe) - netpkt.create  
- path_len         /            0..=1     ?(str|abe) - netpkt.path_len  
- links_len        /            0..=1     ?(str|abe) - netpkt.links_len  
- data_size        /            0..=1     ?(str|abe) - netpkt.data_size  
- path             /            0..=1     ?(str|abe) - netpkt.path  
- ipath            /            0..=1     ?(str|abe) - netpkt.ipath  
- comp0            /            0..=1     ?(str|abe) - netpkt.comp0  
- comp1            /            0..=1     ?(str|abe) - netpkt.comp1  
- comp2            /            0..=1     ?(str|abe) - netpkt.comp2  
- comp3            /            0..=1     ?(str|abe) - netpkt.comp3  
- comp4            /            0..=1     ?(str|abe) - netpkt.comp4  
- comp5            /            0..=1     ?(str|abe) - netpkt.comp5  
- comp6            /            0..=1     ?(str|abe) - netpkt.comp6  
- comp7            /            0..=1     ?(str|abe) - netpkt.comp7  
- data             /            0..=1     ?(str|abe) - netpkt.data  

# print pkt default

## functions
- pkt              /            0..=0     default pk fmt  
- netpkt           /            0..=0     TODO default netpkt fmt  
- point            /            0..=0     TODO default point fmt  
- netbytes         / ?          0..=0     raw netpkt bytes  

# select link

## functions
- *=               /:?          1..=1     [suffix] get first link with tag ending in suffix  
## eval
- links            :{EXPR} where expr is repeated for each link binding 'ptr' and 'tag'  

# recv
recv stamp for packet. value depends on the context
## functions
- recv             / ?          0..=0     recv stamp - errors if unavailable in context  
- recv_now         / ?          0..=0     recv stamp - recv stamp returns now if unavailable in context  

# user input list
Provide values, access with {0} {1} .. {7} 
## functions
- 0                / ?          0..=0     argv[0]  
- 1                / ?          0..=0     argv[1]  
- 2                / ?          0..=0     argv[2]  
- 3                / ?          0..=0     argv[3]  
- 4                / ?          0..=0     argv[4]  
- 5                / ?          0..=0     argv[5]  
- 6                / ?          0..=0     argv[6]  
- 7                / ?          0..=0     argv[7]  

</pre>

</div>

</div>
</div>
</div>
</div>

<div id="outline-container-lk_encode" class="outline-3">
<h3 id="lk_encode">lk_encode</h3>
<div class="outline-text-3" id="text-lk_encode">
<p>
Translate bytes into abe such that <code>lk_eval(lk_encode(X)) == X</code>
</p>

<p class="verse">
We can get meta. lk_encode is available as the evaluator <code>[/?:bytes:options]</code><br>
</p>

<div class="ctabs" id="orgb5edbed">
<div class="py" id="org6bea847">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">data = bytes([0,0,0,255])
abe = lk_encode(data)
assert data == lk_eval(abe)
print("ab  text:", abe)
abe = lk_encode(data,"u8/u32/b") # Try to encode as expression
print("abe text:", abe)
</pre>
</div>

<pre class="example" id="org6a3d361">
ab  text: \0\0\0\f
abe text: [u32:255]
</pre>

</div>

</div>
</div>

<div id="outline-container-org6eb1868" class="outline-4">
<h4 id="org6eb1868">DEFAULT_FMT</h4>
<div class="outline-text-4" id="text-org6eb1868">
<p>
This is how packets are printed by default using <code>lk printf</code> or pythons <code>str(pkt)</code>.
</p>

<div class="ctabs" id="orgf46fdd2">
<div class="py" id="orgf4ff082">
<div class="org-src-container">
<pre class="src src-python">import lkpy
print(lkpy.DEFAULT_PKT)
</pre>
</div>

<pre class="example" id="org6a9604d">
type\t[type:str]\nhash\t[hash:str]\ngroup\t[/~?:[group]/#/b]\ndomain\t[domain:str]\npath\t[path:str]\npubkey\t[/~?:[pubkey]/@/b]\ncreate\t[create:str]\nlinks\t[links_len:str]\n[/links:\t[tag:str] [ptr:str]\n]\ndata\t[data_size:str]\n[data:str]\n
</pre>

</div>

</div>
</div>
</div>
</div>



<div id="outline-container-lk_split_abe" class="outline-3">
<h3 id="lk_split_abe">lk_split_abe</h3>
<div class="outline-text-3" id="text-lk_split_abe">
</div>
</div>



<div id="outline-container-ABELNS" class="outline-3">
<h3 id="ABELNS">LNS</h3>
<div class="outline-text-3" id="text-ABELNS">
<p>
LNS is a system for publicly naming keys and groups, and adding auxiliary data to them.
It allows you to register as <code>@:Alice:nl</code>, <code>#:sales:company:com</code>, etc.
</p>

<p>
LNS is easy to use from an abe expression.
Both to lookup and do a reverse lookup.
</p>

<p>
See <a href="../../lns.html">lns</a> for info.
</p>

<p class="verse">
You can create local bindings, allowing you to reference <code>[@:my_identity:local]</code> or <code>[#:friends:local]</code><br>
By default <a href="#lk_key">lk_key</a> sets up the <code>[@:me:local]</code> identity.<br>
</p>

<div class="ctabs" id="orgf154b4d">
<div class="sh" id="orged6973f">
<div class="org-src-container">
<pre class="src src-bash">lk eval "[#:pub]" | lk encode "@/#/b"
</pre>
</div>

<pre class="example" id="org6894ecf">
[#:pub]
</pre>

<div class="org-src-container">
<pre class="src src-bash">lk eval "[@:me:local]" | lk encode "@/#/b"
</pre>
</div>

<pre class="example" id="orgfa8cd70">
[@:me:local]
</pre>

</div>

<div class="py" id="org12a3a16">
<div class="org-src-container">
<pre class="src src-python">group = example_keypoint.group
print("The bare bytes:", group)

# encode as b64
b64 = lk_encode(group,"b")
print("b64 encoded   :", b64)

# Try to express as a [#:..], on failure try as [@:..], fallback to [b:...]
try_name = lk_encode(group,"#/@/b")
print("Or through lns:", try_name)

print("Pkt's pubkey  :",example_keypoint.pubkey)
try_keyname = lk_encode(example_keypoint.pubkey,"#/@/b")
print("Similarly lns :", try_keyname)


</pre>
</div>

<pre class="example" id="org76a3d85">
The bare bytes: b'D=\xe5\xb4\xe8^\x1b\x80\xab\x06\xea\xd42{g\x85\x9f\x0f\xb5\x9e\xb2\x01\x81\x7f\x0b[\xab(ft\x04\x1d'
b64 encoded   : [b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]
Or through lns: [#:pub]
Pkt's pubkey  : b"}-;\xe9DP\xafs\x1d9\xe6\\V['\x1c\x06\xa1\xbe5\x02\xd2\xe8:&amp;uL8\xb8\xbb\x87\x95"
Similarly lns : [@:me:local]
</pre>

</div>

</div>
</div>
</div>
</div>


<div id="outline-container-Query" class="outline-2">
<h2 id="Query">Query</h2>
<div class="outline-text-2" id="text-Query">
<p class="verse">
<a href="../cargo-doc/liblinkspace/query/index.html">Rust docs</a><br>
</p>

<p>
A query is a list of predicates and options used to select a set of packets.
They are used by the local index ( <a href="#lk_watch">lk_watch</a> and <a href="#lk_get">lk_get</a> ),
or to signal what packets should be found looked for in the group ( <a href="#lk_pull">lk_pull</a> ),
or as a filter function.
</p>
</div>

<div id="outline-container-lk_query" class="outline-3">
<h3 id="lk_query">lk_query</h3>
<div class="outline-text-3" id="text-lk_query">
<p>
Queries are newline separated.
Predicates are an <a href="#ABE">ABE</a> 3-tuple <code>field ':' test-operation ':' value</code> and constrain the set of accepted packets.
Options are context dependent and start with ':'
</p>

<pre class="example" id="org00c9eab">
group:=:[#:pub]
domain:=:example
data_size:&lt;=:[u16:256]
prefix:=:/hello/world
pubkey:=:[@local:me]
link_len:&gt;=:[u16:2]
link_len:&lt;=:[u16:8]

:mode:tree-asc
:follow
:watch:gethellos
</pre>

<p>
A predicate can be set multiple times.
They are designed such that you can concatenate two queries.
If the result can only ever be the empty set an error is returned.
</p>

<p>
There are only 4 basic test operations.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Basic Op</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&gt;</td>
<td class="org-left">greater eq</td>
</tr>

<tr>
<td class="org-left">&lt;</td>
<td class="org-left">less eq</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-left">all '0' in value are '0' in field</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">all '1' in value are '1' in field</td>
</tr>
</tbody>
</table>

<p>
The following are shorthand and resolve to one or more of the basic tests.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Derived Ops</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">=</td>
<td class="org-left">&gt;(val-1) and &lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">&gt;=</td>
<td class="org-left">&gt;(val-1)</td>
</tr>

<tr>
<td class="org-left">&lt;=</td>
<td class="org-left">&lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">*=</td>
<td class="org-left">Last n-bytes must eq val</td>
</tr>

<tr>
<td class="org-left">=*</td>
<td class="org-left">First n-bytes must eq val</td>
</tr>
</tbody>
</table>


<p>
The CLI has various aliases that can act as a guide in creating queries by using <code>print-query</code>.
</p>

<div class="ctabs" id="org125989c">
<div class="sh" id="org73b4269">
<p>

</p>

<p class="verse">
Many cli commands (e.g. <code>print-statemnt</code>, <code>watch</code> ) take as the first argument a <code>domain:group:path:(?depth)</code><br>
If no depth is set the path_len is constraint by default.<br>
Except for <code>watch-tree</code> which sets the depth to unconstrained by default<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">lk print-query "my:[#:pub]:/hello:*" --signed
</pre>
</div>

<pre class="example" id="org9d21114">
:mode:tree-desc
:watch:default
type:1:[b2:00000111]
domain:=:[a:my]
group:=:[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]
prefix:=:/hello
path_len:&lt;:[u8:3]
path_len:&gt;:[u8:0]
</pre>

</div>
<div class="py" id="org32a4b1f">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">q = lk_query()
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_query_parse" class="outline-3">
<h3 id="lk_query_parse">lk_query_parse</h3>
<div class="outline-text-3" id="text-lk_query_parse">
<p>
Add multiple constraints to a query. Returns an error if the resulting set is empty.
The full list of predicates and their byte size can be found <a href="#predicatelist">here</a>.
</p>

<div class="ctabs" id="orgcc8915d">
<div class="py" id="org5b9e7af">
<div class="org-src-container">
<pre class="src src-python"># parse runs eval and can take pkt and argv as argument.
stmt = """
group:=:[#:pub]
domain:=:example
path_len:&lt;:[u8:4]
data_size:&lt;:[0]
"""
lk_query_parse(q,stmt,argv=[int(10).to_bytes(2)])
lk_query_print(q,True) 
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_query_push" class="outline-3">
<h3 id="lk_query_push">lk_query_push</h3>
<div class="outline-text-3" id="text-lk_query_push">
<p>
Add a single statement to a query, with the last field in byte format.
</p>

<p>
Predicates are combined. Creating conflicts returns an error
</p>

<div class="ctabs" id="org3269d16">
<div class="py" id="org844dccd">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">q = lk_query()
lk_query_push(q,"data_size","&lt;",bytes([0,4])) # less than 4
lk_query_push(q,"data_size","&lt;",lk_eval("[u16:20]"))  # less than 20
lk_query_push(q,"data_size","&lt;",int(3).to_bytes(2))  # less than 3
lk_query_print(q)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Adding contradictions/defining an empty set, returns an error.</label><pre class="src src-python">try:
  r = lk_query_push(q,"data_size","&gt;",bytes([0,100])) #greater than 100
except Exception as e :
  r = ("That's not possible",e)
r

</pre>
</div>

<pre class="example" id="orga72e9c2">
type:1:[b2:00000001]
data_size:&gt;:[u16:100]
</pre>

</div>

</div>
</div>
</div>


<div id="outline-container-lk_query_print" class="outline-3">
<h3 id="lk_query_print">lk_query_print</h3>
<div class="outline-text-3" id="text-lk_query_print">
<p>
Print a query as text.
The query will have merged overlapping predicates
The last argument sets whether to create abe expressions or stick to ab-text without the expressions
</p>


<div class="ctabs" id="orgf0e54e4">
<div class="py" id="orgf5fdab1">
<p>

</p>


<div class="org-src-container">
<pre class="src src-python">lk_query_print(q,True)
</pre>
</div>

</div>

</div>


<p class="verse">
The <code>b2</code> function read a binary representation.<br>
The types are: datapoint=[b2:0000_0001], linkpoint [b2:0000_0011], keypoint [b2:0000_0111].<br>
Setting 'group', 'domain', 'path', 'links', or 'create' predicates automatically exclude the datapoint type.<br>
Setting pubkey or signature excludes link and data points.<br>
</p>
</div>
</div>



<div id="outline-container-org6e10dfc" class="outline-3">
<h3 id="org6e10dfc">More on predicates</h3>
<div class="outline-text-3" id="text-org6e10dfc">
<p class="verse">
<code>group</code> requires 32 bytes but will try to parse base64.<br>
<code>domain</code> requires 16 bytes but will prepend '\0' if too few bytes are given<br>
<code>path</code> and <code>prefix</code> only take the "\=" op, and take spath bytes. I.e. <code>path:=:[//hello/world]</code>, but will accept <code>/hello/world</code> as well<br>
</p>

<p>
Besides the fields in a point, predicates also apply to the hash and variable net header fields.
These fields are useful when writing an exchange processes.
</p>

<p>
The netheader fields can be mutated.
It is 32 bytes consisting of the following field. 
The netheader fields are :
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Prefix<sub>3</sub></td>
<td class="org-left">magic bytes 'LK1'</td>
</tr>

<tr>
<td class="org-left">NetFlags<sub>1</sub></td>
<td class="org-left">See source code</td>
</tr>

<tr>
<td class="org-left">hop<sub>2</sub></td>
<td class="org-left">number of hops since creation</td>
</tr>

<tr>
<td class="org-left">stamp<sub>8</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits0<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits1<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits2<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits3<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-predicatelist" class="outline-4">
<h4 id="predicatelist">Predicates &amp; options</h4>
<div class="outline-text-4" id="text-predicatelist">
<p>
The full list of options and predicates:
</p>

<div class="ctabs" id="orgd4aba91">
<div class="rs" id="org21b8e46">
<p>

</p>

<p>
Current set of <a href="../cargo-doc/liblinkspace/query/enum.PredicateType.html">predicates</a> and 
<a href="../cargo-doc/liblinkspace/query/enum.KnownOptions.html">options</a>.
</p>

<p>
Predicates must be known, unknown options are added but ignored.
An exchange process will for instance add a ':boomfilter' only it understands.
</p>

</div>

<div class="sh" id="org1630d2c">
<div class="org-src-container">
<pre class="src src-bash">lk print-query --help
</pre>
</div>

<pre class="example" id="orgc9628e8">
hash         - the point hash e.g. \[b:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\]
group        - group id e.g. \[#:pub\]
domain       - domain - if fewer than 16 bytes, prepadded with   e.g. \[a:example\]
prefix       - path prefix - only accepts '=' op e.g. /hello/world
path         - exact path - only accepts '=' op e.g. /hello/world
pubkey       - public key used to sign point e.g. \[@:me:local\]
create       - the create stamp e.g. \[now:-1H\]
path_len     - the total number of path components - max 8 e.g. \[u8:0\]
links_len    - the number of links in a packet e.g. \[u16:0\]
data_size    - the byte size of the data field e.g. \[u16:0\]
recv         - the recv time of a packet e.g. \[now:+1D\]
i_branch     - total packets per uniq (group,domain,path,key) - only applicable during local tree index, ignored otherwise e.g. \[u32:0\]
i_index      - total packets read from local index e.g. \[u32:0\]
i_new        - total newly received packets e.g. \[u32:0\]
i            - total matched packets e.g. \[u32:0\]
hop          - (mutable) number of hops e.g. \[u16:5\]
stamp        - (mutable) variable stamp e.g. \[now\]
ubits0       - (mutable) user defined bits e.g. \[u32:0\]
ubits1       - (mutable) user defined bits e.g. \[u32:0\]
ubits2       - (mutable) user defined bits e.g. \[u32:0\]
ubits3       - (mutable) user defined bits e.g. \[u32:0\]
type         - the field type bits - implied by other predicates e.g. \[b2:00000001\]
netflags     - (mutable) netflags e.g. \[b2:00000000\]
point_size   - exact point size - (netpkt_size - 32b header - 32b hash) e.g. \[u16:4\]

The following options are available

	:mode
	:watch
	:follow
	:notify-close


query - print full query from common aliases

Usage: lk print-query [OPTIONS] [DGPD] [-- &lt;EXPRS&gt;...]

Arguments:
  [DGPD]      
  [EXPRS]...  

Options:
  -p, --print-expr               print the query
      --print-text               print in ascii-byte-text format (ABE without '{..}' expressions)
      --id &lt;ID&gt;                  [default: default]
      --private                  enable io of linkpoints in [#:0] [env: PRIVATE_GROUP=]
      --mode &lt;MODE&gt;              [default: tree-desc]
  -b, --bare                     
      --index                    only match locally indexed pkts           | i_new:=:{u32:0}
      --new                      only match new unindexed pkts             | i_index:=:{u32:0}
      --max &lt;MAX&gt;                match upto max packets.                   | i:&lt;:{u32:max}
      --max-branch &lt;MAX_BRANCH&gt;  match upto max per (dm,grp,path,key) pkts | i:&lt;:{u32:max_branch}
      --max-index &lt;MAX_INDEX&gt;    match upto max from local index           | i_index:&lt;:{u32:max_index}
      --max-new &lt;MAX_NEW&gt;        match upto max unindexed pkts             | i_new:&lt;:{u32:max_new}
      --signed                   match only signed pkts                    | pubkey:&gt;:{@:none}
      --unsigned                 match only unsigned pkts                  | pubkey:=:{@:none}
      --watch                    Add :watch option
      --watch-id &lt;WATCH_ID&gt;      set :watch option id (implies --watch)
      --follow                   Add :follow option
      --ttl &lt;TTL&gt;                add recv:&lt;:{now:+..}
  -h, --help                     Print help
</pre>

</div>

</div>
</div>
</div>
</div>
</div>


<div id="outline-container-Linkspace" class="outline-2">
<h2 id="Linkspace">Linkspace</h2>
<div class="outline-text-2" id="text-Linkspace">
<p class="verse">
<a href="../cargo-doc/liblinkspace/linkspace/index.html">Rust docs</a><br>
</p>


<p>
The linkspace is a local log and index that one or more processes connect to.
It is the place you save and retrieve data from.
Either by read or watch.
The latter lets you callback for each currently known and future packet matching a specific set of predicates.
</p>

<p>
Essentially every thread has a read transaction to the database.
This transaction is updated to reflect the latest state through <a href="#lk_process">lk_process</a> and <a href="#lk_process_while">lk_process_while</a>.
You can read one packet with <a href="#lk_get">lk_get</a>, multiple from disk with <a href="#lk_get_all">lk_get_all</a>, or current and future packet with <a href="#lk_watch">lk_watch</a>.
</p>
</div>

<div id="outline-container-lk_open" class="outline-3">
<h3 id="lk_open">lk_open</h3>
<div class="outline-text-3" id="text-lk_open">
</div>
</div>

<div id="outline-container-lk_save" class="outline-3">
<h3 id="lk_save">lk_save</h3>
<div class="outline-text-3" id="text-lk_save">
</div>
</div>

<div id="outline-container-lk_get" class="outline-3">
<h3 id="lk_get">lk_get</h3>
<div class="outline-text-3" id="text-lk_get">
</div>
</div>
<div id="outline-container-lk_get_all" class="outline-3">
<h3 id="lk_get_all">lk_get_all</h3>
<div class="outline-text-3" id="text-lk_get_all">
</div>
</div>


<div id="outline-container-lk_watch" class="outline-3">
<h3 id="lk_watch">lk_watch</h3>
<div class="outline-text-3" id="text-lk_watch">
</div>
</div>


<div id="outline-container-lk_process" class="outline-3">
<h3 id="lk_process">lk_process</h3>
<div class="outline-text-3" id="text-lk_process">
</div>
</div>

<div id="outline-container-lk_process_while" class="outline-3">
<h3 id="lk_process_while">lk_process_while</h3>
<div class="outline-text-3" id="text-lk_process_while">
</div>
</div>


<div id="outline-container-lk_close_watch" class="outline-3">
<h3 id="lk_close_watch">lk_close_watch</h3>
<div class="outline-text-3" id="text-lk_close_watch">
</div>
</div>
</div>


<div id="outline-container-Conventions" class="outline-2">
<h2 id="Conventions">Conventions</h2>
<div class="outline-text-2" id="text-Conventions">
<p class="verse">
<a href="../cargo-doc/liblinkspace/conventions/index.html">Rust docs</a><br>
</p>

<p>
Conventions are functions built on top of the other linkspace functions.
They provide interop for processes by encoding data into linkspace packets.
</p>

<p>
Generally they require the caller to also run <a href="#lk_process">lk_process</a> or <a href="#lk_process_while">lk_process_while</a>
</p>

<p>
One general conventions is that domains and paths starting with \xff are for meta stuff, such as status queries and packet exchange.
</p>
</div>

<div id="outline-container-lk_status_set" class="outline-3">
<h3 id="lk_status_set">lk_status_set</h3>
<div class="outline-text-3" id="text-lk_status_set">
<p>
Status queries allow us to communicate if a process exists that is handling a specific type and a specific instance.
</p>

<p>
The function signature is (<code>domain</code>, <code>group</code>, <code>obj_type</code>, <code>instance</code>).
</p>

<ul class="org-ul">
<li>A request is a packet in the form DOMAIN:[#:0]:/\fstatus/GROUP/type(/instance?) and has no data and no links.</li>
<li>A reply is of the form DOMAIN:[#:0]/\status/GROUP/type/instance with some data and at least one link.</li>
</ul>

<p>
Note that the packets are in `#:0`.
This function is only for local status updates.
</p>

<p>
The group argument does not ask inside GROUP, it only signals which group the query is about.
Other processes are meant to answer a request.
</p>

<p>
The following are statuses that the exchange process should set:
</p>

<ul class="org-ul">
<li>exchange GROUP process</li>
<li>exchange GROUP connection PUBKEY</li>
<li>exchange GROUP pull PULL PULL_HASH</li>
</ul>
</div>
</div>

<div id="outline-container-lk_status_poll" class="outline-3">
<h3 id="lk_status_poll">lk_status_poll</h3>
<div class="outline-text-3" id="text-lk_status_poll">
<p>
Request the status of a `domain group obj_type ?instance timeout`.
</p>
</div>
</div>


<div id="outline-container-lk_pull" class="outline-3">
<h3 id="lk_pull">lk_pull</h3>
<div class="outline-text-3" id="text-lk_pull">
<p>
A pull request is made by a domain application and signals the set of packets it wants.
The function takes the query and saves it as: 
<code>[f:exchange]:[#:0]:/pull/[query.group]/[query.domain]/[query.watch]</code>
</p>

<p class="verse">
Note that from a domain's perspective, there is no such thing as 'fully synchronized'.<br>
The most straight forwards way to emulate such a thing is to create 'log' packets that link to<br>
known packets from a single device's perspective.<br>
</p>

<p>
Pull queries must have the predicates 'domain:=:..' and 'group:=:..', and ':watch'
</p>

<p>
An exchange process (such as <a href="#anyhost">anyhost</a>) watches these packets and attempts to fulfill it.
The exchange is only responsible for pull requests received when it is running.
The exchange can drop requests when you reuse the 'watch'.
The function returns the hash of the request.
</p>

<p>
A domain application should be conservative with its query.
Requesting too much can add overhead.
</p>
</div>
</div>

<div id="outline-container-lk_key" class="outline-3">
<h3 id="lk_key">lk_key</h3>
<div class="outline-text-3" id="text-lk_key">
<p>
Read ( or creates ) an encrypted private key from lns:[#:0]:/local/NAME.
Also writes into the local LNS lookup table such that the public key can be requested with <code>[@:NAME:local]</code>
</p>
</div>
</div>
</div>

<div id="outline-container-lns" class="outline-2">
<h2 id="lns">LNS</h2>
<div class="outline-text-2" id="text-lns">
<p>
See <a href="../../lns.html">LNS</a> for some general information.
See <a href="#ABELNS">abe#lns</a> for how to use LNS for lookup and reverse lookup.
</p>

<p>
The LNS system works by making a claim in <code>lns:[#:pub]:/claim/test/example/john</code> which we'll call <code>$Claim1</code>
A claim can have 3 types of special links.
The first link with the tag pubkey@ has as ptr the <code>pubkey</code> bytes to use when referring to <code>@:john:example:test</code>.
The first link with the tag group# has as ptr the <code>group</code> bytes to use when referring to <code>#:john:example:test</code>.
Every tag ending with '<code>^</code>' e.g. <code>root_00^</code> is an authority public key.
An authority has the right to vote for all subclaims. For example the claim <code>lns:[#:pub]:/claim/test/example/john/home/</code>
</p>

<p>
<code>$Claim1</code> becomes 'live' when a single authority of <code>claim/test/example</code> creates a vote by creating a keypoint <code>lns:[#:pub]:/claim/test/example/john</code> with
the link <code>vote:$Claim1.hash</code>. The first claim to get a majority of votes wins.
</p>
</div>
</div>



<div id="outline-container-qa" class="outline-2">
<h2 id="qa">Q&amp;A</h2>
<div class="outline-text-2" id="text-qa">
</div>


<div id="outline-container-orgc8eb964" class="outline-5">
<h5 id="orgc8eb964">Why Big Endian?</h5>
<div class="outline-text-5" id="text-orgc8eb964">
<p>
The tree index is in the expected order when using the numbers as path components.
E.g. <code>lk linkpoint ::/some/dir/[now]</code> will come after <code>lk linkpoint ::/some/dir/[now:-1D]</code> because <code>now &gt; (now - one day)</code>
</p>
</div>
</div>

<div id="outline-container-org48c6679" class="outline-5">
<h5 id="org48c6679">Every user of my domain app needs X from my server/I want to add advertisements to my domain app.</h5>
<div class="outline-text-5" id="text-org48c6679">
<p>
Hardcode a public key into the app and publish a group exchange service.
There are two primary ways to centralize things with this public key.
Either everybody connects over a single group, or you can exchange over the group: their-key XOR your-key group.
</p>
</div>
</div>

<div id="outline-container-org19a5078" class="outline-5">
<h5 id="org19a5078">I'm not in control of the user! / Anybody in my group can leak data from it!?</h5>
<div class="outline-text-5" id="text-org19a5078">
<p>
I don't make the rules, I just make them obvious.
</p>
</div>
</div>

<div id="outline-container-orgb67f0c4" class="outline-5">
<h5 id="orgb67f0c4">A domain application can write outside its own domain space.</h5>
<div class="outline-text-5" id="text-orgb67f0c4">
<p>
Yes, the current API has no restriction.
Maybe at some point we can effectively restrict processes through wasm or some other access control.
It will take some time before we reached that point.
</p>
</div>
</div>

<div id="outline-container-org364dcdc" class="outline-5">
<h5 id="org364dcdc">Why not use an SQL backend? / Why invent queries?</h5>
<div class="outline-text-5" id="text-org364dcdc">
<p>
That is a complex question.
First off, if you desire to run SQL queries it is relatively straight forward to stream packets into a SQL table and query them.
</p>

<p>
But SQL isn't magic, and its non-trivial price to pay for something that is not a great fit for a few fundamental problems including:
</p>
<ol class="org-ol">
<li>What are the tables peers should have?</li>
<li>How to constrain a query as it travels across a group?</li>
</ol>

<p>
Both can be solved in a number of ways, but most solutions are quickly going to bloat.
I've tried.
</p>

<p>
Queries have a few desirable properties.
You can do a form of algebra on them with concatenation and equality.
They handle arbitrary bytes.
They're declarative enough for where they're used.
</p>
</div>
</div>

<div id="outline-container-org3c38b29" class="outline-5">
<h5 id="org3c38b29">Will it handle spam?</h5>
<div class="outline-text-5" id="text-org3c38b29">
<p>
You can require proof of work or a proof of association.
POW is as simple as adding a predicate on the hash.
AI generated spam only makes this association more important than it is now, and the linkspace protocol can help there.
Will it solve it entirely? Never.
But existing tools to combat spam are no more or less effective.
Instead, we have an additional tool to do better.
</p>
</div>
</div>
</div>

<div id="outline-container-linkmail" class="outline-2">
<h2 id="linkmail">Example Domain App - linkmail</h2>
<div class="outline-text-2" id="text-linkmail">
<div class="ctabs" id="org4dad17d">
<div class="info" id="orge2db49b">
<p>

</p>

<p class="verse">
Available in the <a href="https://antonsol919.github.io/linkspace/download.html">pkg</a> or in repository/examples/app<br>
</p>
<p>
linkmail is a app to write messages in a group.
Note that it will complain if you have not also started an exchange process for the group.
</p>

</div>

<div class="py" id="orgae7d3d7">
<div class="org-src-container">
<pre class="src src-python">#!/bin/env python3.11
import os,sys,logging,tempfile,subprocess,shlex,functools,cmd,argparse,getpass
from lkpy import *
from pathlib import Path

#logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
parser = argparse.ArgumentParser(description='Linkmail')
parser.add_argument('--linkspace', dest='linkspace', type=str,
                    default="",help='use linkspace (default: $HOME/linkspace)')
parser.add_argument('--group', dest='group', type=str,
                    default=os.environ.get('GROUP'),help='group (default: [#:pub])')
parser.add_argument('--key', dest='key', type=str,
                    default=os.environ.get('LK_KEY'),help='use key (default: [me:local])')
args = parser.parse_args()

lk = lk_open(path=args.linkspace,create=True)
print(lk_info(lk).path)

keyname ="me:local"
password=""
group_name = args.group
group=lk_eval(group_name)
common_q = lk_query_parse(lk_query(),"domain:=:linkmail","group:=:"+group_name)
try:
    print("Using key:",lk_eval2str(f"[@:{keyname}/?b]"))
except:
    print(keyname , " not found - we'll try creating it")
passw = getpass.getpass(prompt='Password&gt; ', stream=None)
print("Unlocking key");
key = lk_key(lk,password=lk_eval(passw),name=keyname,create=True)
lk_process(lk) # required for lk_encode
keyname = lk_encode(key.pubkey,"@/b") # ensure we use the preferred name for this key
print(f"Key ok: ",keyname);

lk_keypoint = functools.partial(lk_keypoint,key=key,domain=b"linkmail",group=group)
lk_linkpoint = functools.partial(lk_linkpoint,domain=b"linkmail",group=group)



def tag_str(t):
    """strip nulls from 16 byte value and escape"""
    return lk_eval2str("[0/?a0]",argv=[t])

def links_str(links=[]):
    return "\n".join([tag_str(l.tag) + " " + lk_encode(l.ptr,"#/@/b") for l in links])

first_mail = "Hello world!"
def user_write_mail(links = [],notes = "") -&gt; tuple[str,list[Link],str]:
    global first_mail
    editor = os.environ.get('VISUAL', os.environ.get('EDITOR', 'vi'))
    with tempfile.NamedTemporaryFile(mode='w+b', delete=False) as tf:
        tf.write(f"{first_mail}\n==LINKS==\n".encode())
        tf.write(links_str(links).encode())
        if notes:
            tf.write(f"\n==NOTES==\n{notes}".encode())
        tf.flush()
        # will not work on windows - must first close file
        tmp_file = tf.name
        process = subprocess.Popen(shlex.split(f"{editor} \"{tmp_file}\""))
        process.wait()
        first_mail = ""
    mail,*rest = Path(tmp_file).read_text("utf-8").split("\n==LINKS==\n",1)
    if not rest:
        return (mail,[],"")
    links,*notes = rest[0].split("\n==NOTES==\n",1)
    def read_link(line):
        print(line)
        [tag,link] = line.split(maxsplit=1)
        return Link(lk_eval(f"[a:{tag}]"),lk_eval(link))
    links = [read_link(line) for line in links.splitlines() if line]
    return (mail,links,notes[0] if notes else "")

def get_exchange_status(watch_finish=False):
    status =[] 
    lk_status_poll(lk,
               lambda pkt: status.append(pkt) ,
               timeout=lk_eval("[s:+2s]"),
               domain=b"exchange",
               group=group,
               objtype=b"process",watch_id=b"status")
    ok = lk_process_while(lk,watch=b"status",watch_finish=watch_finish)
    return status

intro = """
linkmail - A simple linkspace mail system
Use 'new' to write a new linkmail.
Use 'list [subj] [limit]' to print a list of linkmail.
Use 'pull [subj]' to request mail from the group.
Use 'queue' to print a list of recently received linkmail
Use 'open [N]' to open a linkmail

Every time a list is displayed with a number you can:
- 'open &lt;N&gt;' to open it
- 'link &lt;N&gt; [tag]' to save it for use during 'new'
"""


list_template  = "[/or:[/?:[pubkey]/@]:\\[[pubkey/2mini]\\]]:[path:str] = [data/slice::20/rpad:20: ] [create/s:delta/rfixed:18: ]:[hash/2mini] # [links_len:str]([:[/links:[tag:str] [ptr/2mini],]/~rcut:32])"
class Linkmail(cmd.Cmd):
    intro =intro
    prompt = "&gt; "

    links : list[Link] = []
    notes = "Add notes here"

    lst : list[Pkt] = []
    queue_in : list[Pkt] = []
    # last from lst, or last 'open'
    last_shown : Pkt = lk_linkpoint(data="Nothing here so far",create=int(0).to_bytes(8))

    def precmd(self,line):
        lk_process(lk)
        return line

    def postcmd(self,stop,_line):
        if self.queue_in:
            print("New messages (use 'queue')")
        return stop

    def print_entry(self,pkt:Pkt,prnt=True,tag="") -&gt; int:
        i = len(self.lst)
        self.lst.append(pkt)
        self.last_shown = pkt;
        if prnt:
            print(i,tag,lk_eval2str(list_template,pkt))
        return i

    def print_list(self,lst:list[Pkt]):
        self.lst.clear()
        for p in lst:
            self.print_entry(p)

    def do_queue(self,_):
        """List the packets received since the last call to queue (or starting this proc)"""
        self.print_list(self.queue_in)
        self.queue_in.clear()

    def do_status(self,_):
        ex_status = get_exchange_status(True)
        if not ex_status:
            print(f"No exchange running for {group_name} - pull requests will be ignored")
        for e in ex_status:
            print(lk_eval2str("([hash/2mini]) [comp2]/[comp3]\\n[data]\\n",e))

    def do_pull(self,path = "",):
        """Notify the exchange process to start pulling messages (from [path])"""
        if not get_exchange_status():
            print(f"No exchange running for {group_name} - pull requests will be ignored")
            return
        q = lk_query(common_q)
        path_b = lk_eval(f"[/~/mail/{path}]")
        # we use the path in binary form. Two strings might differ but eval to the same bytes
        q = lk_query_push(q,"","watch",path_b) 

        q = lk_query_push(q,"path","=",path_b)
        q = lk_query_push(q,"","follow",b"")
        lk_pull(lk,q)

    def do_new(self,path):
        """write a new mail"""
        path,*rest =  shlex.split(path or "/")
        path_b = lk_eval(f"[/~/mail/{path}]")
        (data,links,notes) = user_write_mail(self.links,self.notes)
        self.notes = notes
        pkt = lk_keypoint(data=data,links=links,path=path_b)
        self.last_shown = pkt
        print(str(pkt))
        if (input("Ok[Y/n]?") or "Y") in "Yy":
            if not get_exchange_status():
                if not ( input(f"No exchange running for {group_name} - Write anyways? [Y/n]") or "Y" in "Yy" ):
                    return
            lk_save(lk,pkt)
            self.links=[]

    def do_threads(self,path):
        """List all threads"""
        path,*rest =  shlex.split(path or "/")
        q = lk_query(common_q)
        q = lk_query_parse(q,f"prefix:=:[/~/mail/{path}]","i_branch:=:[u32:0]",*rest)
        logging.debug(q)
        lst = []
        lk_get_all(lk,q,lambda pkt: lst.append(pkt))
        self.print_list(lst)

    def do_list(self,path):
        """list all messages [path] [limit] - e.g. list / recv:&gt;:[now:-1D] pubkey:=:[@:alice:nl] create:&gt;:[-2D]"""
        path,*rest =  shlex.split(path or "/")
        q = lk_query(common_q)
        q = lk_query_parse(q,f"path:=:[/~/mail/{path}]",*rest)
        logging.debug(q)
        lst = []
        lk_get_all(lk,q,lambda pkt: lst.append(pkt))
        self.print_list(lst)

    def do_open(self,idx):
        pkt = self.lst[int(idx)] if idx else self.last_shown
        self.last_shown = pkt
        print_template= "==[hash:str]==\\n[/~?:[pubkey]/@/b]\\n[path:str]\\n[create/s:str]\\n[data:str]\\n"
        print(lk_eval2str(print_template,pkt))
        self.lst.clear()
        for link in pkt.links:
            pkt = lk_get(lk,lk_hash_query(link.ptr))
            if not pkt:
                print("\t",tag_str(link.tag), " ", lk_encode(link.ptr,"#/@/b"))
            else:
                print(len(self.lst),"\t",tag_str(link.tag), " ", b64(link.ptr,mini=True),lk_eval2str(list_template,pkt))
                self.lst.append(pkt)

    def do_link(self,arg):
        """save a link used in the next mail"""
        if arg == "clear":
            self.links = []
            return
        select,*rest =  shlex.split(arg or "shown")
        link = self.last_shown.hash if select =="shown" else self.lst[int(select[0])].hash
        tag = rest[0] if rest else "link"
        self.links.append(Link(tag,link))
        print("Current Links")
        print(links_str(self.links))

    def do_EOF(self, _):
        return True

    def new_mail_pkt(self,pkt):
        if pkt.pubkey != key.pubkey:
            self.queue_in.append(pkt)


dloop = Linkmail()

new_mail = lk_query_parse(lk_query(common_q),":watch:incoming","prefix:=:/mail","i_index:&lt;:[u32:0]")
logging.debug("new_mail",str(new_mail))
lk_watch(lk,new_mail,lambda p: dloop.new_mail_pkt(p))

dloop.do_pull("")

while True:
    try:
        dloop.cmdloop()
    except Exception as e:
        logging.warn(e, exc_info=True)
</pre>
</div>

</div>

</div>
</div>
</div>



<div id="outline-container-imageboard" class="outline-2">
<h2 id="imageboard">Example Domain App - Imageboard</h2>
<div class="outline-text-2" id="text-imageboard">
<div class="ctabs" id="org267f94d">
<div class="info" id="org56d8965">
<p>

</p>

<p class="verse">
Available in the <a href="https://antonsol919.github.io/linkspace/download.html">pkg</a> or in repository/examples/app<br>
</p>

<p>
This is a basic domain application example.
Should you build applications in bash? Fuck no.
</p>

<p>
The purpose of the app will be to create an image collage with multiple people.
</p>

<p>
The data structure is as follows:
</p>

<p>
Adding an image is done by creating a linkpoint where the first path component indicates the name of the image.
The tag of the link is a decimal encoded [X, Y] coordinates.
Its ptr is a datapoint packet hash.
Building the collage is done by adding all images to a base image in 'create' order.
</p>

</div>

<div class="sh" id="orga7bef8f">
<p>

</p>

<ul class="org-ul">
<li>placing images</li>
</ul>

<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -xeuo pipefail
if [ $# -lt 4 ]; then
    echo "Usage: img_file board_name X Y"
    exit 2
fi

IMG_FILE=$1; BOARD=$2; X=$3; Y=$4;
shift 4

IMG_HASH=$(\
    cat "$IMG_FILE" \
        | lk data --write db --write stdout \
        | lk printf "[hash:str]")
TAG=$(printf "%08d%08d" "$X" "$Y")

lk link "imageboard:$GROUP:/$BOARD" \
   -l "$TAG":"$IMG_HASH" "$@" \
   --write db --write stdout \
    | lk printf
</pre>
</div>

<ul class="org-ul">
<li>viewing images</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail
BOARD=${1?Usage: board_name [start_stamp] }
if [[ ! -f $BOARD.png ]]; then
    magick convert -size 1000x1000 xc:transparent PNG32:$BOARD.png # Create empty canvas
fi
START_STAMP=${2:-"0"} # If no stamp is given we begin at 0, i.e. unix epoch in microseconds

# We select everything with a create field greater or equal to $START_STAMP
lk watch --index "imageboard:$GROUP:/$BOARD" -- "create:&gt;=:[u64:$START_STAMP]" \
    | lk printf "[/links:[tag:str] [ptr:str]]" \
    | while read REF; do
        X=${REF:0:8}
        Y=${REF:8:8}
        IMG_HASH=${REF: -43}
        echo "Placing $IMG_HASH at $X , $Y"
        lk watch-hash $IMG_HASH --ttl 5s \
            | lk printf "[data]" --delimiter "" \
            | magick composite -geometry +$X+$Y - PNG32:$BOARD.png PNG32:$BOARD.png
    done
echo "$BOARD: $START_STAMP"
</pre>
</div>

<ul class="org-ul">
<li>streaming images</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash -x 
set -euo pipefail
BINS="$(dirname "${BASH_SOURCE[0]}")"
GROUP=${GROUP:-"[#:pub]"}
BOARD=${1?Usage: board_name [start_stamp] }
magick convert -size 1000x1000 xc:transparent PNG32:$BOARD.png

# not strictly necessary, but otherwise pull does nothing
lk poll-status exchange $GROUP process --write "stdout-expr:exchange - [data]"  || echo "No exchange process active"

echo Pulling $GROUP $BOARD
lk pull "imageboard:$GROUP:/$BOARD" --follow -- "create:&gt;:[now:-1D]" 

$BINS/imageboard.view.sh $BOARD 0 # run once

#On receiving a new packet of interest we repaint the board from that stamp
lk watch --new "imageboard:$GROUP:/$BOARD" | \
    lk printf "[create:str]" | \
    while read STAMP; do
        $BINS/imageboard.view.sh $BOARD $STAMP
    done
</pre>
</div>

</div>


<div class="py" id="orgd492e9d">
<p>
This is a straight-up copy of the bash script.
It works, but it could be done better by having only a single python instance running.
</p>
<ul class="org-ul">
<li>placing images</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/env python3
from lkpy import *
import sys
if len(sys.argv) &lt; 5:
    sys.exit('Usage: imagefile boardname x y')
[imagefile,boardname,x,y] = sys.argv[1:]
x = int(x)
y = int(y)
if x &gt; 1000 or y &gt; 1000:
    sys.exit('X and Y coordinates should be &lt; 1000')

imgdata = open(imagefile,'rb').read()
# this will error if the file is to large ( 2^16 - 512) 
datap = lk_datapoint(imgdata)
# we can access the point's fields as bytes such as datap.hash, turn those into b64
# print("Saving image ",base64(datap.hash))
# Alternatively we can use lk_eval/lk_eval2str and use an abe expr
print(lk_eval2str("Using image [hash:str]",datap))


# We make up this scheme for our app
# Tags will be decimal encoded, ptr will point to image data. 
tag = f"{x:08d}{y:08d}".encode() # Everything in linkspace is plain bytes
links = [Link(tag,datap.hash)]
linkp = lk_linkpoint(domain=b"imageboard",
                     group=PUBLIC, # default
                     path=[boardname.encode()],
                     links=links)
# print(lk_eval2str("Placing new image [pkt]",linkp))

# instance looks for 'path' arg | $LINKSPACE env | $HOME/linkspace
lk = lk_open(create=True) 

# write the point to the linkspace instance
_isnew = lk_save(lk,datap)
lk_save(lk,linkp)
</pre>
</div>

<ul class="org-ul">
<li>viewing images</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/env python3.11
from lkpy import *
import os
import sys
if len(sys.argv) &lt; 2:
    sys.exit('Usage: boardname ?stamp')

boardfile = sys.argv[1] + ".png"
boardname = sys.argv[1]
create_stamp = int(sys.argv[2]) if len(sys.argv) &gt; 2 else 0

if not os.path.exists(boardfile):
    os.system(f"magick convert -size 1000x1000 xc:transparent PNG32:{boardfile}")

lk = lk_open(create=True)

# You can parse multiple statements as abe.
# The usual ABE context is available, and you can extend it with argv
query_string = """
group:=:[#:pub]
domain:=:imageboard
path:=:/[0]
create:&gt;=:[1/u64]
"""
query = lk_query_parse(lk_query(),query_string,argv=[boardname,str(create_stamp)])
# or use templates. if you're just interested in the string
query = lk_query_parse(query,f"create:&gt;=:[:{str(create_stamp)}/u64]")

# Or if you have the exact bytes
create_b = create_stamp.to_bytes(8,byteorder='big')
query = lk_query_parse(query,f"create:&gt;=:[0]",argv=[create_b])
# Or if you're only adding a single statement
query = lk_query_push(query,"create","&gt;=",create_b)

# The query merges overlapping predicates, and errors on conflicting predicates

# Query parsing is somewhat forgiving in that it allows Group, Domain, and Path two syntax's
# Group can take the b64 no-pad string
# Domain is 16 bytes but does not have to prepend '\0'
# Path takes either a '/' delimited expression, or the 'spath' bytes ( as given by the spath function or pkt.spath value )
# The other values require the exact number of bytes, in big endian when a number.

# Its worth understanding why these two work. Checkout the guide
create_abe = f"[u64:{str(create_stamp)}]"
assert create_b  == lk_eval(create_abe)
assert lk_encode(create_b,"u64") == create_abe

# we'll collect our entries in here 
image_data = []
def update_image(pkt):
    create = pkt.create # all the links in the packet will have this as their z-index
    for link in pkt.links:
        x = int(str(link.tag[:8],'ascii'))
        y = int(str(link.tag[8:],'ascii'))
        q = lk_hash_query(link.ptr) # shorthand for :mode:hash-asc i:=:[u32:0] hash:=:HASH
        q = lk_query_push(q,"recv","&lt;",lk_eval("[now:+3s]"))

        # we need a uniq id to register this query under.
        wid = bytearray(pkt.hash)
        wid.extend(link.ptr)
        q = lk_query_push(q,"","watch",bytes(wid))

        # print("Looking for ",lk_query_print(q,True))
        # we could get with 'lk_get(lk,q)' but to give new packets a chance to arrive we've set recv &lt; now+3s so we will watch them.
        lk_watch(lk,q,lambda data_pkt : image_data.append([create,x,y,data_pkt,pkt]))

# we only care about the ones we know right now. 
lk_get_all(lk,query, update_image)

# Because we set a timeout ( recv&lt;now+5s ) for all data packets ( in case we're still receiving them )
# we can simply wait until all callbacks are done or dropped.
lk_process_while(lk)

image_data.sort()

import pathlib
pathlib.Path("./fragments").mkdir(parents=True, exist_ok=True)

for [_,x,y,datap,parent] in image_data:
    filename = lk_eval2str("./fragments/[hash:str]",datap)
    try:
        with open(filename, "bx") as f:
            f.write(datap.data)
            f.flush()
            f.close()
    except Exception as e:
        pass
    print(f"placing at {x},{y} the image {filename}")
    os.system(f"magick composite -geometry +{x}+{y} {filename} PNG32:{boardfile} PNG32:{boardfile}")
</pre>
</div>

<ul class="org-ul">
<li>streaming images</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/env python3
from lkpy import *
import os
import sys
if len(sys.argv) &lt; 2:
    sys.exit('Usage: boardname ?stamp')

boardname = sys.argv[1]
create_stamp = int(sys.argv[2]) if len(sys.argv) &gt; 2 else 0


lk = lk_open(create=True)
status = []
lk_status_poll(lk,
               lambda pkt: status.append(pkt) or False, # we're only interested in any reply. (We could check the data for OK)
               timeout=lk_eval("[s:+10s]"),
               domain=b"exchange",
               group=PUBLIC,
               objtype=b"process")
lk_process_while(lk)

if len(status) == 0:
    sys.exit("No exchange process active?") # not strictly necessary, but otherwise pull does nothing
else:
    print("Exchange status: ");
    print(str(status[0].data,'utf8'))


query_string = """
group:=:[#:pub]
domain:=:imageboard
path:=:/[0]
create:&gt;=:[now:-1D]
:watch:[0]
"""
query = lk_query_parse(lk_query(),query_string,argv=[boardname])

#We signal the exchange process to gather the data
lk_pull(lk,query)

#we just wait for every packet and redraw the painting starting at the 'create' stamp
script_dir = os.path.dirname(os.path.realpath(__file__))
os.system(f"{script_dir}/imageboard.view.py {boardname} 0")

def update_img(pkt):
    create = lk_eval2str("[create:str]",pkt)
    os.system(f"{script_dir}/imageboard.view.py {boardname} {create}")

query = lk_query_parse(query,"i_index:&lt;:[u32:0]") # we only care for new stuff
lk_watch(lk,query, update_img)
lk_process_while(lk)
</pre>
</div>

</div>

</div>
</div>
</div>

<div id="outline-container-anyhost" class="outline-2">
<h2 id="anyhost">Example Group Exchange - Anyhost</h2>
<div class="outline-text-2" id="text-anyhost">
<p class="verse">
Available in the <a href="https://antonsol919.github.io/linkspace/download.html">pkg</a> or in repository/examples/exchange<br>
</p>

<div class="ctabs" id="orgb2c47da">
<div class="info" id="orgd8e1bf1">
<p class="verse">
Available in the repo/examples/exchange<br>
See repo/dev/exchange.md for some open design issues/notes.<br>
</p>

<p>
This is a rather dumb client &amp; host.
It simply forwards requests.
It does no pruning before sending or receiving.
</p>

</div>
<div class="sh" id="orga1e16a6">
<p>

</p>

<ul class="org-ul">
<li>anyhost client</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail
cd "$(dirname "$0")"
lk key 
export SERVER=${SERVER:-${1:-"127.0.0.1:5020"}}
export GROUP_ORIG=$GROUP
export GROUP=$(lk eval "[:$GROUP/?b]")

socat /dev/null tcp:$SERVER
# We could check if the server is responding first, but if we do we're on the clock during the handshake.
# so instead we save the password here
export LINKSPACE_PASS=$(lk key --no-pubkey --no-enckey --display-pass)

echo Connecting $GROUP $SERVER
socat tcp:$SERVER,keepalive exec:"handshake.sh connect client_io.sh",fdout=4
#websocat -E --binary ws://$SERVER sh-c:"handshake.sh connect client_io.sh"
</pre>
</div>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# parent should set out to fd4. otherwise add a exec 4&gt;&amp;1 1&gt;&amp;2
set -euo pipefail
function fin (){
    kill -9 -- -$$ $(jobs -p) 2&gt;/dev/null || true
    echo Disconnected - $THEIR_KEY 
}
trap "fin" EXIT

cd $SESSION
echo SESSION=$SESSION
echo THEIR_KEY=$THEIR_KEY
echo GROUP=$GROUP
GROUP="[b:$GROUP]"
THEIR_KEY="[b:$THEIR_KEY]"

lk link --create [u64:0] ":[#:0]:/rxlog/$THEIR_KEY" --write db
lk link --create [u64:0] ":[#:0]:/txlog/$THEIR_KEY" --write db
LAST_RX=$(lk --private watch --max 1 ":[#:0]:/rxlog/$THEIR_KEY" | lk printf [create:str])
LAST_TX=$(lk --private watch --max 1 ":[#:0]:/txlog/$THEIR_KEY" | lk printf [create:str])
lk eval "last rx [u64:$LAST_RX/s:str]\nlast tx [u64:$LAST_TX/s:str]\n"

lk set-status exchange $GROUP process anyhost-client --data "abe:OK\nPID:$$\nSESSION:$SESSION" &amp;

export LINKSPACE_NO_CHECK=true

# save reads from stdin, ie. the server 
LINKSPACE_NO_CHECK=false lk save --new db --new stdout \
    | lk printf --inspect "RX [domain:str] [path:str] [hash:str]" \
    | lk --private collect ":[#:0]:/rxlog/$THEIR_KEY" \
              --min-interval 1m \
              --forward null \
              --write db &amp;

# read the pull request made by other apps and place them into the group
lk --private watch --new "[f:exchange]:[#:0]:/pull/$GROUP:**" \
    | lk --private rewrite \
                --password "" \
                --group $GROUP \
                --write db --write stdout sign-all \
    | lk p  "&gt;&gt;&gt;&gt;new request [hash:str]\n[data]\n&lt;&lt;&lt;&lt;" &amp;


# This group exchange requires us to send all the data to the server
lk watch --bare --mode log-asc -- "group:=:$GROUP" "hop:=:[u32:0]" "recv:&gt;:[u64:$LAST_TX]" \
    | lk get-links \
    | lk dedup \
    | lk printf --inspect "[now:str] SENDING [hash:str]" \
    | tee --output-error=exit &gt;( cat &gt;&amp;4 ) \
    | lk --private collect ":[#:0]:/txlog/$THEIR_KEY" \
         --min-interval 1m \
         --forward null \
         --write db &amp;

echo PIDS $(jobs -p)
wait -n
</pre>
</div>

<ul class="org-ul">
<li>handshake</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail
if [[ ${SOCAT_PEERADDR+x} ]]
   then
    export THEIR_ADDR=$SOCAT_PEERADDR:$SOCAT_PEERPORT
else
    # websocat
    export THEIR_ADDR=${WEBSOCAT_CLIENT:-$SERVER}
fi
export SESSION=$(mktemp -dt $THEIR_ADDR.XXXXX)

MODE=${1:-serve}
lk handshake --max-diff-secs 6000 --password "$LINKSPACE_PASS" \
          --write stdout --write file:$SESSION/handshake.out \
          --forward file:$SESSION/handshake.in \
          $MODE &gt;&amp;4

export THEIR_KEY=$(cat $SESSION/handshake.in | lk filter --bare --signed --max-new 1 | lk printf "[pubkey:str]")
echo Connected $THEIR_ADDR - Their Key : $THEIR_KEY 1&gt;&amp;2 
exec ${@:2} 
</pre>
</div>

<ul class="org-ul">
<li>anyhost server</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail

export PORT=${PORT:-"5020"}
echo My Key $(lk key --password "")
export GROUP=$(lk eval "[:$GROUP/?b]")
echo Serving $GROUP $PORT 
export LINKSPACE_PASS=$(lk key --no-pubkey --no-enckey --display-pass)

function fin (){
    kill -9 -- -$$
    kill -9 -- $(jobs -p) 2&gt;/dev/null || true
    echo Disconnected - $GROUP $PORT
}
trap "fin" EXIT

lk set-status exchange $GROUP process anyhost-client --data "abe:OK\nPID:$$\nwe're hosting" &amp;

socat tcp-listen:$PORT,fork exec:"handshake.sh serve serve_io.sh",fdout=4 &amp;

echo PIDS $(jobs -p)
wait -n

#websocat -e -E --binary --ping-timeout 15 --ping-interval 10 \
#         ws-l:0.0.0.0:5020 sh-c:"strace -e 'trace=!all' handshake.sh serve serve_io.sh"
</pre>
</div>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# parent should set out to fd4. otherwise add a exec 4&gt;&amp;1 1&gt;&amp;2
set -euo pipefail
PID=$$
function fin (){
    kill -9 -- -$$ $(jobs -p) 2&gt;/dev/null || true
    echo $PID Disconnected - $THEIR_KEY 
}
trap "fin" EXIT

cd $SESSION
echo SESSION=$SESSION 
echo THEIR_KEY=$THEIR_KEY
echo GROUP=$GROUP
echo PID=$PID
GROUP="[b:$GROUP]"
THEIR_KEY="[b:$THEIR_KEY]"

lk link --create [u64:0] ":[#:0]:/rxlog/$THEIR_KEY" --write db
lk link --create [u64:0] ":[#:0]:/txlog/$THEIR_KEY" --write db
LAST_RX=$(lk --private watch --max 1 ":[#:0]:/rxlog/$THEIR_KEY" | lk printf [create:str])
LAST_TX=$(lk --private watch --max 1 ":[#:0]:/txlog/$THEIR_KEY" | lk printf [create:str])
lk eval "last rx [u64:$LAST_RX/s:str]\nlast tx [u64:$LAST_TX/s:str]\n"

export LINKSPACE_NO_CHECK=true
# save reads from std. i.e. what the client is sending
LINKSPACE_NO_CHECK=false lk save --new db --new stdout \
        --old file:&gt;( lk printf "$PID Ignored [hash:str] (old)" &gt;&amp;2 ) \
   | lk printf --inspect "$PID RX [domain:str] [path:str] [hash:str]" \
   | lk --private collect ":[#:0]:/rxlog/$THEIR_KEY" \
        --min-interval 1m \
        --forward null \
        --write db  &gt; /dev/null &amp;

# Read new request keypoints and return their content
lk watch --new "[f:exchange]:$GROUP:/pull/$GROUP:**" -- "pubkey:=:$THEIR_KEY"  \
    | lk printf --inspect "&gt;&gt;&gt;&gt;Pull req [hash:str]\n[data]\n&lt;&lt;&lt;&lt;$PID " \
    | lk multi-watch \
    | lk dedup \
    | lk printf --inspect "$PID Tx [hash:str]" &gt;&amp;4 


echo PIDS $(jobs -p)
wait -n
</pre>
</div>

</div>

</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">I consider blockchains a subset of supernets.
They require hashes/entries to be shared, pointing to a previous block, and there are strict rules on what to accept in the chain</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">The readme contains technical properties this provides. However, there is one I lack a word for.
Both the process of view-database state synchronization, and dealing with (network) IO in general have this in common:
They're well-designed if they run under the assumption of incomplete/bad state.
In linkspace this is an obvious requirement, and liblinkspace attempts to make it simple.
That's not to imply orchestration becomes simple, or the abstraction does not leak. I fear those are the facts of life.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">To overcome this, just create a new linkpoint, either as a collecting or with a special tag that points to a next linkpoint</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">the hash of <code>lk_datapoint(b"Hello, Sol")</code></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">similar to some definition of 'macros'</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2023-04-03 Mon 17:26</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>