<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-02-23 Thu 09:10 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Linkspace Protocol Guide</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">The Linkspace Protocol Guide</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgcef5d6e">Introduction</a></li>
<li><a href="#org430d3b2">Setup</a>
<ul>
<li><a href="#org91b6171">linkspace-cli</a></li>
<li><a href="#org0b46d39">lkpy - linkspace python bindings</a></li>
</ul>
</li>
<li><a href="#api">API overview</a></li>
<li><a href="#Point">Point</a>
<ul>
<li><a href="#org0ca832b">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
<li><a href="#org365540a">Notes</a></li>
</ul>
</li>
<li><a href="#ABE">ABE</a>
<ul>
<li><a href="#org93d5d1a">Parsing</a></li>
<li><a href="#org011b18a">lk_eval</a>
<ul>
<li><a href="#org2ba674c">Sub-expressions</a></li>
<li><a href="#org14b8849">Scope &amp; context</a></li>
<li><a href="#org18b3c79">Usage notes</a></li>
<li><a href="#abe-help">Help</a></li>
</ul>
</li>
<li><a href="#lk_encode">lk_encode</a></li>
<li><a href="#lk_split_abe">lk_split_abe</a></li>
<li><a href="#ABELNS">LNS</a>
<ul>
<li><a href="#orgf653852">LNS - Local mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Query">Query</a>
<ul>
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#org811453b">More on predicates</a></li>
</ul>
</li>
<li><a href="#Linkspace">Linkspace</a>
<ul>
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_read">lk_read</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
<li><a href="#lk_close_watch">lk_close_watch</a></li>
</ul>
</li>
<li><a href="#Conventions">Conventions</a>
<ul>
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul>
</li>
<li><a href="#lns">LNS</a></li>
<li><a href="#qa">Q&amp;A</a></li>
<li><a href="#imageboard">Example Domain App - Imageboard</a></li>
<li><a href="#anyhost">Example Group Exchange - Anyhost</a></li>
</ul>
</div>
</nav>
<p class="verse">
This is a living document, it is not yet finished, things are broken, and is kept up to date on a best effort basis.<br>
Sometimes the <a href="../cargo-doc/liblinkspace/index.html">liblinkspace</a> docs is ahead of this guide.<br>
</p>

<div id="outline-container-orgcef5d6e" class="outline-2">
<h2 id="orgcef5d6e">Introduction</h2>
<div class="outline-text-2" id="text-orgcef5d6e">
<p>
The Linkspace Protocol provides a structure to build multi-user applications.
<a href="../cargo-doc/liblinkspace/index.html">liblinkspace</a> implements this protocol.
At its core it is a packet layout which are indexed by their hash and their path.
</p>

<p>
If those words mean little you should begin at <a href="../../eli5.html">eli5</a>.
</p>

<p>
Projects such as Git, BitTorrent, Matrix, IPFS, and various blockchains already proof that addressing content is a powerful abstraction.
It sidesteps or solves a number of difficulties inherent in organizing data as a stream in multi-user applications.
When the content in such a system includes objects that link other content by its hash the system can be classified as a supernet.
</p>

<p>
The issue with supernets so far, is that they are bound to their use-case.
The Linkspace Protocol is a general purpose solution.
It is built to be fast and simple.
</p>
<p class="verse">
Supernet  [ˈsü-pərˌnet]<br>
<br>
A self-referential multi-user data organization protocol whose primary<br>
addressing method uses hashes instead of endpoint identifiers.<br>
A communication protocol where the method of exchange is an extraneous concern.<br>
e.g. git, bitcoin, nostr, the linkspace protocol<br>
</p>

<p>
The supernet paradigm is a trade-off.
Instead of processing ordered streams of network data, an application is a function over the partial watch of (potentially noisy) interlinked state.
</p>

<p>
The Linkspace Protocol is best understood as 4 ideas.
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> - Three types of packets</li>
<li><a href="#ABE">ABE</a> - (Byte) templating</li>
<li><a href="#Query">Query</a> - Query for selecting packets</li>
<li><a href="#Linkspace">Linkspace</a> - Packet index and callbacks</li>
</ul>

<p>
A big addition compared to similar systems is the split between domains and groups.
It separates the responsibility of 'User Interface &amp; Data Structure' with the 'Members and the exchange of data'.
This split and other standard problems, are supported by a set of (growing) <a href="#Conventions">Conventions</a>.
</p>
</div>
</div>

<div id="outline-container-org430d3b2" class="outline-2">
<h2 id="org430d3b2">Setup</h2>
<div class="outline-text-2" id="text-org430d3b2">
<p>
This guide uses Python and (Bash) CLI snippets.
You can get the latest version from <a href="https://github.com/AntonSol919/linkspace">GitHub</a>
</p>
</div>

<div id="outline-container-org91b6171" class="outline-3">
<h3 id="org91b6171">linkspace-cli</h3>
<div class="outline-text-3" id="text-org91b6171">
<p>
<code>make install-lk</code> or:
</p>

<div class="org-src-container">
<pre class="src src-bash">cd cli/linkspace
cargo install --path .
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">lk --version
</pre>
</div>

<pre class="example" id="org562e355">
error: unexpected argument '--version' found

Usage: lk [OPTIONS] &lt;COMMAND&gt;

For more information, try '--help'.
</pre>
</div>
</div>


<div id="outline-container-org0b46d39" class="outline-3">
<h3 id="org0b46d39">lkpy - linkspace python bindings</h3>
<div class="outline-text-3" id="text-org0b46d39">
<p>
<code>make install-lkpy</code> or: 
</p>

<div class="org-src-container">
<pre class="src src-bash">cd ffi/liblinkspace-py
make
source ./.env/bin/activate
python -i
&gt;&gt;&gt; import * from lkpy
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-api" class="outline-2">
<h2 id="api">API overview</h2>
<div class="outline-text-2" id="text-api">
<p>
The liblinkspace API is a small set of functions that is mostly stable.
It is available as a Rust crate <code>liblinkspace</code> and binding for other languages follow this API.
</p>

<p>
It consists of the following functions:
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> creation
<ul class="org-ul">
<li><a href="#datapoint-py">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
</ul></li>

<li><a href="#ABE">ABE</a> - ascii byte expressions - a language for manipulating and templating bytes
<ul class="org-ul">
<li><a href="#org011b18a">lk_eval</a></li>
<li><a href="#lk_encode">lk_encode</a></li>
</ul></li>

<li><a href="#Query">Query</a> - Addressing and filtering of packets with predicates and options
<ul class="org-ul">
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
</ul></li>

<li><a href="#Linkspace">Linkspace</a> - Locally indexed packets and new packet processing functions
<ul class="org-ul">
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_read">lk_read</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
</ul></li>

<li><a href="#Conventions">Conventions</a> - functions
<ul class="org-ul">
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-Point" class="outline-2">
<h2 id="Point">Point</h2>
<div class="outline-text-2" id="text-Point">
<p class="verse">
<a href="../cargo-doc/liblinkspace/point/index.html">Rust docs</a><br>
</p>

<p>
Points are the basic units in linkspace.
They carry data, link to other points, and might contain information about the who, what, when, and how.
There are 3 kinds of points. datapoints, linkpoints, and keypoints.
A point has a maximum size of 2<sup>16</sup>-512 bytes.
</p>

<p>
Building a point is always combined with generating a hash and prepending a netheader.
Together the [netheader, hash, point] form a netpacket.
All functions deal in netpacket.
</p>

<p>
Writing an application is the art of defining a relationship between the points.
</p>
</div>



<div id="outline-container-org0ca832b" class="outline-3">
<h3 id="org0ca832b">lk_datapoint</h3>
<div class="outline-text-3" id="text-org0ca832b">
</div>
<ul class="org-ul">
<li><a id="org3b38e67"></a>Bash<br>
<div class="outline-text-5" id="text-org3b38e67">
<div class="org-src-container">
<pre class="src src-bash">echo -n "Hello, Sol" | lk data | lk printf "{hash:str}\n{data}"
</pre>
</div>

<pre class="example" id="org2394d1b">
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
</pre>
</div>
</li>



<li><a id="datapoint-py"></a>Python<br>
<div class="outline-text-5" id="text-datapoint-py">
<div class="org-src-container">
<pre class="src src-python">import lkpy
from lkpy import * 
datap = lk_datapoint(b"Hello, Sol")
lk_eval2str("{hash:str}\\n{data}", datap)
</pre>
</div>

<pre class="example" id="orged7458a">
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
</pre>
</div>
</li>
</ul>
</div>



<div id="outline-container-lk_linkpoint" class="outline-3">
<h3 id="lk_linkpoint">lk_linkpoint</h3>
<div class="outline-text-3" id="text-lk_linkpoint">
<p>
A linkpoint creates relations between packets by their hash and its location.
</p>

<p>
It consists of these fields:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Group<sub>32</sub></td>
<td class="org-left">the intended recipients.</td>
</tr>

<tr>
<td class="org-left">Domain<sub>16</sub></td>
<td class="org-left">the intended application.</td>
</tr>

<tr>
<td class="org-left">Path<sub>var&lt;240</sub></td>
<td class="org-left">Sequence of bytes. e.g. '/dir1/dir2/thing'</td>
</tr>

<tr>
<td class="org-left">Stamp<sub>8</sub></td>
<td class="org-left">Big endian UNIX timestamp in microseconds.</td>
</tr>

<tr>
<td class="org-left">Links<sub>48*n</sub></td>
<td class="org-left">A variable length list of (Tag<sub>16</sub>, Pointer<sub>32</sub>)</td>
</tr>

<tr>
<td class="org-left">Data<sub>var&lt;2<sup>16</sup></sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
A packets' location refers to its (Domain, Group, Path) triple.
All values, including the Path, contain arbitrary bytes.
</p>

<p class="verse">
Packet hashes, GroupID's, and public keys are 32 bytes.<br>
They are usually encoded in URL-safe no-padding base64, e.g. <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code>.<br>
These hashes quickly make things unreadable.<br>
The <code>{...}</code> syntax (<a href="#ABE">ABE</a>) allows us to name and manipulate bytes.<br>
This following example shows that <code>{#:pub}</code> resolves to the bytes <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code> in both the Group and the second link<br>
Furthermore, If no group was provided it defaults to <code>{#:pub}</code><br>
</p>
</div>

<ul class="org-ul">
<li><a id="org5f0fd6c"></a>Bash<br>
<div class="outline-text-5" id="text-org5f0fd6c">
<p>
The command <code>lk link</code> can build linkpoint packets and output's them to stdout by default.
Whenever a cli commands deal with (domain, group, path) tuples, they can be set as the first argument: <code>DOMAIN:GROUP:PATH</code>.
Two links are added with the tags <code>first_tag_1</code> and <code>another_tag</code>
</p>

<div class="org-src-container">
<pre class="src src-bash">lk link "a_domain:{#:pub}:/dir1/dir2/thing" \
          -l first_tag_1:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0 \
          -l another_tag:{#:pub} \
| lk printf
</pre>
</div>
</div>
</li>

<li><a id="org8d4a374"></a>Python<br>
<div class="outline-text-5" id="text-org8d4a374">
<p>
The library requires the actual bytes. We can get them directly from fields or evaluate a string with <a href="#org011b18a">lk_eval</a>.
</p>
<div class="org-src-container">
<pre class="src src-python">ptr1 = lk_eval("{b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0}")
ptr2 = lk_eval("{#:pub}")
datap = lk_datapoint("Hello example");
assert(ptr1 == ptr2)
link1 = Link(tag=b"first tag 1",ptr=ptr1)
link2 = Link(b"another tag",ptr2)
link3 = Link(b"a datapacket",datap.hash)
linkp = lk_linkpoint(domain=b"example domain", group=lk_eval("{#:pub}"), 
                     data=b"Hello, Sol",
                     links=[link1,link2,link3]
                     )
str(linkp)
</pre>
</div>

<p class="verse">
Datapoints do not have a 'create' field, so they get the same hash given the same data.<br>
If we had forced a specific 'create' stamp for both the python and bash example it would have produced the same hash for both.<br>
Instead, 'create' defaults to the current time ( microseconds since epoch ), and thus the hash is different.<br>
</p>
</div>
</li>
</ul>
</div>



<div id="outline-container-lk_keypoint" class="outline-3">
<h3 id="lk_keypoint">lk_keypoint</h3>
<div class="outline-text-3" id="text-lk_keypoint">
<p>
A key point is a linkpoint with an additional publickey and signature.
</p>
</div>


<ul class="org-ul">
<li><a id="org87513ce"></a>Bash<br>
<div class="outline-text-5" id="text-org87513ce">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Set up an instance and generate a key</label><pre class="src src-bash">export LINKSPACE=/tmp/linkspace
lk --init key --insecure --password "" 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">lk keypoint "example::" --sign --password "" | lk printf
</pre>
</div>

<p class="verse">
The CLI also accepts <code>lk link --sign</code> instead of <code>lk keypoint</code><br>
</p>
</div>
</li>
<li><a id="org53099af"></a>Python<br>
<div class="outline-text-5" id="text-org53099af">
<div class="org-src-container">
<pre class="src src-python">key = lk_key("me","my secret");
linkp = lk_keypoint(key=key,domain=b"example")
str(linkp)
</pre>
</div>

<p class="verse">
<a href="#lk_key">lk_key</a> is a function combining lk_keygen, lk_keystring, lk_keyopen, that stores the encrypted string in a linkpoint<br>
such that you can later reference it as <code>{@local:NAME}</code> ( <a href="#ABELNS">abe</a> )<br>
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-org365540a" class="outline-3">
<h3 id="org365540a">Notes</h3>
<div class="outline-text-3" id="text-org365540a">
<p>
Groups conceptually indicate the intended set of recipients and practically the method of data exchange.
Domains conceptually indicate the activity, and practically the application used to present an interface to the user.
</p>

<p>
I.e. The groups bytes are simply chosen and membership is enforced by its members.
They can have a special meaning, such as public key or a pointer to a list of publickeys that act as administrators.
</p>

<p>
The following do have a meaning.
The [0;32] null group ( <code>{#:0}</code> ), i.e. the local only group, is never transmitted to other devices and is never accepted from outside sources.
Everything in the <code>{#:pub}</code> group<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> is meant for everybody. e.g. the public.
</p>

<p>
By convention the group created by pubkey1 XOR pubkey2 forms a group with those keys as its only two members.
</p>

<p class="verse">
The <code>{#:...}</code> is part of the Linkspace Naming System ( <a href="#lns">LNS</a> ).<br>
A public registry for assigning names and naming rights.<br>
e.g. <code>{#:sales:mycomp:com}</code> for groups and <code>{@:alicekey:mycomp:com}</code> for keys.<br>
</p>
</div>
</div>
</div>

<div id="outline-container-ABE" class="outline-2">
<h2 id="ABE">ABE</h2>
<div class="outline-text-2" id="text-ABE">
<p class="verse">
<a href="../cargo-doc/liblinkspace/abe/index.html">Rust docs</a><br>
</p>



<p>
ABE (Ascii-Byte-Expr) is a tiny byte templating language.
Its primary purpose is to make it easy for developers to read and write arbitrary (0..=255) bytes in plain ascii,
but it can add context's ( such as a linkspace instance) and evaluate expressions ( such as a 'name' for a public key ).
</p>

<p>
Linkspace has no concept of encoding.
Fields have a fixed length or prefix their exact length.
The <code>null</code> (0) byte is not special.
</p>

<p>
Things like <a href="#Query">Query</a> or simply printing a text representation of a packet use ABE.
</p>

<p class="verse">
Note that its up to the application how to display the bytes to the end user.<br>
For instance, they could demand the bytes are valid UTF8 containing one emoji and ignore packets otherwise.<br>
</p>
</div>

<div id="outline-container-org93d5d1a" class="outline-3">
<h3 id="org93d5d1a">Parsing</h3>
<div class="outline-text-3" id="text-org93d5d1a">
<ul class="org-ul">
<li>Most printable ascii letters are as is.</li>
<li>The external delimiters <code>'\n'</code> (newline) and <code>'\t'</code> (tab) are invalid characters.</li>
<li>the internal delimiters <code>:</code> , <code>/</code>.</li>
<li><code>{</code> and <code>}</code> wrap an expression</li>
<li><code>:</code>, <code>/</code>, <code>\</code>, <code>{</code>, <code>}</code>  can be escaped with a <code>\</code>.</li>
<li><code>\x00</code> up-to <code>\xFF</code> for bytes.</li>
<li><code>\0</code> equals  <code>\x00</code>,  <code>\f</code> equals <code>\xFF</code></li>
</ul>
</div>
</div>

<div id="outline-container-org011b18a" class="outline-3">
<h3 id="org011b18a">lk_eval</h3>
<div class="outline-text-3" id="text-org011b18a">
<p>
ABE is evaluated by substituting an expressions ( <code>{..}</code> ) with its result.
For example in <code>{u8:97}</code>, the function 'u8' parses "97" and prints it.
The byte 97 equals the character 'a'. 
</p>

<div class="org-src-container">
<pre class="src src-bash">lk eval "ab{u8:99}" | xxd
</pre>
</div>

<p>
The result of an ABE is a list of (bytes, ?delimiter). 
</p>
<div class="org-src-container">
<pre class="src src-bash">lk eval --json "h{u8:101}ll{u8:111} / world:etc" 
</pre>
</div>

<p>
Note that bytes are joined after evaluating. In the example this results in the component <code>('hello ', /)</code>.
The delimiters (\n \t : /) are interpreted depends on the context.
In the context of <code>linkspace eval</code> the delimiters are simply printed as is.
</p>

<p class="verse">
The rest of this chapter goes further in depth.<br>
With basic knowledge of expression substitution (<code>{..}</code>) and the <code>':'</code>, <code>'/'</code> delimiters the reader can choose to<br>
skip to the next chapter <a href="#Query">Query</a> and return here for reference later.<br>
</p>
</div>


<div id="outline-container-org2ba674c" class="outline-4">
<h4 id="org2ba674c">Sub-expressions</h4>
<div class="outline-text-4" id="text-org2ba674c">
<p>
A list of functions/evaluators be found by evaluating <a href="#abe-help">{help}</a>.
</p>
</div>

<ul class="org-ul">
<li><a id="org2d301cb"></a>Functions<br>
<div class="outline-text-5" id="text-org2d301cb">
<ul class="org-ul">
<li><code>{fn}</code></li>
<li><code>{fn:arg0}</code></li>
<li><code>{fn:arg0:arg1}</code></li>
</ul>

<p>
Their arguments are bytes. They can take upto 8 arguments.
The resulting bytes are concatenated with their surrounding.
The empty function <code>'{:...}'</code> resolves to its first argument.
</p>

<ul class="org-ul">
<li><code>hello {:world}</code> == <code>hello world</code></li>
</ul>

<p>
Arguments are evaluated before application.
<code>{fn0:{fn1}}</code> will call fn1 and use its result as the first argument to fn0.
</p>

<p>
Functions can be chained with <code>/</code>.
This uses the result as the first argument to the next function.
</p>

<ul class="org-ul">
<li><code>{:97/u8}</code> <code>= ~{u8:97}~ =</code> <code>a</code></li>
<li><code>{:97/u8/?u}</code> <code>= ~{?u:{u8:97}}~ =</code> <code>97</code></li>
</ul>

<p class="verse">
You can think of ABE Functions as a translation of conventional function calling.<br>
'{name:arg1:arg2} <code>= name(arg1,arg2)'<br>
'{name:{other_name:argA}:arg2} =</code> name( other_name(argA) , arg2 )'<br>
'{other_name:argA/name:arg2}' == name ( other_name(argA) , arg2 )'<br>
</p>

<p class="verse">
Functions are aware if they are first or not.<br>
The vast majority of functions do not care.<br>
</p>

<p class="verse">
<code>{{:u8}:97}</code> is explicitly not allowed. Variable function identifiers are conceptually interesting but practically begging for bugs.<br>
</p>
</div>
</li>

<li><a id="orga56590a"></a>Evaluators<br>
<div class="outline-text-5" id="text-orga56590a">
<p>
The second type of operation is calling an evaluator.
Whereas functions are called after their arguments are evaluated.
Evaluators are called without evaluation <code>{..}</code> expressions.
</p>

<ul class="org-ul">
<li><code>{/re}</code></li>
<li><code>{/re:arg0:arg1}</code></li>
<li><code>{/re:{fn:arg0}:arg1}</code></li>
</ul>

<p>
The <code>/re</code> function finds <code>{fn:arg0}</code> without it being evaluated
</p>

<p>
The most common use-case for evaluators is extending the scope. 
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org14b8849" class="outline-4">
<h4 id="org14b8849">Scope &amp; context</h4>
<div class="outline-text-4" id="text-org14b8849">
<p>
Functions and evaluators are defined in a scope.
The standard scope contains functions to manipulate bytes.
Some scopes require a context.
</p>
</div>

<ul class="org-ul">
<li><a id="orga60d287"></a>Packet scope<br>
<div class="outline-text-5" id="text-orga60d287">
<p>
By providing a packet, the packet scope is added.
This adds operations to evaluate packet fields such as <code>hash</code>, <code>group</code>, <code>path</code> etc.
These are bytes that you can use as arguments. E.g <code>{hash/?b}</code> encodes the hash in base 64.
For convenience all packet fields accept 'str' and 'abe' as a first argument to print them in a default format.
E.g. <code>{hash:str}</code> <code>= ~{hash/?b}~, and ~{create:str}~ =</code> <code>{create/?u}</code>.
</p>

<p>
The <code>links</code> evaluator iterates over every link in a packet.
It evaluates the inner scope for each link with the with an additional <code>tag</code> and <code>ptr</code> function for each link in the packet.
</p>
</div>
</li>

<li><a id="org5f8a579"></a>bash<br>
<div class="outline-text-5" id="text-org5f8a579">
<p>
<a id="org788d4b7"></a>
<code>printf</code> is similar to <code>eval</code> except that it reads packets from stdin and uses them as context.
</p>
<div class="org-src-container">
<pre class="src src-bash">lk link "::" -l tag1:{#:0} -l tag2:{#:pub} | lk printf "HASH:{hash/?b}\n{/links:TAG = {tag:str} PTR = {ptr:str} \n}"
</pre>
</div>
</div>
</li>

<li><a id="org187ee3c"></a>python<br>
<div class="outline-text-5" id="text-org187ee3c">
<div class="org-src-container">
<pre class="src src-python">datap = lk_datapoint(b"hello")
lk_eval2str("{data} or in base64 {data/?b}",datap)
</pre>
</div>

<pre class="example" id="org94d4f9f">
hello or in base64 aGVsbG8
</pre>

<ul class="org-ul">
<li>Linkspace scope</li>
</ul>

<p>
Having a linkspace instance in the scope ( <a href="#lk_open">lk_open</a> does this automatically ) add various options such as
</p>

<ul class="org-ul">
<li><code>?</code> to access packets by their hash</li>
<li><code>#</code> and <code>@</code> ( see <a href="#lns">LNS</a> ) for publicly named groups, keys, and other data</li>
<li><code>#local</code> and <code>@local</code> for privately named groups, keys, and other data.</li>
<li><code>readhash</code></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-org18b3c79" class="outline-4">
<h4 id="org18b3c79">Usage notes</h4>
<div class="outline-text-4" id="text-org18b3c79">
<p>
ABE expressions evaluate into a list of [ (bytes,?sep) ].
Sometimes each element has a different meaning, e.g. [ ( domain , : ) , (group , _) ] in the CLI arguments.
It's also common to turn the result directly into bytes. 
<code>lk_eval</code> does just that. To interpret each item use the <code>lk_split_abe</code> function. 
</p>

<p>
When ABE expressions are nested, such as <code>{/links:expr}</code>,  <code>{/readhash:{#:pub}:some expr}</code>, <code>{/:hello world}</code>
we could choose to do two things. Either the expr must resolve to a list of [ (bytes,?sep) ] of at most length 1 without a separator. 
Resulting in plain bytes. 
Or we concatenate all the bytes and separators.
</p>

<p>
This last pattern 'destroys' some context information, but has the upside of greatly reducing the number of escapes \: or \/. 
For instance <code>lk link :: --write 'file:./afolder:with/colons'</code>
Either we interpret only ./afolder , or we interpret it as './afolder:with/colons'
</p>

<p>
The rule of thumb is that if the last element in an expression results in plain bytes, the entire list is concatenated including separators <span class="underline">as is</span>. 
</p>

<p class="verse">
We can add an expression to &#x2013;write arguments<br>
<code>lk link :: --write "stdout-expr:hello world:/ {hash:str}"</code><br>
In case of <code>file</code> this leaves us in the situation that second argument is the file and the tail of the expression will be evaluated<br>
The simplest way to ignore all escapes is to use empty evaluator <code>{/:..}</code>.<br>
<code>lk link :: --write "file-expr:{/:./afolder:with/colons}:hello world:/ {hash:str}"</code><br>
</p>
</div>
</div>


<div id="outline-container-abe-help" class="outline-4">
<h4 id="abe-help">Help</h4>
<div class="outline-text-4" id="text-abe-help">
<p>
A full list of active scopes can be viewed with the <code>help</code> function.
</p>

<p class="verse">
The following naming conventions are used:<br>
<br>
- ending with '?' is a predicate to check a property.<br>
- starting with '?' is a basic reverse operation , e.g. <code>'?a'</code>, the less powerful <a href="#lk_encode">lk_encode</a> ( This is different but related to [lk_encode], the more powerful reverse op)<br>
- b_RADIX_ ( b2, b8, b16 ) 'b' defaults to base64 radix<br>
- u_SIZE_  ( u8, .., u128 ) parse decimal into big endian bytes. ?u interpret as big endian print to decimal<br>
</p>
</div>

<ul class="org-ul">
<li><a id="orgcdcf3d0"></a>python<br>
<div class="outline-text-5" id="text-orgcdcf3d0">
<div class="org-src-container">
<pre class="src src-python">lk_eval2str("{help}",lk_linkpoint())
</pre>
</div>

<pre class="example" id="org856e293">
==scopes==
# bytes
Byte padding/trimming and ascii-byte reflection functions
## functions
-                  /:?          1..=16     the blank fnc can be use to start an expr such as {:12/u8} which is the same as {u8:12}  
- ?a               /:?          1..=1     encode bytes into ascii-bytes format  
- ?a0              /:?          1..=1     encode bytes into ascii-bytes format but strip prefix '0' bytes  
- a                /:?          1..=3     [bytes,length = 16,pad_byte = \0] - alias for 'pad&lt;'  
- f                /:?          1..=3     same as 'a' but uses \xff as padding   
- pad&lt;             /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad input bytes  
- pad&gt;             /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad input bytes  
- cut&lt;             /:?          1..=2     [bytes,length = 16] - left cut input bytes  
- cut&gt;             /:?          1..=2     [bytes,length = 16] - right cut input bytes  
- trim&lt;            /:?          1..=2     [bytes,length = 16] - left trim ( cut&lt; without error )  
- trim&gt;            /:?          1..=2     [bytes,length = 16] - right trim ( cut&gt; without error )  
- b2               /:?          1..=1     decode binary  
- b8               /:?          1..=1     decode octets  
- b16              /:?          1..=1     decode hex  

# UInt
Unsigned integer functions
## functions
- +                /:?          1..=16     Saturating addition. Requires all inputs to be equal size  
- -                /:?          1..=16     Saturating subtraction. Requires all inputs to be equal size  
- u8               /:?          1..=1     parse 1 byte  
- u16              /:?          1..=1     parse 2 byte  
- u32              /:?          1..=1     parse 4 byte  
- u64              /:?          1..=1     parse 8 byte  
- u128             /:?          1..=1     parse 16 byte  
- ?u               /:?          1..=1     Print big endian bytes as decimal  
- lu               /:?          1..=1     parse little endian byte (upto 16)  
- lu8              /:?          1..=1     parse 1 little endian byte  
- lu16             /:?          1..=1     parse 2 little endian byte  
- lu32             /:?          1..=1     parse 4 little endian byte  
- lu64             /:?          1..=1     parse 8 little endian byte  
- lu128            /:?          1..=1     parse 16 little endian byte  
- ?lu              /:?          1..=1     print little endian number  

# b64
base64 url-safe no-padding
## functions
- ?b               /:?          1..=1     encode base64  
- 2mini            /:?          1..=1     encode mini  
- b                /:?          1..=1     decode base64  

# help

## functions
- help             /:           0..=16     help  
## eval
- help             desribe current eval context  

# logic ops
ops are : &lt; &gt; = 0 1 
## functions
- size?            /:?          3..=3     [in,OP,VAL] error unless size passes the test ( UNIMPLEMENTED )  
- val?             /:?          3..=3     [in,OP,VAL] error unless value passes the test ( UNIMPLMENTED)  
## eval
- or               :{EXPR}[:{EXPR}]* short circuit evaluate untill valid return. Empty is valid, use {_/minsize?} to error on empty  

# encode
attempt an inverse of a set of functions
## functions
- eval             /:           1..=1     parse and evaluate  
## eval
- ?                find an abe encoding for the value trying multiple reversal functions - [/fn:{opts}]*   
- e                eval inner expression list. Useful to avoid escapes: eg file:{/e:/some/dir:thing}:opts does not require escapes the '/'   

# static-lns
static lns for local only {{#:0}} and public {{#:pub}}
## functions
- #                / ?          1..=1     resolve #:0 , #:pub, and #:test without a db  
- @                / ?          1..=1     resolve @:none  

# stamp
utilities for stamp values (big endian u64 microsecond since unix epoch)
arguments consists of ( [+-][YMWDhmslu]usize : )* (str | 2delta | 2y6)?

## functions
- s                /:           0..=16     if chained, mutate 8 bytes input as stamp (see scope help). if used as head assume stamp 0  
- now              / ?          0..=16     current systemtime  
- epoch            / ?          0..=16     unix epoch / zero time  
- s++              / ?          0..=16     max stamp  

# path
spath and ipath utls. Usually you'll want {//some/path}
## functions
- ?sp              /:?          1..=1     decode spath  
- ?ip              /:?          1..=1     decode ipath  
- ipcomp           /:?          2..=3     ipath select [start,?end]  
- spcomp           /:?          2..=3     ipath select [start,?end]  
- ip               /:?          1..=8     build ipath from arguments  
- sp               /:?          1..=8     build spath from arguments  
## eval
-                  the 'empty' eval for build spath. i.e. {//some/spath/val} creates the byte for /some/spath/val  

# lns

## functions
- lns              /:?          1..=1     rev lookup  
- ?@               /:?          1..=1     rev lookup  
- ?#               /:?          1..=1     rev lookup  

# local-lns

## functions
- local            /            1..=16     [namecomp*] - get the entire local lns packet and fowards arg to pkt scope  
- #local           / ?          1..=7     [namecomp*] - get the associated local lns group name  
- @local           / ?          1..=7     [namecomp*] - get the associated local lns group name  
## eval
- local            namecmp*::{EXPR} evaluate expr with pkt scope of local  

# config
read files from Err(Custom { kind: Other, error: "No runtime argument given" }) 
## functions
- conf             /:           1..=1     read a file from the conf directory  

# database
get packets from the local db.
e-funcs evaluate their args as if in pkt scope.
funcs evaluate as if {/[func + args]:{rest}}. (e.g. {/readhash:HASH:{group:str}} == {readhash:..:group:str})
## functions
- readhash         /:           1..=16     open a pkt by hash and use tail args as if calling in a netpkt scope  
- read             /:           2..=16     read but accesses open a pkt by dgpk path and apply args. e.g. {read:mydomain:{#:pub}:{//a/path}:{@:me}::data:str}, prefer eval ctx  
## eval
- readhash         HASH ':' expr [ ':' alt if not found ]   

# netpkt field
get a field of a netpkt. also used in watch predicates.
## functions
- netflags         /            0..=1     ?(str|abe) - get netflags field from netpkt  
- hop              /            0..=1     ?(str|abe) - get hop field from netpkt  
- stamp            /            0..=1     ?(str|abe) - get stamp field from netpkt  
- ubits0           /            0..=1     ?(str|abe) - get ubits0 field from netpkt  
- ubits1           /            0..=1     ?(str|abe) - get ubits1 field from netpkt  
- ubits2           /            0..=1     ?(str|abe) - get ubits2 field from netpkt  
- ubits3           /            0..=1     ?(str|abe) - get ubits3 field from netpkt  
- hash             /            0..=1     ?(str|abe) - get hash field from netpkt  
- type             /            0..=1     ?(str|abe) - get type field from netpkt  
- point_size       /            0..=1     ?(str|abe) - get point_size field from netpkt  
- pubkey           /            0..=1     ?(str|abe) - get pubkey field from netpkt  
- signature        /            0..=1     ?(str|abe) - get signature field from netpkt  
- group            /            0..=1     ?(str|abe) - get group field from netpkt  
- domain           /            0..=1     ?(str|abe) - get domain field from netpkt  
- create           /            0..=1     ?(str|abe) - get create field from netpkt  
- path_len         /            0..=1     ?(str|abe) - get path_len field from netpkt  
- links_len        /            0..=1     ?(str|abe) - get links_len field from netpkt  
- data_size        /            0..=1     ?(str|abe) - get data_size field from netpkt  
- path             /            0..=1     ?(str|abe) - get path field from netpkt  
- comp0            /            0..=1     ?(str|abe) - get comp0 field from netpkt  
- comp1            /            0..=1     ?(str|abe) - get comp1 field from netpkt  
- comp2            /            0..=1     ?(str|abe) - get comp2 field from netpkt  
- comp3            /            0..=1     ?(str|abe) - get comp3 field from netpkt  
- comp4            /            0..=1     ?(str|abe) - get comp4 field from netpkt  
- comp5            /            0..=1     ?(str|abe) - get comp5 field from netpkt  
- comp6            /            0..=1     ?(str|abe) - get comp6 field from netpkt  
- comp7            /            0..=1     ?(str|abe) - get comp7 field from netpkt  
- data             /            0..=1     ?(str|abe) - get data field from netpkt  

# print pkt default

## functions
- pkt              /            0..=0     default pk fmt  
- netpkt           /            0..=0     TODO default netpkt fmt  
- point            /            0..=0     TODO default point fmt  
- netbytes         / ?          0..=0     raw netpkt bytes  

# select link

## functions
- *=               /:?          1..=1     [suffix] get first link with tag ending in suffix  
## eval
- links            :{EXPR} where expr is repeated for each link binding 'ptr' and 'tag'  

# recv
recv stamp for packet. value depends on the context
## functions
- recv             / ?          0..=0     recv stamp - errors if unavailable in context  
- recv_now         / ?          0..=0     recv stamp - recv stamp returns now if unavailable in context  

</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-lk_encode" class="outline-3">
<h3 id="lk_encode">lk_encode</h3>
<div class="outline-text-3" id="text-lk_encode">
<p>
Translate bytes into abe such that <code>lk_eval(lk_encode(X)) == X</code>
</p>
</div>
<ul class="org-ul">
<li><a id="org9dd17a1"></a>python<br>
<div class="outline-text-5" id="text-org9dd17a1">
<div class="org-src-container">
<pre class="src src-python">data = bytes([123,255,0,2])
abe = lk_encode(data)
assert data == lk_eval(abe)
</pre>
</div>

<p>
We can get meta, lk_encode is available as the evaluator <code>{/?:bytes:options}</code>
</p>
</div>
</li>
</ul>
</div>


<div id="outline-container-lk_split_abe" class="outline-3">
<h3 id="lk_split_abe">lk_split_abe</h3>
<div class="outline-text-3" id="text-lk_split_abe">
</div>
</div>



<div id="outline-container-ABELNS" class="outline-3">
<h3 id="ABELNS">LNS</h3>
<div class="outline-text-3" id="text-ABELNS">
<p>
LNS is a work in progress, but is designed to integrate with ABE.
Currently, the following are available:
</p>

<p>
<code>{#:pub}</code> for the public group.
<code>{#:0}</code> for the local only group. 
</p>

<p>
See the <a href="../../lns.html">lns.html</a> for info.
</p>
</div>

<div id="outline-container-orgf653852" class="outline-4">
<h4 id="orgf653852">LNS - Local mode</h4>
<div class="outline-text-4" id="text-orgf653852">
<p>
You can name keys in your local index, allowing you to reference <code>{@local:my_identity}</code> or <code>{#local:friends}</code>
By default <a href="#lk_key">lk_key</a> sets up the <code>{@local:me}</code> identity.
The function to do so is not yet exported (crates/common/protocol/lns/local.rs::build_local_lns_points)
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-Query" class="outline-2">
<h2 id="Query">Query</h2>
<div class="outline-text-2" id="text-Query">
<p class="verse">
<a href="../cargo-doc/liblinkspace/query/index.html">Rust docs</a><br>
</p>

<p>
A query is a list of predicates and options used to select a set of packets.
They are used by the local index ( <a href="#lk_watch">lk_watch</a> and <a href="#lk_read">lk_read</a> ),
or to signal what packets should be found looked for in the group ( <a href="#lk_pull">lk_pull</a> ),
or as a filter function.
</p>
</div>

<div id="outline-container-lk_query" class="outline-3">
<h3 id="lk_query">lk_query</h3>
<div class="outline-text-3" id="text-lk_query">
<p>
Queries are newline separated.
Predicates are <a href="#ABE">ABE</a> a 3-tuple <code>field ':' test-operation ':' value</code> and constrain the set of accepted packets.
Options are context dependent and start with ':'
</p>

<pre class="example" id="org5e3049e">
group:=:{#:pub}
domain:=:example
data_size:&lt;=:{u16:256}
prefix:=:/hello/world
pubkey:=:{@local:me}
link_len:&gt;=:{u16:2}
link_len:&lt;=:{u16:8}

:mode:tree-asc
:follow
:watch:gethellos
</pre>

<p>
A predicate can be set multiple times.
They are designed such that you can concatenate two queries.
If the result can only ever be the empty set an error is returned.
</p>

<p>
There are only 4 basic test operations.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Basic Op</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&gt;</td>
<td class="org-left">greater eq</td>
</tr>

<tr>
<td class="org-left">&lt;</td>
<td class="org-left">less eq</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-left">all '0' in value are '0' in field</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">all '1' in value are '1' in field</td>
</tr>
</tbody>
</table>

<p>
The following are shorthand and resolve to one or more of the basic tests.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Derived Ops</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">=</td>
<td class="org-left">&gt;(val-1) and &lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">&gt;=</td>
<td class="org-left">&gt;(val-1)</td>
</tr>

<tr>
<td class="org-left">&lt;=</td>
<td class="org-left">&lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">*=</td>
<td class="org-left">Last n-bytes must eq val</td>
</tr>

<tr>
<td class="org-left">=*</td>
<td class="org-left">First n-bytes must eq val</td>
</tr>
</tbody>
</table>


<p>
The CLI has various aliases that can act as a guide in creating queries by using <code>print-query</code>.
</p>
</div>

<ul class="org-ul">
<li><a id="orgc8b7c85"></a>bash<br>
<div class="outline-text-5" id="text-orgc8b7c85">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>A query that matches keypoints with domain 'my' , group '{#:pub}' , path with 2 components starting with  '/hello'</label><pre class="src src-bash">lk print-query "my:{#:pub}:/hello:*" --signed
</pre>
</div>

<pre class="example" id="org918456b">
:mode:tree-desc
:watch:default
type:1:{b2:00000111}
domain:=:{a:my}
group:=:{b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0}
prefix:=:/hello
path_len:&lt;:{u8:3}
path_len:&gt;:{u8:0}
</pre>

<p class="verse">
Note that many cli commands (e.g. <code>print-statemnt</code>, <code>watch</code> ) take as the first argument a <code>domain:group:path:[?depth]</code><br>
If no depth is set the path_len is constraint by default.<br>
Except for <code>watch-tree</code> which sets the depth to unconstrained by default<br>
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-lk_query_print" class="outline-3">
<h3 id="lk_query_print">lk_query_print</h3>
<div class="outline-text-3" id="text-lk_query_print">
<p>
Print a query as text.
The query will have merged overlapping predicates and will give the 'obvious' ABE encoding for each field.
The last argument sets whether to create abe expressions or stick to ab-text with out the expressions
</p>

<div class="org-src-container">
<pre class="src src-python">lk_query_print(lk_query("path_len:&lt;:{u8:3}","path_len:&lt;:{u8:2}","group:=:{#:pub}"),True)
</pre>
</div>

<pre class="example" id="orgdc7e29b">
type:1:{b2:00000010}
group:=:{b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0}
path_len:&lt;:{u8:2}
</pre>

<p class="verse">
The <code>b2</code> function read a binary representation.<br>
The types are: datapoint={b2:0000_0001}, linkpoint {b2:0000_0011}, keypoint {b2:0000_0111}.<br>
Setting group, domain, path, links, or create predicates automatically exclude the datapoint type.<br>
Setting pubkey or signature excludes link and data points.<br>
</p>
</div>
</div>

<div id="outline-container-lk_query_parse" class="outline-3">
<h3 id="lk_query_parse">lk_query_parse</h3>
<div class="outline-text-3" id="text-lk_query_parse">
<p>
Add multiple constraints to a query. Returns an error if the resulting set is empty.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Predicates contradict. No such packet can exist.</label><pre class="src src-python">lk_query_parse("prefix:=:/hello/world","path_len:&lt;:\x01")
</pre>
</div>
</div>
</div>

<div id="outline-container-lk_query_push" class="outline-3">
<h3 id="lk_query_push">lk_query_push</h3>
<div class="outline-text-3" id="text-lk_query_push">
<p>
Add a single statement to a query without encoding the final field
</p>
</div>
</div>

<div id="outline-container-org811453b" class="outline-3">
<h3 id="org811453b">More on predicates</h3>
<div class="outline-text-3" id="text-org811453b">
<p class="verse">
<code>group</code> requires 32 bytes but will try to parse base64.<br>
<code>domain</code> requires 16 bytes but will prepend '\0' if too few bytes are given<br>
<code>path</code> and <code>prefix</code> only take the "\=" op, and take spath bytes. I.e. <code>path:=:{//hello/world}</code>, but will accept <code>/hello/world</code> as well<br>
</p>

<p>
Besides the fields in a point, predicates also apply to the hash and variable net header fields.
The netheader fields can be mutated.
It is 32 bytes consisting of the following field. 
The netheader fields are :
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Prefix<sub>3</sub></td>
<td class="org-left">magic bytes 'LS0'</td>
</tr>

<tr>
<td class="org-left">NetFlags<sub>1</sub></td>
<td class="org-left">See source code</td>
</tr>

<tr>
<td class="org-left">hop<sub>2</sub></td>
<td class="org-left">number of hops since creation</td>
</tr>

<tr>
<td class="org-left">stamp<sub>8</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits0<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits1<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits2<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits3<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The stamp and ubits are set by the exchange process. e.g. <a href="#anyhost">anyhost</a>
</p>
</div>

<ul class="org-ul">
<li><a id="orgb00f001"></a>NetFlags<br>
<div class="outline-text-5" id="text-orgb00f001">
<p>
For instance, the anyhost exchange example has:
The server receiving thread sets ubits to a value identifying the client.
The server sending thread checks ubits to ensure packets aren't being sent back to the origin. 
</p>

<p>
The full list of addressable fields is the same as in the ABE packet scope:
</p>
<div class="org-src-container">
<pre class="src src-bash">lk print-query --help
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-Linkspace" class="outline-2">
<h2 id="Linkspace">Linkspace</h2>
<div class="outline-text-2" id="text-Linkspace">
<p class="verse">
<a href="../cargo-doc/liblinkspace/linkspace/index.html">Rust docs</a><br>
</p>



<p>
The linkspace is a local log and index that one or more processes connect to.
It is the place you save and retrieve data from.
Either by read or watch.
The latter lets you callback for each currently known and future packet matching a specific set of predicates.
This is done in the <a href="#lk_process">lk_process</a> stage.
The callback receives the linkspace.
You can nest calling <code>lk_watch</code> and <code>lk_read</code>.
</p>
</div>

<div id="outline-container-lk_open" class="outline-3">
<h3 id="lk_open">lk_open</h3>
<div class="outline-text-3" id="text-lk_open">
</div>
</div>

<div id="outline-container-lk_save" class="outline-3">
<h3 id="lk_save">lk_save</h3>
<div class="outline-text-3" id="text-lk_save">
</div>
</div>

<div id="outline-container-lk_read" class="outline-3">
<h3 id="lk_read">lk_read</h3>
<div class="outline-text-3" id="text-lk_read">
</div>
</div>

<div id="outline-container-lk_watch" class="outline-3">
<h3 id="lk_watch">lk_watch</h3>
<div class="outline-text-3" id="text-lk_watch">
</div>
</div>


<div id="outline-container-lk_process" class="outline-3">
<h3 id="lk_process">lk_process</h3>
<div class="outline-text-3" id="text-lk_process">
</div>
</div>

<div id="outline-container-lk_process_while" class="outline-3">
<h3 id="lk_process_while">lk_process_while</h3>
<div class="outline-text-3" id="text-lk_process_while">
</div>
</div>


<div id="outline-container-lk_close_watch" class="outline-3">
<h3 id="lk_close_watch">lk_close_watch</h3>
<div class="outline-text-3" id="text-lk_close_watch">
</div>
</div>
</div>


<div id="outline-container-Conventions" class="outline-2">
<h2 id="Conventions">Conventions</h2>
<div class="outline-text-2" id="text-Conventions">
<p class="verse">
<a href="../cargo-doc/liblinkspace/linkspace/conventions.html">Rust docs</a><br>
</p>

<p>
Conventions are functions built on top of the other linkspace functions.
They provide interop for processes by encoding data into linkspace packets.
</p>

<p>
One general conventions is that domains and paths starting with \xff are for meta stuff, such as status queries.
</p>
</div>

<div id="outline-container-lk_status_set" class="outline-3">
<h3 id="lk_status_set">lk_status_set</h3>
<div class="outline-text-3" id="text-lk_status_set">
<p>
Status queries allow us to communicate if a process exists that is handling a specific type and a specific instance.
</p>

<p>
The function signature is `DOMAIN GROUP OBJ_TYPE INSTANCE`.
</p>

<ul class="org-ul">
<li>A request is a packet in the form DOMAIN:{#:0}:/\fstatus/GROUP/type[/instance?] and has no data and no links.</li>
<li>A reply is of the form DOMAIN:{#:0}/\status/GROUP/type/instance with some data and at least one link.</li>
</ul>

<p>
Note that the packets are in `#:0`.
This function is only for local status updates.
</p>

<p>
The group argument does not ask inside GROUP, it only signals which group the query is about.
Other processes are meant to answer a request.
</p>

<p>
The following are statuses that the exchange process should set:
</p>

<p>
exchange GROUP process
exchange GROUP connection PUBKEY
exchange GROUP pull PULL PULL_HASH
</p>
</div>
</div>

<div id="outline-container-lk_status_poll" class="outline-3">
<h3 id="lk_status_poll">lk_status_poll</h3>
<div class="outline-text-3" id="text-lk_status_poll">
<p>
Request the status of a `domain group obj_type ?instance timeout`.
</p>
</div>
</div>


<div id="outline-container-lk_pull" class="outline-3">
<h3 id="lk_pull">lk_pull</h3>
<div class="outline-text-3" id="text-lk_pull">
<p>
A pull request is made by a domain application and signals the set of packets it wants.
</p>

<p class="verse">
Note that from a domain's perspective, there is no such thing as 'fully synchronized'.<br>
The most straight forwards way to emulate such a thing is to create 'log' packets that link to<br>
known packets from a single device's perspective.<br>
</p>

<p>
Pull queries must have the predicates 'domain:=:..' and 'group:=:..', and ':watch'
</p>

<p>
It is up to an exchange process (e.g. <a href="#anyhost">anyhost</a> ) to fulfill the query.
The exchange is only responsible for pull requests received when it is running.
The exchange will drop requests when you reuse the 'watch'.
( use :watch:{now} to ensure it is unique. )
The function returns the hash of the request.
</p>

<p>
The domain should be conservative with its query.
Requesting too much can add significant overhead.
</p>
</div>
</div>

<div id="outline-container-lk_key" class="outline-3">
<h3 id="lk_key">lk_key</h3>
<div class="outline-text-3" id="text-lk_key">
<p>
Read ( or creates ) an encrypted private key from lns:{#:0}:/local/NAME.
Also writes into the local LNS lookup table such that the public key can be requested with <code>{@local:NAME}</code>
</p>
</div>
</div>
</div>

<div id="outline-container-lns" class="outline-2">
<h2 id="lns">LNS</h2>
<div class="outline-text-2" id="text-lns">
<p>
See <a href="#ABELNS">abe#lns</a> and <a href="../../lns.html">LNS</a>.
</p>
</div>
</div>

<div id="outline-container-qa" class="outline-2">
<h2 id="qa">Q&amp;A</h2>
<div class="outline-text-2" id="text-qa">
</div>


<ul class="org-ul">
<li><a id="org929c5fc"></a>Why Big Endian?<br>
<div class="outline-text-5" id="text-org929c5fc">
<p>
The tree index is in the expected order when using the numbers as path components.
E.g. <code>lk linkpoint ::/some/dir/{now}</code> will come after <code>lk linkpoint ::/some/dir/{now:-1D}</code> because <code>now &gt; (now - one day)</code>
</p>
</div>
</li>

<li><a id="org4ea52ff"></a>Why can't I own a group? / I'm not in control of the user! / Anybody in my group can leak data from it!?<br>
<div class="outline-text-5" id="text-org4ea52ff">
<p>
I don't make the rules, I just make them obvious.
</p>
</div>
</li>

<li><a id="orgef78128"></a>I want to add advertisements to my domain app/Every user of my domain app needs X from my server.<br>
<div class="outline-text-5" id="text-orgef78128">
<p>
You hardcode a public key into the app, and also publish a group exchange service.
There are two primary ways to centralize information.
Either they connect over the public group, or you can connect over their-key XOR your-key group.
</p>
</div>
</li>

<li><a id="org8acd7d7"></a>A domain can write outside its own domain space.<br>
<div class="outline-text-5" id="text-org8acd7d7">
<p>
Yes, the current API has no restriction.
The best thing I think would be to build a wasm runtime interface and restrict access entirely.
That will take some time before we reached that point.
</p>
</div>
</li>

<li><a id="orgb8faf52"></a>Why not use an SQL backend? / Why invent queries?<br>
<div class="outline-text-5" id="text-orgb8faf52">
<p>
That is a complex question.
First off, if all you want is SQL queries it is relatively straight forward to stream packets into a SQL table and query them.
But SQL isn't magic, and its non-trivial price to pay for something that is not a great fit for a few fundamental problems including:
</p>
<ol class="org-ol">
<li>What is the index peers agree on?</li>
<li>How to constrain a query as it travels across a group?</li>
</ol>
<p>
Both can be solved in a number of ways, but most solutions are quickly going to bloat.
I've tried.
</p>

<p>
Queries have two desirable properties.
You can do a form of algebra on them with concatenation and equality.
They're powerful enough for where they're used.
</p>
</div>
</li>

<li><a id="orgf1096c8"></a>Will it handle spam?<br>
<div class="outline-text-5" id="text-orgf1096c8">
<p>
You can require proof of work or a proof of association.
POW is as simple as adding a predicate on the hash.
AI Generated spam only makes this association more important than it is now, and the linkspace protocol can help there.
Will it solve it entirely? Never.
But existing solutions can be adapted and we get more tools to do better.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-imageboard" class="outline-2">
<h2 id="imageboard">Example Domain App - Imageboard</h2>
<div class="outline-text-2" id="text-imageboard">
<p class="verse">
Available in the repository/examples/app<br>
</p>

<p>
This is a very simplified example.
The goal is to create an image collage with multiple people.
The data structure is as follows:
</p>

<p>
Adding an image is done by creating a linkpoint where the first path component indicates the name of the image.
The link tag's are decimal encoded [X, Y] coordinates.
It's ptr is a datapoint packet hash.
Building the collage is done by adding all images to a base image in 'create' order.
</p>
</div>

<ul class="org-ul">
<li><a id="orgcd03502"></a>placing images<br>
<div class="outline-text-5" id="text-orgcd03502">
<p>
TODO: Should probably add a 'prev' pointer to indicate what the user currently has.
</p>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash 
set -xeuo pipefail
if [ $# -lt 4 ]; then
    echo "Usage: img_file board_name X Y"
    exit 2
fi

IMG_FILE=$1; BOARD=$2; X=$3; Y=$4; 
shift 4

IMG_HASH=$(\
    cat $IMG_FILE \
        | lk data --write db --write stdout \
        | lk printf "{hash:str}")
TAG=$(printf "%08d%08d" $X $Y)

lk link "imgboard:$GROUP:/$BOARD" \
   -l $TAG:$IMG_HASH "$@" \
   --write db --write stdout \
    | lk printf
</pre>
</div>
</div>
</li>

<li><a id="orgcf04539"></a>viewing images<br>
<div class="outline-text-5" id="text-orgcf04539">
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail
BOARD=${1?Usage: board_name [start_stamp] }
if [[ ! -f $BOARD.png ]]; then
    magick convert -size 1000x1000 xc:transparent PNG32:$BOARD.png # Create empty canvas
fi
START_STAMP=${2:-"0"} # If no stamp is given we begin at 0, i.e. unix epoch in microseconds

# We select everything with a create field greater or equal to $START_STAMP
lk watch --index "imgboard:$GROUP:/$BOARD" -- "create:&gt;=:{u64:$START_STAMP}" \
    | lk printf "{/links:{tag:str} {ptr:str}}" \
    | while read REF; do
        X=${REF:0:8}
        Y=${REF:8:8}
        IMG_HASH=${REF: -43}
        echo "Placing $IMG_HASH at $X , $Y"
        lk watch-hash $IMG_HASH \
            | lk printf "{data}" --delimiter "" \
            | magick composite -geometry +$X+$Y - PNG32:$BOARD.png PNG32:$BOARD.png
    done
echo "$BOARD: $START_STAMP"
</pre>
</div>
</div>
</li>

<li><a id="orgbd40d27"></a>streaming images<br>
<div class="outline-text-5" id="text-orgbd40d27">
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash -x 
set -euo pipefail
GROUP=${GROUP:-"{#:pub}"}
BOARD=${1?Usage: board_name [start_stamp] }
magick convert -size 1000x1000 xc:transparent PNG32:$BOARD.png

function pull {
    lk poll-status exchange $GROUP process --write "stdout-expr:exchange - {data}"  || echo "!no exchange process active"
    echo Pulling $GROUP $BOARD
    lk pull --ttl 10m "imgboard:$GROUP:/$BOARD" --follow -- "create:&gt;:{now:-1D}" "create:&lt;:{now:+10m}" 
    sleep 600
    pull
}
pull &amp;

./imgboard-view.sh $BOARD 0 # run once

#On receiving a new packet of interest we repaint the board from that stamp
lk watch --new "imgboard:$GROUP:/$BOARD" | \
    lk printf "{create:str}" | \
    while read STAMP; do
        ./imgboard-view.sh $BOARD $STAMP
    done
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-anyhost" class="outline-2">
<h2 id="anyhost">Example Group Exchange - Anyhost</h2>
<div class="outline-text-2" id="text-anyhost">
<p class="verse">
Available in the repo/examples/exchange<br>
See repo/dev/exchange.md for some open design issues/notes.<br>
</p>

<p>
This is currently unfinished and inefficient.
Anybody can read any group/domain.
Eventually the client will add a bloom filter and counter to the query.
</p>
</div>

<ul class="org-ul">
<li><a id="orgfdd9f40"></a>anyhost client<br>
<div class="outline-text-5" id="text-orgfdd9f40">
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail
cd "$(dirname "$0")"
echo My Key $(lk key --password "" --insecure)
export SERVER=${SERVER:-${1:-"127.0.0.1:5020"}}
export GROUP_ORIG=$GROUP
export GROUP=$(lk eval "{:$GROUP/?b}")
echo Connecting $GROUP $SERVER

socat tcp:$SERVER,keepalive exec:"handshake.sh connect client_io.sh",fdout=4
#websocat -E --binary ws://$SERVER sh-c:"handshake.sh connect client_io.sh"
</pre>
</div>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# parent should set out to fd4. otherwise add a exec 4&gt;&amp;1 1&gt;&amp;2
set -euo pipefail
function fin (){
    kill $(jobs -p) 2&gt;/dev/null || true
    echo Disconnected - $THEIR_KEY 
}
trap "fin" EXIT

cd $SESSION
echo SESSION=$SESSION
echo THEIR_KEY=$THEIR_KEY
echo GROUP=$GROUP
GROUP="{b:$GROUP}"
THEIR_KEY="{b:$THEIR_KEY}"

lk link --create {u64:0} ":{#:0}:/rxlog/$THEIR_KEY" --write db
lk link --create {u64:0} ":{#:0}:/txlog/$THEIR_KEY" --write db
LAST_RX=$(lk --private watch --max 1 ":{#:0}:/rxlog/$THEIR_KEY" | lk printf {create:str})
LAST_TX=$(lk --private watch --max 1 ":{#:0}:/txlog/$THEIR_KEY" | lk printf {create:str})
lk eval "last rx {u64:$LAST_RX/s:str}\nlast tx {u64:$LAST_TX/s:str}\n"

lk set-status exchange $GROUP process anyhost-client --data "abe:OK\nPID:$$\nSESSION:$SESSION" &amp;

# save reads from stdin, ie. the server 
lk save --new db --new stdout \
    | lk printf --inspect "RX {domain:str} {path:str} {hash:str}" \
    | lk --private collect ":{#:0}:/rxlog/$THEIR_KEY" \
              --min-interval 1m \
              --forward null \
              --write db &amp;

# read the pull request made by other apps and place them into the group
lk --private watch --new "{f:exchange}:{#:0}:/pull/$GROUP:**" \
    | lk --private rewrite \
                --password "" \
                --group $GROUP \
                --write db --write stdout sign-all \
    | lk p  "&gt;&gt;&gt;&gt;new request {hash:str}\n{data}\n&lt;&lt;&lt;&lt;" &amp;


# This group exchange requires us to send all the data to the server
lk watch --bare --mode log-asc -- "group:=:$GROUP" "hop:=:{:0/u32}" \
    | lk get-links \
    | lk dedup \
    | lk printf --inspect "{now:str} SENDING {hash:str}" \
    | tee --output-error=exit &gt;( cat &gt;&amp;4 ) \
    | lk --private collect ":{#:0}:/txlog/$THEIR_KEY" \
         --min-interval 1m \
         --forward null \
         --write db &amp;

echo PIDS $(jobs -p)
wait -n
</pre>
</div>
</div>
</li>

<li><a id="orgc5083df"></a>handshake<br>
<div class="outline-text-5" id="text-orgc5083df">
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail
if [[ ${SOCAT_PEERADDR+x} ]]
   then
    export THEIR_ADDR=$SOCAT_PEERADDR:$SOCAT_PEERPORT
else
    # websocat
    export THEIR_ADDR=${WEBSOCAT_CLIENT:-$SERVER}
fi
export SESSION=$(mktemp -dt $THEIR_ADDR.XXXXX)

MODE=${1:-serve}
lk handshake --password "" \
          --write stdout --write file:$SESSION/handshake.out \
          --forward file:$SESSION/handshake.in \
          $MODE &gt;&amp;4

export THEIR_KEY=$(cat $SESSION/handshake.in | lk filter --bare --signed --max-new 1 | lk printf "{pubkey:str}")
echo Connected $THEIR_ADDR - Their Key : $THEIR_KEY 1&gt;&amp;2 
exec ${@:2} 
</pre>
</div>
</div>
</li>

<li><a id="orgbb2034f"></a>anyhost server<br>
<div class="outline-text-5" id="text-orgbb2034f">
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
set -euo pipefail

export PORT=${PORT:-"5020"}
echo My Key $(lk key --password "" --insecure)
export GROUP=$(lk eval "{:$GROUP/?b}")
echo Serving $GROUP $PORT 

trap "kill -- -$$" EXIT

socat tcp-listen:$PORT,fork exec:"handshake.sh serve serve_io.sh",fdout=4


#websocat -e -E --binary --ping-timeout 15 --ping-interval 10 \
#         ws-l:0.0.0.0:5020 sh-c:"strace -e 'trace=!all' handshake.sh serve serve_io.sh"
</pre>
</div>
<div class="org-src-container">
<pre class="src src-bash">#!/bin/bash
# parent should set out to fd4. otherwise add a exec 4&gt;&amp;1 1&gt;&amp;2
set -euo pipefail
PID=$$
function fin (){
    kill $(jobs -p) 2&gt;/dev/null || true
    echo $PID Disconnected - $THEIR_KEY 
}
trap "fin" EXIT

cd $SESSION
echo SESSION=$SESSION 
echo THEIR_KEY=$THEIR_KEY
echo GROUP=$GROUP
echo PID=$PID
GROUP="{b:$GROUP}"
THEIR_KEY="{b:$THEIR_KEY}"

lk link --create {u64:0} ":{#:0}:/rxlog/$THEIR_KEY" --write db
lk link --create {u64:0} ":{#:0}:/txlog/$THEIR_KEY" --write db
LAST_RX=$(lk --private watch --max 1 ":{#:0}:/rxlog/$THEIR_KEY" | lk printf {create:str})
LAST_TX=$(lk --private watch --max 1 ":{#:0}:/txlog/$THEIR_KEY" | lk printf {create:str})
lk eval "last rx {u64:$LAST_RX/s:str}\nlast tx {u64:$LAST_TX/s:str}\n"

# save reads from std. i.e. what the client is sending
lk save --new db --new stdout \
   --old file:&gt;( lk printf "$PID Ignored {hash:str} (old)" &gt;&amp;2 ) \
    | lk printf --inspect "$PID RX {domain:str} {path:str} {hash:str}" \
    | lk --private collect ":{#:0}:/rxlog/$THEIR_KEY" \
         --min-interval 1m \
         --forward null \
         --write db  &gt; /dev/null &amp;

# Read new request keypoints and return their content
lk watch --new "{f:exchange}:$GROUP:/pull/$GROUP:**" -- "pubkey:=:$THEIR_KEY"  \
    | lk printf --inspect "&gt;&gt;&gt;&gt;Pull req {hash:str}\n{data}\n&lt;&lt;&lt;&lt;$PID " \
    | lk multi-watch \
    | lk dedup \
    | lk printf --inspect "$PID Tx {hash:str}" &gt;&amp;4 


echo PIDS $(jobs -p)
wait -n
</pre>
</div>
</div>
</li>
</ul>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">the hash of <code>lk_datapoint(b"Hello, Sol")</code></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2023-02-23 Thu 09:10</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>