<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-06-18 Sun 10:05 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Linkspace Guide</title>
<meta name="generator" content="Org Mode" />
<link rel="icon" type="image/x-icon" href="../../images/logo2.png">
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script type="text/javascript" src="../utils.js"></script>
<link rel="stylesheet" type="text/css" href="./style.css"/>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">The Linkspace Guide</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0ccd034">Introduction</a></li>
<li><a href="#setup">Setup</a>
<ul>
<li><a href="#orgbfb5edd">Binary</a></li>
<li><a href="#org651ef6c">Package manager</a></li>
<li><a href="#org3e3d1fd">Build from source</a>
<ul>
<li><a href="#orgd932a6c">User</a></li>
<li><a href="#orgf8116fd">Development</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#api">API overview</a></li>
<li><a href="#Point">Point</a>
<ul>
<li><a href="#lk_datapoint">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
<li><a href="#org9816726">Fields</a></li>
<li><a href="#orgdc1bd40">Notes</a></li>
<li><a href="#orgf928efd">lk_write and lk_read</a></li>
</ul>
</li>
<li><a href="#ABE">ABE</a>
<ul>
<li><a href="#orgdf36ffe">Parsing</a></li>
<li><a href="#org231a4db">lk_eval</a>
<ul>
<li><a href="#org8189cd3">Sub-expressions</a>
<ul>
<li><a href="#orgaea699a">Functions</a></li>
<li><a href="#org1fe94c0">Macros</a></li>
</ul>
</li>
<li><a href="#org7b58301">Scope &amp; Context</a>
<ul>
<li><a href="#org4ec593f">Argv</a></li>
<li><a href="#org962bf16">Packet</a></li>
<li><a href="#org7468958">Linkspace</a></li>
</ul>
</li>
<li><a href="#org5423727">Usage notes</a></li>
<li><a href="#abe-help">Help</a></li>
</ul>
</li>
<li><a href="#lk_encode">lk_encode</a>
<ul>
<li><a href="#org3160e6b">DEFAULT_FMT</a></li>
</ul>
</li>
<li><a href="#lk_split_abe">lk_split_abe</a></li>
<li><a href="#ABELNS">LNS</a></li>
</ul>
</li>
<li><a href="#Query">Query</a>
<ul>
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
<li><a href="#org36d2928">More on predicates</a>
<ul>
<li><a href="#predicatelist">Predicates &amp; options</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linkspace">Linkspace</a>
<ul>
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_get">lk_get</a></li>
<li><a href="#lk_get_all">lk_get_all</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
<li><a href="#lk_close_watch">lk_close_watch</a></li>
</ul>
</li>
<li><a href="#Conventions">Conventions</a>
<ul>
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul>
</li>
<li><a href="#lns">LNS</a></li>
<li><a href="#qa">Q&amp;A</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#orgc6c02a0">Why Big Endian?</a></li>
<li><a href="#org8fcb2f1">Every user of my domain app needs X from my server/I want to add advertisements to my domain app.</a></li>
<li><a href="#org3e617cc">I'm not in control of the user! / Anybody in my group can leak data from it!?</a></li>
<li><a href="#orgda3c440">A domain application can write outside its own domain space.</a></li>
<li><a href="#org027b5cb">Why not use an SQL backend? / Why invent queries?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
<p class="verse">
This document is kept up to date on a best effort basis.<br>
Sometimes the Rust <a href="../cargo-doc/linkspace/index.html">linkspace</a> docs is ahead of this guide.<br>
</p>

<p>
This is a technical document describing linkspace protocol, library, and how they fit together.
You should be familiar with the <a href="../../basics.html">basics</a>.
If you're interested in how linkspace solves your problems checkout the <a href="../tutorial/index.html">tutorials</a>.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk --version
</pre>
</div>

<pre class="example" id="orge81d183">
linkspace-cli linkspace-cli v0.3.0 debug build from 37932780208e52d657a257b8607c003117e26fc9 (main)
</pre>

<div id="outline-container-org0ccd034" class="outline-2">
<h2 id="org0ccd034">Introduction</h2>
<div class="outline-text-2" id="text-org0ccd034">
<p>
Linkspace is a packet format and processing library.
Instead of providing an API to consume streams of data, linkspace takes a different path.
Packets of bytes are hashed, named, saved, and can reference other packets.
</p>

<p>
This gives us a thin and powerful stack to build multiparty applications.
<a href="../cargo-doc/linkspace/index.html">linkspace</a> is the authoritative implementation.
</p>

<p>
Projects such as Git, BitTorrent, Matrix, IPFS, and various blockchains already prove that addressing content by hash is a powerful abstraction.
This abstraction sidesteps or solves a number of difficulties inherent in organizing data.
If entries include hashes to other entries I consider it a supernet<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>

<p class="verse">
Supernet  [ˈsü-pərˌnet]<br>
<br>
A self-referential multi-participant data organization protocol whose primary<br>
addressing method uses hashes instead of endpoint identifiers.<br>
A communication protocol where the method of exchange is an extraneous concern.<br>
e.g. git, bitcoin, linkspace<br>
</p>

<p>
The supernet paradigm is a trade-off.
Instead of processing ordered streams of network data, an application is a function over the partial view of interlinked state.
This has upsides<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> and downsides.
</p>

<p>
One issue with supernets built so far is that they are bound to their use-case.
Linkspace is a general purpose supernet.
A developer claims a domain name like they would a port number, and their application can run for any group of users.
Linkspace is designed to be fast and has a small API.
</p>

<p>
It consists of 4 concepts.
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> - Bytes that are named and reference other points by hash. Together with its hash and netheader form a packet.</li>
<li><a href="#ABE">ABE</a> - (Byte) templating for convenience.</li>
<li><a href="#Query">Query</a> - A list of predicates and options for selecting packets.</li>
<li><a href="#linkspace">Linkspace</a> - A multi-reader single-writer database for saving, and to query for existing and reacting to new packets.</li>
</ul>

<p>
Common challenges are addressed by a set of <a href="#Conventions">Conventions</a>.
</p>
</div>
</div>

<div id="outline-container-setup" class="outline-2">
<h2 id="setup">Setup</h2>
<div class="outline-text-2" id="text-setup">
<p>
This guide uses Python and (Bash) CLI snippets.
</p>
</div>

<div id="outline-container-orgbfb5edd" class="outline-3">
<h3 id="orgbfb5edd">Binary</h3>
<div class="outline-text-3" id="text-orgbfb5edd">
<p>
The <a href="https://github.com/AntonSol919/linkspace/releases">zip</a> contains the CLI and python library and the examples used in this document.
</p>
</div>
</div>

<div id="outline-container-org651ef6c" class="outline-3">
<h3 id="org651ef6c">Package manager</h3>
<div class="outline-text-3" id="text-org651ef6c">
<p>
<code>cargo +nightly install linkspace-cli</code>
</p>

<p>
<code>pip install linkspace</code>
</p>
</div>
</div>

<div id="outline-container-org3e3d1fd" class="outline-3">
<h3 id="org3e3d1fd">Build from source</h3>
<div class="outline-text-3" id="text-org3e3d1fd">
</div>
<div id="outline-container-orgd932a6c" class="outline-4">
<h4 id="orgd932a6c">User</h4>
<div class="outline-text-4" id="text-orgd932a6c">
<p>
<code>make install-lk install-python</code>
</p>
</div>
</div>

<div id="outline-container-orgf8116fd" class="outline-4">
<h4 id="orgf8116fd">Development</h4>
<div class="outline-text-4" id="text-orgf8116fd">
<p>
<code>source ./activate</code> builds and sets PATH and PYTHONPATH env variables.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-api" class="outline-2">
<h2 id="api">API overview</h2>
<div class="outline-text-2" id="text-api">
<p>
The linkspace API is a small set of functions that is mostly stable.
It is available as a Rust crate <code>linkspace</code> and binding for other languages follow the same API.
</p>

<p>
It consists of the following functions:
</p>

<ul class="org-ul">
<li><a href="#Point">Point</a> creation
<ul class="org-ul">
<li><a href="#lk_datapoint">lk_datapoint</a></li>
<li><a href="#lk_linkpoint">lk_linkpoint</a></li>
<li><a href="#lk_keypoint">lk_keypoint</a></li>
</ul></li>

<li><a href="#ABE">ABE</a> - (Byte) templating for convenience
<ul class="org-ul">
<li><a href="#org231a4db">lk_eval</a></li>
<li><a href="#lk_encode">lk_encode</a></li>
</ul></li>

<li><a href="#Query">Query</a> - Addressing and filtering of packets with predicates and options
<ul class="org-ul">
<li><a href="#lk_query">lk_query</a></li>
<li><a href="#lk_query_parse">lk_query_parse</a></li>
<li><a href="#lk_query_push">lk_query_push</a></li>
<li><a href="#lk_query_print">lk_query_print</a></li>
</ul></li>

<li><a href="#linkspace">Linkspace</a> - A runtime to save and query for old and new packets.
<ul class="org-ul">
<li><a href="#lk_open">lk_open</a></li>
<li><a href="#lk_save">lk_save</a></li>
<li><a href="#lk_get">lk_get</a></li>
<li><a href="#lk_get_all">lk_get_all</a></li>
<li><a href="#lk_watch">lk_watch</a></li>
<li><a href="#lk_process">lk_process</a></li>
<li><a href="#lk_process_while">lk_process_while</a></li>
</ul></li>

<li><a href="#Conventions">Conventions</a> - Functions following a convention build on top of the core functions.
<ul class="org-ul">
<li><a href="#lk_status_set">lk_status_set</a></li>
<li><a href="#lk_status_poll">lk_status_poll</a></li>
<li><a href="#lk_pull">lk_pull</a></li>
<li><a href="#lk_key">lk_key</a></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-Point" class="outline-2">
<h2 id="Point">Point</h2>
<div class="outline-text-2" id="text-Point">
<p class="verse">
<a href="../cargo-doc/linkspace/point/index.html">Rust docs</a><br>
</p>

<p>
Points are the basic units in linkspace.
They carry data, link to other points, and might contain information about the who, what, when, and how.
There are 3 kinds of points. datapoints, linkpoints, and keypoints.
A point has a maximum size of 2<sup>16</sup>-512 bytes.
</p>

<p>
Building a point is always combined with generating a hash and prepending a netheader.
Together the [netheader, hash, point] form a packet.
Functions usually deal with packet.
</p>
</div>

<div id="outline-container-lk_datapoint" class="outline-3">
<h3 id="lk_datapoint">lk_datapoint</h3>
<div class="outline-text-3" id="text-lk_datapoint">
<div class="ctabs" id="org6d27630">
<div class="sh" id="org19ca9fb">
<p>

</p>

<div class="org-src-container">
<pre class="src src-bash">echo -n "Hello, Sol" | lk data | lk pktf "[hash:str]\n[data]"
</pre>
</div>

<pre class="example" id="org5519c26">
shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
Hello, Sol
</pre>

</div>

<div class="py" id="orgcec2c41">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">from linkspace import *
datap = lk_datapoint(b"Hello, Sol")
lk_eval2str("[hash:str] = [data]", datap)
</pre>
</div>

<pre class="example" id="orgf19cf98">
RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0 = Hello, Sol
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_linkpoint" class="outline-3">
<h3 id="lk_linkpoint">lk_linkpoint</h3>
<div class="outline-text-3" id="text-lk_linkpoint">
<p>
A linkpoint creates relations between packets by their hash and its location.
</p>

<p>
It consists of these fields:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Group<sub>32</sub></td>
<td class="org-left">the intended recipients.</td>
</tr>

<tr>
<td class="org-left">Domain<sub>16</sub></td>
<td class="org-left">the intended application.</td>
</tr>

<tr>
<td class="org-left">Path<sub>var&lt;240</sub></td>
<td class="org-left">Sequence of bytes. e.g. '/dir1/dir2/thing'</td>
</tr>

<tr>
<td class="org-left">Stamp<sub>8</sub></td>
<td class="org-left">Big endian UNIX timestamp in microseconds.</td>
</tr>

<tr>
<td class="org-left">Links<sub>48*n</sub></td>
<td class="org-left">A variable length list of (Tag<sub>16</sub>, Pointer<sub>32</sub>)</td>
</tr>

<tr>
<td class="org-left">-Link[0]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[1]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[2]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">-Link[&#x2026;]<sub>48</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Data<sub>var&lt;2<sup>16</sup></sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Each (Domain,Group) is a 'tree', and each (Domain,Group,Path) is a packets 'location'.
</p>

<p>
All values, including the Path, contain arbitrary bytes.
</p>

<p>
An entire point can be 2<sup>16</sup>-512 bytes in size. The header is always 4 bytes.
A data point can hold a maximum of 2<sup>16</sup>-512-4 bytes.
This space is shared between the links and data so beware that too much data and links won't fit into a single packet
<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<p class="verse">
Packet hashes, GroupID's, and public keys are 32 bytes.<br>
They are usually encoded in URL-safe no-padding base64, e.g. <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code>.<br>
These hashes quickly make things unreadable.<br>
The <code>[...]</code> syntax (<a href="#ABE">ABE</a>) allows us to name and manipulate bytes.<br>
This following example shows that <code>[#:pub]</code> resolves to the bytes <code>RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF</code> in both the Group and the second link<br>
Furthermore, If no group was provided it defaults to <code>[#:pub]</code><br>
</p>

<p>
Datapoints do not have a 'create' field, so they get the same hash given the same data.
If we had forced a specific 'create' stamp for both the python and bash example it would have produced the same hash for both.
Instead, 'create' defaults to the current time ( microseconds since epoch ), and thus the hash is different.
</p>

<div class="ctabs" id="org6abab9f">
<div class="sh" id="orgbbad2ef">
<p>

</p>

<p>
The command <code>lk link</code> builds a linkpoint packets and output's it to stdout by default.
Whenever a cli commands deal with (domain, group, path) tuples, they are set from the first argument: <code>DOMAIN:GROUP:PATH</code>.
Here two links are added with the tags <code>first_tag_1</code> and <code>another_tag</code>.
</p>


<div class="org-src-container">
<pre class="src src-bash">lk link "a_domain:[#:pub]:/dir1/dir2/thing" -- \
          first_tag_1:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0 \
          another_tag:[#:pub] \
| lk pktf

</pre>
</div>

<pre class="example" id="orgbce28d1">
type	LinkPoint
hash	ka0VpUnbGBGMU6H9FyBoPx0GKDhONIGMQnSRV1y7KuE
group	[#:pub]
domain	a_domain
path	/dir1/dir2/thing
pubkey	[@:none]
create	1687075529329806
links	2
	first_tag_1 RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	another_tag RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0

data	0
</pre>

<div class="org-src-container">
<pre class="src src-bash">echo hello | lk link my_domain --data-stdin | lk pktf
</pre>
</div>

<pre class="example" id="org8a293a1">
type	LinkPoint
hash	X5wc1IBctBaj85bHI_s2zXKlBR0biDR5r5dNKH0FF1w
group	[#:test]
domain	my_domain
path	
pubkey	[@:none]
create	1687075529350967
links	0

data	6
hello
</pre>

</div>


<div class="py" id="org0714af7">
<p>

</p>

<p>
The API deals with arbitrary bytes, not encoded strings.
In python, we have 4 common ways to get bytes.
</p>

<ul class="org-ul">
<li><code>"some string".encode()"</code></li>
<li>the <code>b"byte notation"</code></li>
<li>fields like <code>apkt.group</code>, <code>apkt.hash</code> <code>apkt.domain</code> etc</li>
<li>evaluate an ABE string with <a href="#org231a4db">lk_eval</a>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">ptr1 = lk_eval("[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]")
link1 = Link(tag=b"first tag 1",ptr=ptr1)

ptr2 = lk_eval("[#:pub]")
link2 = Link(b"another tag",ptr2)

assert(link1.ptr == link2.ptr)

datap = lk_datapoint(b"Hello example");
link3 = Link(b"a datapacket",datap.hash)

linkp = lk_linkpoint(
    domain=b"example-domain",
    group=lk_eval("[#:pub]"),
    data=b"Hello, World!",
    links=[link1,link2,link3]
)
str(linkp)
</pre>
</div>

<pre class="example" id="org11d4ccb">
type	LinkPoint
hash	A2ElzknaWjDRhwyfmgJOAyAaUlWQXdxgA0CLxPgktQE
group	[#:pub]
domain	example-domain
path	
pubkey	[@:none]
create	1687075529473041
links	3
	first tag 1 RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	another tag RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
	a datapacket Y1DQDTA7NP1f6IwzPW2wKF6duXw00fE5fR30WhJz6pg

data	13
Hello, World!
</pre>

</div>

</div>
</div>
</div>



<div id="outline-container-lk_keypoint" class="outline-3">
<h3 id="lk_keypoint">lk_keypoint</h3>
<div class="outline-text-3" id="text-lk_keypoint">
<p>
A key point is a linkpoint with an additional publickey and signature.
</p>

<p>
There are functions to generate, encrypt, and decrypt a linkspace key.
Leaving you to deal with the saving.
Alternatively there is the <a href="#lk_key">lk_key</a> function that does it all for you.
With the added benefit that you can address your own public key as <code>[@:me:local]</code>.
</p>

<div class="ctabs" id="org469fbb9">
<div class="sh" id="orgdc843a4">
<div class="org-src-container">
<pre class="src src-bash">export LK_DIR=/tmp/linkspace
lk --init key --decrypt-cost 0 --password "my secret" # remove the --decrypt-cost. it speeds up building this doc
</pre>
</div>

<pre class="example" id="org5a797ca">
$argon2d$v=19$m=8,t=1,p=1$b9b7M7vBkPf5E59YBo7uq+0U0CmF98OEvAuea0DDUDw$w9kkvk9akrrgcws8zqCxixUN1aRvZt87PptFOMx82DU
b9b7M7vBkPf5E59YBo7uq-0U0CmF98OEvAuea0DDUDw
</pre>

<div class="org-src-container">
<pre class="src src-bash">lk keypoint "example::" --password "my secret" | lk pktf
</pre>
</div>

<pre class="example" id="org897189e">
type	KeyPoint
hash	EJVqtrd0b0sQv6NfmgvyLAk_RykfNDhhx2675gtpt_Q
group	[#:test]
domain	example
path	
pubkey	[@:me:local]
create	1687075529546300
links	0

data	0
</pre>

<p class="verse">
The CLI also accepts <code>lk link --sign</code> instead of <code>lk keypoint</code><br>
</p>

</div>
<div class="py" id="orge90906b">
<div class="org-src-container">
<pre class="src src-python">lk = lk_open("/tmp/linkspace",create=True)
key = lk_key(lk,b"my secret");
example_keypoint = lk_keypoint(key=key,domain=b"example")
str(example_keypoint)
</pre>
</div>

<pre class="example" id="org3ba1920">
type	KeyPoint
hash	gAjzQsOOOqI4Ve2oeXrKFBhsTgyv-C7XUnHKNr5AGjo
group	[#:pub]
domain	example
path	
pubkey	[@:me:local]
create	1687075529648438
links	0

data	0

</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-org9816726" class="outline-3">
<h3 id="org9816726">Fields</h3>
<div class="outline-text-3" id="text-org9816726">
<p>
In python you can access these fields directly as bytes.
Fields are not writable because they are included in the hash.
</p>

<div class="org-src-container">
<pre class="src src-python">[attr for attr in dir(lk_linkpoint())  if not "__" in attr]
</pre>
</div>

<pre class="example" id="org8659148">
['create', 'data', 'domain', 'group', 'hash', 'hop', 'ipath', 'links', 'netflags', 'path', 'path0', 'path1', 'path2', 'path3', 'path4', 'path5', 'path6', 'path7', 'path_len', 'path_list', 'pkt_type', 'point_size', 'pubkey', 'recv', 'signature', 'size', 'stamp', 'ubits0', 'ubits1', 'ubits2', 'ubits3', 'until']
</pre>

<p>
Where path[0..7] are the path components, 
</p>

<p class="verse">
Some <a href="#predicatelist">fields</a> we've not seen so far are writable, but they are not relevant for most applications.<br>
</p>
</div>
</div>


<div id="outline-container-orgdc1bd40" class="outline-3">
<h3 id="orgdc1bd40">Notes</h3>
<div class="outline-text-3" id="text-orgdc1bd40">
<p>
Groups signals the intended set of recipients.
Domains signal the activity, and practically the application used to present an interface to the user.
</p>

<p>
The groups bytes are simply chosen and membership is enforced by its members.
They exist because we say they exist.
It's up to the user (or some to be build management tool) to pick a method of data exchange.
Group bytes can be chosen to have a special meaning, such as public key or a pointer to a list of publickeys that act as group administrators.
</p>

<p>
The following do have a meaning.
The [0;32] null group ( <code>[#:0]</code> ), i.e. the local only group, is never transmitted to other devices and is never accepted from outside sources.
Everything in the <code>[#:pub]</code> group<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup> is meant for everybody. e.g. the public.
</p>

<p>
By convention the group created by pubkey1 XOR pubkey2 forms a group with those keys as its only two members.
</p>

<p class="verse">
The <code>[#:...]</code> is part of the <a href="#lns">LNS</a>.<br>
A public registry for assigning names and naming rights.<br>
e.g. <code>[#:sales:mycomp:com]</code> for groups and <code>[@:alicekey:mycomp:com]</code> for keys.<br>
</p>
</div>
</div>


<div id="outline-container-orgf928efd" class="outline-3">
<h3 id="orgf928efd">lk_write and lk_read</h3>
<div class="outline-text-3" id="text-orgf928efd">
<p>
Serialize / Deserialize from the byte representation.
A domain application rarely has to deal with this representation.
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">bytes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">32</td>
<td class="org-left">netheader (routing)</td>
</tr>

<tr>
<td class="org-right">32</td>
<td class="org-left">hash</td>
</tr>

<tr>
<td class="org-right">var</td>
<td class="org-left">point content</td>
</tr>
</tbody>
</table>

<div class="ctabs" id="org5eb85c7">
<div class="py" id="org97ee17e">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">datap = lk_datapoint("hello")
linkp = lk_linkpoint()
keyp = lk_keypoint(key)
packet_bytes = lk_write(datap) + lk_write(linkp) + lk_write(keyp)
print(len(packet_bytes),packet_bytes)

# read the bytes as packets
(p1, packet_bytes)= lk_read(packet_bytes)
(p2, packet_bytes)= lk_read(packet_bytes)
(p3, packet_bytes)= lk_read(packet_bytes)

assert(p1 == datap)
assert(p2 == linkp)
assert(p3 == keyp)
</pre>
</div>

<pre class="example" id="orgeaa2f66">
465 b'LK1\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\xd3\x9c\xefV\xe9&lt;p\x1d\x0b\xf2\x7f\xe2\xe8\xb4z\xeb\\\x1a\x90\xd0U\xc2&amp;\xdd7\xd6i2\xe3t\xc9\x00\x01\x00\thelloLK1\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbd\xce"g\xfd\x13\xe4\xc2\xb7lC;\xa0z\xd7V_\xca0\xee\xe1L\x8d\x80\x13?dQ\xb0\x96|\xbd\x00\x03\x00@\x00@\x00@\x00\x05\xfeb\xe1\xab*\x1aD=\xe5\xb4\xe8^\x1b\x80\xab\x06\xea\xd42{g\x85\x9f\x0f\xb5\x9e\xb2\x01\x81\x7f\x0b[\xab(ft\x04\x1d\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00LK1\x00\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb0vk\x98(o\xe6\x1bJ\x064\xc9\xef\xac\xe2c\x92\xf78\x9d!X\xb2\xf6\t2\xeb\xdb,&amp;\xc0\xc8\x00\x07\x00\xc8\x00\x00\x00\x00o\xd6\xfb3\xbb\xc1\x90\xf7\xf9\x13\x9fX\x06\x8e\xee\xab\xed\x14\xd0)\x85\xf7\xc3\x84\xbc\x0b\x9ek@\xc3P&lt;\x85\x03\x82$\xa3fey\xcd\xb8k\xfa\x1f`-~I\x0c\xa5F&amp;:\'\x07\xacWjc}C\xa2\xa9\xf6\xb7\xe9\x9a\xf6|\xb14o\x1dF-\xf3\x14lNC\xc5)\x97cm_\xee\x8a@\xea?[N\xc5\xdb`\x9b\x1f@\x8c\xa5G\xd2\x1e7\x81\x83\x81\x93\x0f\xae\x93%\xfdJ)\x1c+\x0f\xe82]\xf5\xa5\xdb\xd3\x1d\x00\x03\x00@\x00@\x00@\x00\x05\xfeb\xe1\xab*/D=\xe5\xb4\xe8^\x1b\x80\xab\x06\xea\xd42{g\x85\x9f\x0f\xb5\x9e\xb2\x01\x81\x7f\x0b[\xab(ft\x04\x1d\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
</pre>

</div>
<div class="bash" id="org70e2a4e">
<p>
The CLI automatically reads and writes in packet format from the relevant pipes.
</p>
<div class="org-src-container">
<pre class="src src-bash">echo datapoint:
echo -n hello | lk data | tee /tmp/pkts | xxd 
echo linkpoint:
echo -n hello | lk link my_domain:[#:pub]:/hello/world -- link1:[#:0] link2:[#:test] | tee -a /tmp/pkts | xxd 
echo keypoint:
echo -n hello | lk keypoint --password "my secret" my_domain:[#:pub]:/hello/world -- link1:[#:0] link2:[#:test] | tee -a /tmp/pkts | xxd 
cat /tmp/pkts | lk pktf [hash:str]
</pre>
</div>

<pre class="example" id="org5d00ca6">
datapoint:
00000000: 4c4b 3100 0000 0000 ffff ffff ffff ffff  LK1.............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: acd3 9cef 56e9 3c70 1d0b f27f e2e8 b47a  ....V.&lt;p.......z
00000030: eb5c 1a90 d055 c226 dd37 d669 32e3 74c9  .\...U.&amp;.7.i2.t.
00000040: 0001 0009 6865 6c6c 6f                   ....hello
linkpoint:
00000000: 4c4b 3100 0000 0000 ffff ffff ffff ffff  LK1.............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: e555 f418 59f1 9ced 4379 0a16 9d67 400a  .U..Y...Cy...g@.
00000030: 5255 c8c9 9020 e1d5 08f9 c1a8 acf5 ed79  RU... .........y
00000040: 0003 00b4 00a0 00b4 0005 fe62 e1ab f8a2  ...........b....
00000050: 443d e5b4 e85e 1b80 ab06 ead4 327b 6785  D=...^......2{g.
00000060: 9f0f b59e b201 817f 0b5b ab28 6674 041d  .........[.(ft..
00000070: 0000 0000 0000 006d 795f 646f 6d61 696e  .......my_domain
00000080: 0000 0000 0000 0000 0000 006c 696e 6b31  ...........link1
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 006c 696e 6b32  ...........link2
000000c0: 7fbf c6fa 75e6 5767 b6c7 e5f5 12a5 a503  ....u.Wg........
000000d0: bb33 72c8 b780 ca75 72a3 9e87 ff5b 4f44  .3r....ur....[OD
000000e0: 0206 0c0c 0c0c 0c0c 0568 656c 6c6f 0577  .........hello.w
000000f0: 6f72 6c64                                orld
keypoint:
00000000: 4c4b 3100 0000 0000 ffff ffff ffff ffff  LK1.............
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 282a 475c a60a c534 6c39 5271 7663 d354  (*G\...4l9Rqvc.T
00000030: 0d0a 21be 5234 7a72 7f11 d449 a82c e969  ..!.R4zr...I.,.i
00000040: 0007 013c 0000 0000 6fd6 fb33 bbc1 90f7  ...&lt;....o..3....
00000050: f913 9f58 068e eeab ed14 d029 85f7 c384  ...X.......)....
00000060: bc0b 9e6b 40c3 503c 2b6f 1c87 b963 9776  ...k@.P&lt;+o...c.v
00000070: 175d 0e85 cf64 0c67 a114 4aea 3ac4 1343  .]...d.g..J.:..C
00000080: 0323 46ff 3d3b 99fa ea47 18c6 708b a842  .#F.=;...G..p..B
00000090: 481b 89fa 4636 9323 ac20 dd65 00e9 374b  H...F6.#. .e..7K
000000a0: 71c8 e75c 0d0f f2c1 a76a d17b 4385 d9ea  q..\.....j.{C...
000000b0: 6955 e7c7 8531 4ab1 9478 0eb9 bddf ddb2  iU...1J..x......
000000c0: 257d f20c e69d 76f3 0003 00b4 00a0 00b4  %}....v.........
000000d0: 0005 fe62 e1ac 1ab4 443d e5b4 e85e 1b80  ...b....D=...^..
000000e0: ab06 ead4 327b 6785 9f0f b59e b201 817f  ....2{g.........
000000f0: 0b5b ab28 6674 041d 0000 0000 0000 006d  .[.(ft.........m
00000100: 795f 646f 6d61 696e 0000 0000 0000 0000  y_domain........
00000110: 0000 006c 696e 6b31 0000 0000 0000 0000  ...link1........
00000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000140: 0000 006c 696e 6b32 7fbf c6fa 75e6 5767  ...link2....u.Wg
00000150: b6c7 e5f5 12a5 a503 bb33 72c8 b780 ca75  .........3r....u
00000160: 72a3 9e87 ff5b 4f44 0206 0c0c 0c0c 0c0c  r....[OD........
00000170: 0568 656c 6c6f 0577 6f72 6c64            .hello.world
rNOc71bpPHAdC_J_4ui0eutcGpDQVcIm3TfWaTLjdMk
5VX0GFnxnO1DeQoWnWdAClJVyMmQIOHVCPnBqKz17Xk
KCpHXKYKxTRsOVJxdmPTVA0KIb5SNHpyfxHUSags6Wk
</pre>

</div>

</div>




<p>
Unless you're writing an exchange process, a developer shouldn't have to deal with this level of IO.
</p>
</div>
</div>
</div>

<div id="outline-container-ABE" class="outline-2">
<h2 id="ABE">ABE</h2>
<div class="outline-text-2" id="text-ABE">
<p class="verse">
<a href="../cargo-doc/linkspace/abe/index.html">Rust docs</a><br>
</p>

<p>
ABE (Ascii-Byte-Expr) is a tiny byte templating language.
A stringly representation of delimited bytes ( of the type: <code>[ ( [u8], delimiter ) ]</code> ).
Its primary purpose is to make it easy for developers to read and write sequences of bytes (0..=255) in plain ascii, including the <code>null</code> (0) byte.
In addition, it supports evaluation of functions that act as shorthand for long sequences of bytes. 
</p>

<p>
Linkspace has no concept of encoding.
Fields have a fixed length or prefix their exact length.
</p>

<p>
ABE is used for things like <a href="#Query">Query</a>, <a href="#org3160e6b">printing</a>, and in most arguments for the cli.
</p>

<p>
ABE is not meant to be a proramming language!
It's primarily meant to read and write arbitrary bytes in some context and quickly beat them into a desired shape.
Some things are limited by design.
If there is no obvious way to do something use a general purpose language to deal with your use-case.
</p>

<p>
When building an application you can choose where to use ABE and when to use a different encoding.
</p>
</div>

<div id="outline-container-orgdf36ffe" class="outline-3">
<h3 id="orgdf36ffe">Parsing</h3>
<div class="outline-text-3" id="text-orgdf36ffe">
<ul class="org-ul">
<li>Most printable ascii letters are as is.</li>
<li>Newline and Tab are external delimiters. Separating two blocks.</li>
<li><code>:</code> and <code>/</code> are internal delimiters. Separating two byte expressions.</li>
<li><code>[</code> and <code>]</code> wrap an expression</li>
<li><code>:</code>, <code>/</code>, <code>\</code>, <code>[</code>, <code>]</code>  can be escaped with a <code>\</code>. (Use <code>'\n'</code> and <code>'\t'</code> for newline and tab )</li>
<li><code>\x00</code> up-to <code>\xFF</code> for bytes.</li>
<li><code>\0</code> equals  <code>\x00</code>,  <code>\f</code> equals <code>\xFF</code></li>
</ul>

<p>
We can encode binary into valid abtxt as follows:
</p>
<p class="verse">
We'll get back to <a href="#lk_encode">encode</a> later.<br>
</p>

<div class="ctabs" id="orgfbceba7">
<div class="bash" id="orgd89e498">
<div class="org-src-container">
<pre class="src src-bash">printf "hello" | lk encode -i
printf "world/" | lk encode -i
printf "nl \n tab \t" | lk encode -i
printf "open [ close ]" | lk encode -i
printf "emoji ⌨" | lk encode -i
</pre>
</div>

<pre class="example" id="org28d3f99">
hello
world\/
nl \n tab \t
open \[ close \]
emoji \xe2\x8c\xa8
</pre>

</div>

<div class="py" id="org8f632f3">
<p>
All packet fields are arbitrary bytes, and lk_encode can print them as ab text
</p>

<div class="org-src-container">
<pre class="src src-python">multiline = """newline
tab	""".encode()

lkp = lk_linkpoint(path=[b"hello",b"world/",multiline,b"open [ close ]"])]) # encode implies utf-8

print(lk_encode(lkp.path0),"\t",list(lkp.path0))
print(lk_encode(lkp.path1),"\t",list(lkp.path1))
print(lk_encode(lkp.path2),"\t",list(lkp.path2))
print(lk_encode(lkp.path3),"\t",list(lkp.path3))
print(lk_encode(lkp.path4),"\t",list(lkp.path4), lkp.path4.decode("utf-8"))
</pre>
</div>

</div>

</div>
</div>
</div>


<div id="outline-container-org231a4db" class="outline-3">
<h3 id="org231a4db">lk_eval</h3>
<div class="outline-text-3" id="text-org231a4db">
<p>
ABE is evaluated by substituting an expressions ( <code>[..]</code> ) with its result.
For example in <code>[u8:97]</code>, the function 'u8' parses "97" and prints it.
The byte 99 equals the character 'c'.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk eval "ab[u8:99]" | xxd
</pre>
</div>

<pre class="example" id="orgf093aff">
00000000: 6162 63                                  abc
</pre>

<p>
The result of an ABE is a list of (bytes, ?delimiter). 
</p>

<div class="org-src-container">
<pre class="src src-bash">lk eval --json "h[u8:101]ll[u8:111] / world:etc" 
</pre>
</div>

<pre class="example" id="org580e107">
[["hello ","/"],[" world",":"],["etc",null]]
</pre>

<p>
Note that bytes are joined after evaluating. In the example this results in the component <code>('hello ', /)</code>.
The delimiters ('\n' '\t' ':' '/') are interpreted depends on the context.
In the top level of the template given to <code>lk eval</code> they are printed as is.
</p>

<p>
In other words: <code>eval "hello/:[u8:99]\n"</code> == <code>hello/:c\n</code> ,
but within brackets they have a special meaning:  <code>eval "hello/:[hello/ \n :]"</code> will error.
</p>

<p class="verse">
The rest of this chapter goes further in depth.<br>
Knowing ABE is extremely powerful, but is not requirement to use the linkspace library.<br>
<br>
In python you can stick to using bytes objects, and where possible the cli accepts a base64 string, etc.<br>
<br>
ABE a language of convenience, but not trivial to learn.<br>
With basic knowledge of its purpose, expression substitution (<code>[..]</code>), and the <code>':'</code>, <code>'/'</code> delimiters,<br>
the rest of the guide (starting at <a href="#Query">Query</a>) can be read while you return here for reference in case something is unclear.<br>
</p>
</div>


<div id="outline-container-org8189cd3" class="outline-4">
<h4 id="org8189cd3">Sub-expressions</h4>
<div class="outline-text-4" id="text-org8189cd3">
<p>
A list of functions/macros be found by evaluating
<a href="#abe-help">[[help</a>][\[help\]]].
</p>
</div>

<div id="outline-container-orgaea699a" class="outline-5">
<h5 id="orgaea699a">Functions</h5>
<div class="outline-text-5" id="text-orgaea699a">
<ul class="org-ul">
<li><code>[fn]</code></li>
<li><code>[fn:arg0]</code></li>
<li><code>[fn:arg0:arg1]</code></li>
</ul>

<p>
The arguments are plain bytes. A function can take upto 8 arguments.
Usually the results is concatenated with its surrounding bytes.
The empty function <code>'[:...]'</code> resolves to its first argument.
</p>

<ul class="org-ul">
<li><code>hello [:world]</code> == <code>hello world</code></li>
</ul>

<p>
Arguments are evaluated before application.
<code>[fn0:[fn1]]</code> will call fn1 and use its result as the first argument to fn0.
</p>

<p>
You can chain results with <code>/</code>.
It uses the result as the first argument to the next function.
</p>

<ul class="org-ul">
<li><code>[:97/u8]</code> <code>= ~[u8:97]~ =</code> <code>a</code></li>
<li><code>[:97/u8/?u]</code> <code>= ~[?u:[u8:97]]~ =</code> <code>97</code></li>
</ul>

<p>
You can think of ABE functions as a translation of conventional function calling.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>[name:arg1:arg2]</code></td>
<td class="org-left"><code>name(arg1,arg2)</code></td>
</tr>

<tr>
<td class="org-left"><code>[name:[other_name:argA]:arg2]</code></td>
<td class="org-left"><code>name( other_name(argA) , arg2 )</code></td>
</tr>

<tr>
<td class="org-left"><code>[other_name:argA/name:arg2]</code></td>
<td class="org-left"><code>name ( other_name(argA) , arg2 )</code></td>
</tr>
</tbody>
</table>

<p class="verse">
Functions are aware if they are first or not.<br>
The vast majority of functions do not care.<br>
</p>

<p class="verse">
<code>[[:u8]:97]</code> is explicitly not allowed. Variable function identifiers are conceptually interesting but practically begging for bugs.<br>
</p>

<p>
Note: describing ABE can be a bit tricky in relation to conventional languages.
Specifically, there is no syntax to "reference" a function, they are always resolved to their result.
i.e. <code>fn name(){..}; let x = name; let y = name();</code> has the <code>()</code> syntax to differentiate between calling a function or referencing a value.
There are no 'variables' by design, because ABE is not meant to be used that way.
</p>
</div>
</div>


<div id="outline-container-org1fe94c0" class="outline-5">
<h5 id="org1fe94c0">Macros</h5>
<div class="outline-text-5" id="text-org1fe94c0">
<p>
The second type of operation is applying a macro.
Whereas functions are called after their arguments are evaluated.
Macros are called <span class="underline">as is</span> up until its matching ']' without evaluation <code>[..]</code> expressions.
</p>

<ul class="org-ul">
<li><code>[/a_macro]</code></li>
<li><code>[/a_macro:arg0:arg1]</code></li>
<li><code>[/a_macro:[fn:arg0]:arg1/hello]</code></li>
</ul>

<p>
The <code>/a_macro</code> macro operates on <code>:[fn:arg0]:arg1/hello</code> without it being evaluated.
</p>
</div>
</div>
</div>


<div id="outline-container-org7b58301" class="outline-4">
<h4 id="org7b58301">Scope &amp; Context</h4>
<div class="outline-text-4" id="text-org7b58301">
<p>
Functions and Macros are defined in a scope.
Scopes can be chained, so that if no matching function is found it looks in the next scope. 
The standard scope chain has multiple functions and macros to manipulate bytes.
You can see all active scopes with the [help] function.
</p>

<p>
Sometimes the scope chain is extended with additional context: 
</p>
</div>

<div id="outline-container-org4ec593f" class="outline-5">
<h5 id="org4ec593f">Argv</h5>
<div class="outline-text-5" id="text-org4ec593f">
<p>
A scope containing functions resolving to an argument vector. 
</p>

<div class="ctabs" id="org7cfd382">
<div class="py" id="orgd2c9837">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">inp = "Rm9ycmVzdA" # the base 64 encoding of the word "Forrest"
lk_eval("[0] [1/b], [0]!",argv=["Run",inp])
</pre>
</div>

<pre class="example" id="org4f4ee02">
b'Run Forrest, Run!'
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-org962bf16" class="outline-5">
<h5 id="org962bf16">Packet</h5>
<div class="outline-text-5" id="text-org962bf16">
<p>
By providing a packet, the packet scope is added to the chain.
This adds functions such as <code>hash</code>, <code>group</code>, <code>path</code> etc.
These are bytes that you can use as arguments.
</p>

<p>
e.g <code>[hash/?b]</code> encodes the hash in base 64.
</p>

<p>
For convenience all packet fields accept 'str' and 'abe' as a first argument to print them in a default format.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>[hash:str]</code></td>
<td class="org-left"><code>[hash/?b]</code></td>
</tr>

<tr>
<td class="org-left"><code>[group:str]</code></td>
<td class="org-left"><code>[group/?b]</code></td>
</tr>

<tr>
<td class="org-left"><code>[create:str]</code></td>
<td class="org-left"><code>[create/?u]</code></td>
</tr>

<tr>
<td class="org-left"><code>[links_len:str]</code></td>
<td class="org-left"><code>[links_len/?u]</code></td>
</tr>

<tr>
<td class="org-left">&#x2026;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
The <code>[/links:...]</code> macro iterates over every link in a packet.
It evaluates the inner scope for each link with setting the <code>tag</code> and <code>ptr</code> function.
</p>

<div class="ctabs" id="orgb53c6a2">
<div class="sh" id="org43260fc">
<p>
<code>pktf</code> is <code>eval</code> that reads packets from stdin and puts them in scope.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk link "::" -- tag1:[#:0] tag2:[#:pub] | \
    lk pktf "HASH:[hash/?b]\n[/links:TAG = [tag:str] PTR = [ptr:str] \n]"
</pre>
</div>

<pre class="example" id="orgaf0095a">
HASH:fVlF-Um610JXUduexN_k6c00MgBDbCqTbN6217oQeSw
TAG = tag1 PTR = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
TAG = tag2 PTR = RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
</pre>

</div>

<div class="py" id="org38dcefc">
<div class="org-src-container">
<pre class="src src-python">lp = lk_linkpoint(links=[Link("hello",PUBLIC),Link("world",PRIVATE)])
lk_eval2str("hash:[hash:str]\\n[/links:[tag:str] [ptr:str]\\n]",pkt=lp)
</pre>
</div>

<pre class="example" id="orga719d3e">
hash:w_y-32CqNYvY7GtU-sSnHgu9CCFBc8wWvon6J-lZqkY
hello RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0
world AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-org7468958" class="outline-5">
<h5 id="org7468958">Linkspace</h5>
<div class="outline-text-5" id="text-org7468958">
<p>
Having a linkspace instance in the scope gives you access to functions like:
</p>

<ul class="org-ul">
<li><code>#</code> and <code>@</code> ( see <a href="#lns">LNS</a> ) for named groups, keys, and other data</li>
<li><code>readhash</code></li>
</ul>

<p>
When using <a href="#lk_open">lk_open</a> , the instance is automatically setup as scope.
</p>

<p>
<code>readhash</code> is considered bad practice, fine to hack something together, but it doesn't give you much room to process errors or async.
But you can do some wizardry combining it with <code>[/links]</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org5423727" class="outline-4">
<h4 id="org5423727">Usage notes</h4>
<div class="outline-text-4" id="text-org5423727">
<p>
ABE expressions evaluate into a list of [ (bytes,?sep) ].
Sometimes each element has a different meaning, e.g. [ ( domain , : ) , (group , _) ] in the CLI arguments.
You can process this list with <code>lk_split_abe</code>. 
</p>

<p>
But in the majority of cases we don't care about the list and only want a single result.
<code>lk_eval</code> does just that. It interprets the separators as plain characters.
</p>

<p>
Finally, consider what you would expect to happen when an evaluator takes a ABE expression as its final argument:
</p>

<ul class="org-ul">
<li><code>[/links:abc[:hello]/world]</code></li>
<li><code>[/readhash:[#:pub]:the pkt:[pkt]]</code></li>
<li><code>[/:hello/world]</code></li>
<li id="~lk link">&#x2013;write 'file:./afolder:with/colons'~</li>
</ul>

<p>
The choice was made that if the final argument is an abe expression that will be evaluated, it doesn't need wrapping <code>[]</code>.
Instead, it interprets the entire tail as is.
This reduces the need to escape ':' and '/', but complicating some other expressions.
</p>

<p class="verse">
We can add an expression to &#x2013;write arguments<br>
<code>lk link :: --write "stdout-expr:hello world:/ [hash:str]"</code><br>
In case of <code>file</code> this leaves us in the situation that second argument is the file and the tail of the expression will be evaluated<br>
One option is to use <code>[/:..]</code> to read ':' and '<i>' as is.<br>
~lk link :: &#x2013;write "file-expr:[</i>:./afolder:with/colons]:hello world:/ [hash:str]"~<br>
</p>
</div>
</div>


<div id="outline-container-abe-help" class="outline-4">
<h4 id="abe-help">Help</h4>
<div class="outline-text-4" id="text-abe-help">
<p>
A full list of active scopes can be viewed with the <code>help</code> function.
</p>
<div class="ctabs" id="org12479b3">
<div class="misc" id="orgca44eb9">
<p class="verse">
The following naming conventions are used:<br>
<br>
- ending with '?' is a predicate to check a property.<br>
- starting with '?' is a basic reverse operation. [u8:97/?u] == 97. Its similar but less powerful then <a href="#lk_encode">lk_encode</a> and lacking '[]' brackets.<br>
- b_RADIX_ ( b2, b8, b16 ) 'b' defaults to base64 radix<br>
- u_SIZE_  ( u8, .., u128 ) parse decimal into big endian bytes. ?u interpret as big endian print to decimal<br>
</p>

</div>

<div class="py" id="org85e6aa4">
<div class="org-src-container">
<pre class="src src-python">lk_eval2str("[help]",pkt=lk_linkpoint(),argv=["hello"]) # the help won't show up if no scope is set. 
</pre>
</div>

<pre class="example" id="orgb26fc37">
==scopes==
# bytes
Byte padding/trimming
## functions
-                  /:?          1..=16     the '' (empty) fnc can be used to start an expr such as {:12/u8} which is the same as {u8:12}  
- ?a               /:?          1..=1     encode bytes into ascii-bytes format  
- ?a0              /:?          1..=1     encode bytes into ascii-bytes format but strip prefix '0' bytes  
- a                /:?          1..=3     [bytes,length = 16,pad_byte = \0] - alias for 'lpad'  
- f                /:?          1..=3     same as 'a' but uses \xff as padding   
- lpad             /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad input bytes  
- rpad             /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad input bytes  
- ~lpad            /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad input bytes  
- ~rpad            /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad input bytes  
- lcut             /:?          1..=2     [bytes,length = 16] - left cut input bytes  
- rcut             /:?          1..=2     [bytes,length = 16] - right cut input bytes  
- ~lcut            /:?          1..=2     [bytes,length = 16] - lcut without error  
- ~rcut            /:?          1..=2     [bytes,length = 16] - lcut without error  
- lfixed           /:?          1..=3     [bytes,length = 16,pad_byte = \0] - left pad and cut input bytes  
- rfixed           /:?          1..=3     [bytes,length = 16,pad_byte = \0] - right pad and cut input bytes  
- slice            /:?          1..=4     [bytes,start=0,stop=len,step=1] - python like slice indexing  
- b2               /:?          1..=1     decode binary  
- b8               /:?          1..=1     decode octets  
- b16              /:?          1..=1     decode hex  
- ~utf8            /:?          1..=1     lossy encode as utf8  

# UInt
Unsigned integer functions
## functions
- +                /:?          1..=16     Saturating addition. Requires all inputs to be equal size  
- -                /:?          1..=16     Saturating subtraction. Requires all inputs to be equal size  
- u8               /:?          1..=1     parse 1 byte  
- u16              /:?          1..=1     parse 2 byte  
- u32              /:?          1..=1     parse 4 byte  
- u64              /:?          1..=1     parse 8 byte  
- u128             /:?          1..=1     parse 16 byte  
- ?u               /:?          1..=1     Print big endian bytes as decimal  
- lu               /:?          1..=1     parse little endian byte (upto 16)  
- lu8              /:?          1..=1     parse 1 little endian byte  
- lu16             /:?          1..=1     parse 2 little endian byte  
- lu32             /:?          1..=1     parse 4 little endian byte  
- lu64             /:?          1..=1     parse 8 little endian byte  
- lu128            /:?          1..=1     parse 16 little endian byte  
- ?lu              /:?          1..=1     print little endian number  

# b64
base64 url-safe no-padding
## functions
- ?b               /:?          1..=1     encode base64  
- 2mini            /:?          1..=1     encode mini  
- b                /:?          1..=1     decode base64  

# comment function / void function. evaluates to nothing

## functions
- C                /:?          1..=16     the comment function. all arguments are ignored. evaluates to ''  

# help

## functions
- help             /:           0..=16     help  
## eval
- help             desribe current eval context  

# logic ops
ops are : &lt; &gt; = 0 1 
## functions
- size?            /:?          3..=3     [in,OP,VAL] error unless size passes the test ( UNIMPLEMENTED )  
- val?             /:?          3..=3     [in,OP,VAL] error unless value passes the test ( UNIMPLMENTED)  
## eval
- or               :{EXPR}[:{EXPR}]* short circuit evaluate until valid return. Empty is valid, use {_/minsize?} to error on empty  

# encode
attempt an inverse of a set of functions
## functions
- eval             /:           1..=1     parse and evaluate  
## eval
- ?                find an abe encoding for the value trying multiple reversal functions - [/fn:{opts}]*   
- ~?               same as '?' but ignores all errors  
- e                eval inner expression list. Useful to avoid escapes: eg file:{/e:/some/dir:thing}:opts does not require escapes the '/'   

# static-lns
static lns for local only [#:0] and public [#:pub]
## functions
- #                / ?          1..=16     resolve #:0 , #:pub, and #:test without a db  
- @                / ?          1..=16     resolve @:none  

# stamp
utilities for stamp values (big endian u64 microsecond since unix epoch)
arguments consists of ( [+-][YMWDhmslu]usize : )* (str | delta | ticks | val)?

## functions
- s                /:           0..=16     if chained, mutate 8 bytes input as stamp (see scope help). if used as head assume stamp 0  
- now              / ?          0..=16     current systemtime  
- epoch            / ?          0..=16     unix epoch / zero time  
- s++              / ?          0..=16     max stamp  

# path
path utils. Usually [//some/path] is the most readable
## functions
- ?p               /:?          1..=1     decode path  
- path_idx         /:?          2..=3     path idx [start,?end]  
- p                /:?          1..=8     build path from arguments  
## eval
-                  the 'empty' eval for encoding paths . i.e. [//some/spath/val] creates the byte for /some/spath/val  
- ~                similar to '//' but forgiving on empty components  

# lns

## functions
- #                / ? &lt;partial&gt; 1..=7     (namecomp)* - get the associated lns group  
- ?#               /:?          1..=1     find by group# tag  
- @                / ? &lt;partial&gt; 1..=7     (namecomp)* - get the associated lns key  
- ?@               /:?          1..=1     find by pubkey@ tag  
## eval
- lns              [:comp]*/expr  

# private-lns
Only look at the private claims lookup tree. Makes no requests
## functions
- private#         / ?          1..=7     (namecomp)* - get the associated lns group  
- ?private#        /:?          1..=1     find by group# tag  
- private@         / ?          1..=7     (namecomp)* - get the associated lns key  
- ?private@        /:?          1..=1     find by pubkey@ tag  
## eval
- private-lns      [:comp]*/expr  

# filesystem env
read files from Ok("/tmp/linkspace")/files 
## functions
- files            /:           1..=1     read a file from the LK_DIR/files directory  

# database
get packets from the local db.
e-funcs evaluate their args as if in pkt scope.
funcs evaluate as if [/[func + args]:[rest]]. (e.g. [/readhash:HASH:[group:str]] == [readhash:..:group:str])
## functions
- readhash         /:           1..=16     open a pkt by hash and use tail args as if calling in a netpkt scope  
- read             /:           2..=16     read but accesses open a pkt by dgpk path and apply args. e.g. [read:mydomain:[#:pub]:[//a/path]:[@:me]::data:str], prefer eval ctx  
## eval
- readhash         HASH ':' expr (':' alt if not found)   

# Unset&lt;abe::eval::EScope&lt;linkspace_common::eval::OSEnv&gt;&gt;


# netpkt field
get a field of a netpkt. also used in watch predicates.
## functions
- netflags         /            0..=1     ?(str|abe) - netpkt.netflags  
- hop              /            0..=1     ?(str|abe) - netpkt.hop  
- stamp            /            0..=1     ?(str|abe) - netpkt.stamp  
- ubits0           /            0..=1     ?(str|abe) - netpkt.ubits0  
- ubits1           /            0..=1     ?(str|abe) - netpkt.ubits1  
- ubits2           /            0..=1     ?(str|abe) - netpkt.ubits2  
- ubits3           /            0..=1     ?(str|abe) - netpkt.ubits3  
- hash             /            0..=1     ?(str|abe) - netpkt.hash  
- type             /            0..=1     ?(str|abe) - netpkt.type  
- point_size       /            0..=1     ?(str|abe) - netpkt.point_size  
- pubkey           /            0..=1     ?(str|abe) - netpkt.pubkey  
- signature        /            0..=1     ?(str|abe) - netpkt.signature  
- group            /            0..=1     ?(str|abe) - netpkt.group  
- domain           /            0..=1     ?(str|abe) - netpkt.domain  
- create           /            0..=1     ?(str|abe) - netpkt.create  
- path_len         /            0..=1     ?(str|abe) - netpkt.path_len  
- links_len        /            0..=1     ?(str|abe) - netpkt.links_len  
- data_size        /            0..=1     ?(str|abe) - netpkt.data_size  
- path             /            0..=1     ?(str|abe) - netpkt.path  
- ipath            /            0..=1     ?(str|abe) - netpkt.ipath  
- path0            /            0..=1     ?(str|abe) - netpkt.path0  
- path1            /            0..=1     ?(str|abe) - netpkt.path1  
- path2            /            0..=1     ?(str|abe) - netpkt.path2  
- path3            /            0..=1     ?(str|abe) - netpkt.path3  
- path4            /            0..=1     ?(str|abe) - netpkt.path4  
- path5            /            0..=1     ?(str|abe) - netpkt.path5  
- path6            /            0..=1     ?(str|abe) - netpkt.path6  
- path7            /            0..=1     ?(str|abe) - netpkt.path7  
- data             /            0..=1     ?(str|abe) - netpkt.data  

# print pkt default

## functions
- pkt              /            0..=0     default pk fmt  
- netpkt           /            0..=0     TODO default netpkt fmt  
- point            /            0..=0     TODO default point fmt  
- netbytes         / ?          0..=0     raw netpkt bytes  

# select link

## functions
- *=               /:?          1..=1     [suffix] get first link with tag ending in suffix  
## eval
- links            :{EXPR} where expr is repeated for each link binding 'ptr' and 'tag'  

# recv
recv stamp for packet. value depends on the context
## functions
- recv             / ?          0..=0     recv stamp - errors if unavailable in context  
- recv_now         / ?          0..=0     recv stamp - recv stamp returns now if unavailable in context  

# user input list
Provide values, access with [0] [1] .. [7] 
## functions
- 0                / ?          0..=0     argv[0]  
- 1                / ?          0..=0     argv[1]  
- 2                / ?          0..=0     argv[2]  
- 3                / ?          0..=0     argv[3]  
- 4                / ?          0..=0     argv[4]  
- 5                / ?          0..=0     argv[5]  
- 6                / ?          0..=0     argv[6]  
- 7                / ?          0..=0     argv[7]  

</pre>

</div>

</div>
</div>
</div>
</div>

<div id="outline-container-lk_encode" class="outline-3">
<h3 id="lk_encode">lk_encode</h3>
<div class="outline-text-3" id="text-lk_encode">
<p>
Translate bytes into abe such that <code>lk_eval(lk_encode(X)) == X</code>
</p>

<p class="verse">
We can get meta. lk_encode is available as the evaluator <code>[/?:bytes:options]</code><br>
</p>

<div class="ctabs" id="org0a8a837">
<div class="py" id="orgde347d6">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">data = bytes([0,0,0,255])
abe = lk_encode(data)
assert data == lk_eval(abe)
print("ab  text:", abe)
abe = lk_encode(data,"u8/u32/b") # Try to encode as expression
print("abe text:", abe)
</pre>
</div>

<pre class="example" id="orgcb2a89d">
ab  text: \0\0\0\f
abe text: [u32:255]
</pre>

</div>

</div>
</div>

<div id="outline-container-org3160e6b" class="outline-4">
<h4 id="org3160e6b">DEFAULT_FMT</h4>
<div class="outline-text-4" id="text-org3160e6b">
<p>
This is how packets are printed by default using <code>lk pktf</code> or pythons <code>str(pkt)</code>.
</p>

<div class="ctabs" id="orgf740083">
<div class="py" id="orgb04a04d">
<div class="org-src-container">
<pre class="src src-python">import linkspace
print(linkspace.DEFAULT_PKT)
</pre>
</div>

<pre class="example" id="orgd4b3865">
type\t[type:str]\nhash\t[hash:str]\ngroup\t[/~?:[group]/#/b]\ndomain\t[domain:str]\npath\t[path:str]\npubkey\t[/~?:[pubkey]/@/b]\ncreate\t[create:str]\nlinks\t[links_len:str]\n[/links:\t[tag:str] [ptr:str]\n]\ndata\t[data_size:str]\n[data/~utf8]\n
</pre>

</div>

</div>
</div>
</div>
</div>


<div id="outline-container-lk_split_abe" class="outline-3">
<h3 id="lk_split_abe">lk_split_abe</h3>
<div class="outline-text-3" id="text-lk_split_abe">
</div>
</div>



<div id="outline-container-ABELNS" class="outline-3">
<h3 id="ABELNS">LNS</h3>
<div class="outline-text-3" id="text-ABELNS">
<p>
LNS is a system for publicly naming keys and groups, and adding auxiliary data to them.
It allows you to register as <code>@:Alice:nl</code>, <code>#:sales:company:com</code>, etc.
</p>

<p>
LNS is easy to use from an abe expression.
Both to lookup and do a reverse lookup.
</p>

<p>
See <a href="../../lns.html">lns</a> for info.
</p>

<p class="verse">
You can create local bindings, allowing you to reference <code>[@:my_identity:local]</code> or <code>[#:friends:local]</code><br>
By default <a href="#lk_key">lk_key</a> sets up the <code>[@:me:local]</code> identity.<br>
</p>

<div class="ctabs" id="org308542e">
<div class="sh" id="org4679d7b">
<div class="org-src-container">
<pre class="src src-bash">lk eval "[#:pub]" | lk encode "@/#/b"
</pre>
</div>

<pre class="example" id="orgd9855d2">
[#:pub]
</pre>

<div class="org-src-container">
<pre class="src src-bash">lk eval "[@:me:local]" | lk encode "@/#/b"
</pre>
</div>

<pre class="example" id="org80cc9c3">
[@:me:local]
</pre>

</div>

<div class="py" id="org39030f0">
<div class="org-src-container">
<pre class="src src-python">group = example_keypoint.group
print("The bare bytes:", group)

# encode as b64
b64 = lk_encode(group,"b")
print("b64 encoded   :", b64)

# Try to express as a [#:..], on failure try as [@:..], fallback to [b:...]
try_name = lk_encode(group,"#/@/b")
print("Or through lns:", try_name)

print("Pkt's pubkey  :",example_keypoint.pubkey)
try_keyname = lk_encode(example_keypoint.pubkey,"#/@/b")
print("Similarly lns :", try_keyname)


</pre>
</div>

<pre class="example" id="org90ae9aa">
The bare bytes: b'D=\xe5\xb4\xe8^\x1b\x80\xab\x06\xea\xd42{g\x85\x9f\x0f\xb5\x9e\xb2\x01\x81\x7f\x0b[\xab(ft\x04\x1d'
b64 encoded   : [b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]
Or through lns: [#:pub]
Pkt's pubkey  : b'o\xd6\xfb3\xbb\xc1\x90\xf7\xf9\x13\x9fX\x06\x8e\xee\xab\xed\x14\xd0)\x85\xf7\xc3\x84\xbc\x0b\x9ek@\xc3P&lt;'
Similarly lns : [@:me:local]
</pre>

</div>

</div>
</div>
</div>
</div>


<div id="outline-container-Query" class="outline-2">
<h2 id="Query">Query</h2>
<div class="outline-text-2" id="text-Query">
<p class="verse">
<a href="../cargo-doc/linkspace/query/index.html">Rust docs</a><br>
</p>

<p>
A query is a list of predicates and options used to define a set of packets.
They're used in various ways, most notably you can use them to read (<a href="#lk_get">lk_get</a>, <a href="#lk_get_all">lk_get_all</a>), await (<a href="#lk_watch">lk_watch</a>) and request (<a href="#lk_pull">lk_pull</a>) packets.
</p>
</div>

<div id="outline-container-lk_query" class="outline-3">
<h3 id="lk_query">lk_query</h3>
<div class="outline-text-3" id="text-lk_query">
<p>
Queries are newline separated.
Predicates are an <a href="#ABE">ABE</a> 3-tuple <code>field ':' test-operation ':' value</code> and constrain the set of accepted packets.
Options are context dependent and start with ':'
</p>

<p>
A query might look like this:
</p>

<pre class="example" id="orgc61eb0e">
group:=:[#:pub]
domain:=:example
path:=:/hello/world
pubkey:=:[@:me:local]
create:&gt;:[now:-1D]
</pre>

<p>
A predicate can be set multiple times. In the example above we could add <code>create:&lt;:[now:+2D]</code> to constrain it further.
Queries are designed such that you can concatenate their strings and get their union.
If the result is the empty set an error is returned.
</p>

<p>
There are 4 basic test operations and a couple of aliases.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Basic Op</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&gt;</td>
<td class="org-left">greater eq</td>
</tr>

<tr>
<td class="org-left">&lt;</td>
<td class="org-left">less eq</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-left">all '0' in value are '0' in field</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">all '1' in value are '1' in field</td>
</tr>
</tbody>
</table>

<p>
The following are shorthand and resolve to one or more of the basic tests.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Derived Ops</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">=</td>
<td class="org-left">&gt;(val-1) and &lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">&gt;=</td>
<td class="org-left">&gt;(val-1)</td>
</tr>

<tr>
<td class="org-left">&lt;=</td>
<td class="org-left">&lt;(val+1)</td>
</tr>

<tr>
<td class="org-left">*=</td>
<td class="org-left">Last n-bytes must eq val</td>
</tr>

<tr>
<td class="org-left">=*</td>
<td class="org-left">First n-bytes must eq val</td>
</tr>
</tbody>
</table>



<div class="ctabs" id="org50967bd">
<div class="sh" id="orgfddbe1c">
<p>

</p>

<p>
The CLI has options that can act as a guide in creating queries by using <code>lk print-query --help</code>.
</p>

<p class="verse">
Many cli commands (e.g. <code>print-statemnt</code>, <code>watch</code> ) take as the first argument a <code>domain:group:path:(?depth)</code><br>
If no depth is set the path_len is constraint by default.<br>
Except for <code>watch-tree</code> which sets the depth to unconstrained by default<br>
</p>

<p>
Here we look for the domain 'my' , the group [#:pub], with path starting at /hello and with one additional path component.
</p>

<div class="org-src-container">
<pre class="src src-bash">lk print-query "my:[#:pub]:/hello:*" --signed
</pre>
</div>

<pre class="example" id="org2d43c01">
:mode:tree-desc
type:1:[b2:00000111]
domain:=:[a:my]
group:=:[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]
prefix:=:/hello
path_len:&lt;:[u8:3]
path_len:&gt;:[u8:0]
</pre>

</div>

<div class="py" id="org990f3cb">
<div class="org-src-container">
<pre class="src src-python">template = lk_query_parse(lk_query(),"group:=:[#:pub]")
a_copy = lk_query(template)
lk_query_print(a_copy)
</pre>
</div>

<pre class="example" id="org9937b7f">
type:1:\x02
group:=:D=\xe5\xb4\xe8^\x1b\x80\xab\x06\xea\xd42{g\x85\x9f\x0f\xb5\x9e\xb2\x01\x81\x7f\x0b\[\xab(ft\x04\x1d
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_query_parse" class="outline-3">
<h3 id="lk_query_parse">lk_query_parse</h3>
<div class="outline-text-3" id="text-lk_query_parse">
<p>
Add multiple constraints to a query.
You can add multi line strings or per line.
Each line is evaluated as an abe expression.
You can set a pkt or argv context.
</p>

<p>
Returns an error if the resulting set is empty.
The full list of predicates and their byte size can be found <a href="#predicatelist">here</a>.
</p>

<div class="ctabs" id="orgbcadbae">
<div class="py" id="org3be016a">
<div class="org-src-container">
<pre class="src src-python">q = lk_query()

stmt = """
group:=:[#:pub]
domain:=:example
"""

q = lk_query_parse(q,stmt,
               "path_len:&lt;:[u8:4]",
               "data_size:&lt;:[0]",argv=[int(10).to_bytes(2)]) 
lk_query_print(q,True)
</pre>
</div>

<pre class="example" id="org75df020">
type:1:[b2:00000011]
domain:=:[a:example]
group:=:[b:RD3ltOheG4CrBurUMntnhZ8PtZ6yAYF_C1urKGZ0BB0]
data_size:&lt;:[u16:10]
path_len:&lt;:[u8:4]
</pre>

</div>

</div>
</div>
</div>

<div id="outline-container-lk_query_push" class="outline-3">
<h3 id="lk_query_push">lk_query_push</h3>
<div class="outline-text-3" id="text-lk_query_push">
<p>
Similar to lk_query_parse, but only adds a single statement and the last field expects the bytes.
</p>

<div class="ctabs" id="org01d488b">
<div class="py" id="orgf34809b">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">q = lk_query()
q = lk_query_push(q,"data_size","&lt;",bytes([0,4])) # less than 4
q = lk_query_push(q,"data_size","&lt;",lk_eval("[u16:20]"))  # less than 20
q = lk_query_push(q,"data_size","&lt;",int(3).to_bytes(2))  # less than 3
lk_query_print(q)
</pre>
</div>

<pre class="example" id="orgf5c357e">
type:1:\x01
data_size:&lt;:\0\x03
</pre>

<p>
Adding a contradictions returns an error.
</p>

<div class="org-src-container">
<pre class="src src-python">try:
  r = lk_query_push(q,"data_size","&gt;",bytes([0,100])) # greater than 100 and smaller than 3 can not both be true
except Exception as e :
  r = ("That's not possible",e)
r

</pre>
</div>

<pre class="example" id="org10c024e">
("That's not possible", RuntimeError("Error adding rule 'data_size'\n\nCaused by:\n    0: data_size:&gt;:[u16:100]\n    1: incompatible Greater 100"))
</pre>

</div>

</div>
</div>
</div>


<div id="outline-container-lk_query_print" class="outline-3">
<h3 id="lk_query_print">lk_query_print</h3>
<div class="outline-text-3" id="text-lk_query_print">
<p>
Print a query as text.
The query will have merged overlapping predicates
The boolean argument sets whether to create abe expressions or stick to a representation without expressions.
</p>

<div class="ctabs" id="org483b0cd">
<div class="py" id="orgc68ad17">
<p>

</p>

<div class="org-src-container">
<pre class="src src-python">lk_query_print(q,True)
</pre>
</div>

<pre class="example" id="org871a2fc">
type:1:[b2:00000001]
data_size:&lt;:[u16:3]
</pre>

</div>

</div>


<p class="verse">
The <code>b2</code> function read a binary representation.<br>
The types are: datapoint=[b2:0000_0001], linkpoint [b2:0000_0011], keypoint [b2:0000_0111].<br>
Setting 'group', 'domain', 'path', 'links', or 'create' predicates automatically exclude the datapoint type.<br>
Setting pubkey or signature excludes link and data points.<br>
</p>
</div>
</div>

<div id="outline-container-org36d2928" class="outline-3">
<h3 id="org36d2928">More on predicates</h3>
<div class="outline-text-3" id="text-org36d2928">
<p class="verse">
<code>group</code> requires 32 bytes but will try to parse base64.<br>
<code>domain</code> requires 16 bytes but will prepend '\0' if too few bytes are given<br>
<code>path</code> and <code>prefix</code> only take the = op. Their value is the spath bytes <code>path:=:[//hello/world]</code>, but they'll accept <code>/hello/world</code> as well<br>
</p>

<p>
Besides the fields in a point, predicates also apply to the hash and variable net header fields.
These fields are useful when writing an exchange processes.
</p>

<p>
The netheader fields can be mutated and are to be used by the group exchange for exchanging routing information.
It is 32 bytes consisting of the following field: 
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>

<tr>
<th scope="col" class="org-left">Field<sub>size</sub></th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Prefix<sub>3</sub></td>
<td class="org-left">magic bytes 'LK1'</td>
</tr>

<tr>
<td class="org-left">NetFlags<sub>1</sub></td>
<td class="org-left">See source code</td>
</tr>

<tr>
<td class="org-left">hop<sub>2</sub></td>
<td class="org-left">number of hops since creation</td>
</tr>

<tr>
<td class="org-left">stamp<sub>8</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits0<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits1<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits2<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ubits3<sub>4</sub></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-predicatelist" class="outline-4">
<h4 id="predicatelist">Predicates &amp; options</h4>
<div class="outline-text-4" id="text-predicatelist">
<p>
The full list of options and predicates:
</p>

<div class="ctabs" id="orgd87c289">
<div class="rs" id="org34ed450">
<p>

</p>

<p>
Current set of <a href="../cargo-doc/linkspace/query/enum.PredicateType.html">predicates</a> and 
<a href="../cargo-doc/linkspace/query/enum.KnownOptions.html">options</a>.
</p>

<p>
Predicates must be known, unknown options are added but ignored.
An exchange process will for instance add a ':boomfilter' only it understands.
</p>

</div>

<div class="sh" id="orgd565ea7">
<div class="org-src-container">
<pre class="src src-bash">lk print-query --help
</pre>
</div>

<pre class="example" id="orgbbb3599">
hash         - the point hash e.g. \[b:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\]
group        - group id e.g. \[#:pub\]
domain       - domain - if fewer than 16 bytes, prepadded with  e.g. \[a:example\]
prefix       - path prefix - only accepts '=' op e.g. /hello/world
path         - exact path - only accepts '=' op e.g. /hello/world
pubkey       - public key used to sign point e.g. \[@:me:local\]
create       - the create stamp e.g. \[now:-1H\]
path_len     - the total number of path components - max 8 e.g. \[u8:0\]
links_len    - the number of links in a packet e.g. \[u16:0\]
data_size    - the byte size of the data field e.g. \[u16:0\]
recv         - the recv time of a packet e.g. \[now:+1D\]
i_branch     - total packets per uniq (group,domain,path,key) - only applicable during local tree index, ignored otherwise e.g. \[u32:0\]
i_db         - total packets read from local instance e.g. \[u32:0\]
i_new        - total newly received packets e.g. \[u32:0\]
i            - total matched packets e.g. \[u32:0\]
hop          - (mutable) number of hops e.g. \[u16:5\]
stamp        - (mutable) variable stamp e.g. \[now\]
ubits0       - (mutable) user defined bits e.g. \[u32:0\]
ubits1       - (mutable) user defined bits e.g. \[u32:0\]
ubits2       - (mutable) user defined bits e.g. \[u32:0\]
ubits3       - (mutable) user defined bits e.g. \[u32:0\]
type         - the field type bits - implied by other predicates e.g. \[b2:00000001\]
netflags     - (mutable) netflags e.g. \[b2:00000000\]
point_size   - exact point size - (netpkt_size - 32b header - 32b hash) e.g. \[u16:4\]

The following options are available

	:mode
	:qid
	:follow
	:notify-close


query - print full query from common aliases

Usage: lk print-query [OPTIONS] [DGPD] [-- &lt;EXPRS&gt;...]

Arguments:
  [DGPD]      
  [EXPRS]...  

Options:
  -p, --print-expr               print the query
      --print-text               print in ascii-byte-text format (ABE without '[..]' expressions)
      --mode &lt;MODE&gt;              [default: tree-desc]
  -b, --bare                     
      --private                  enable io of linkpoints in [#:0] [env: LK_PRIVATE=]
      --index                    only match locally indexed pkts           | i_new:=:[u32:0]
      --new                      only match new unindexed pkts             | i_db:=:[u32:0]
      --max &lt;MAX&gt;                match upto max packets.                   | i:&lt;:[u32:max]
      --max-branch &lt;MAX_BRANCH&gt;  match upto max per (dm,grp,path,key) pkts | i_branch:&lt;:[u32:max_branch]
      --max-index &lt;MAX_INDEX&gt;    match upto max from local index           | i_db:&lt;:[u32:max_index]
      --max-new &lt;MAX_NEW&gt;        match upto max unindexed pkts             | i_new:&lt;:[u32:max_new]
      --signed                   match only signed pkts                    | pubkey:&gt;:[@:none]
      --unsigned                 match only unsigned pkts                  | pubkey:=:[@:none]
      --watch                    Add :qid option (generates qid)
      --qid &lt;QID&gt;                set :qid option (implies --watch)
      --follow                   Add :follow option
      --ttl &lt;TTL&gt;                add recv:&lt;:[now:+..]
  -h, --help                     Print help
</pre>

</div>

</div>
</div>
</div>
</div>
</div>


<div id="outline-container-linkspace" class="outline-2">
<h2 id="linkspace">Linkspace</h2>
<div class="outline-text-2" id="text-linkspace">
<p class="verse">
<a href="../cargo-doc/linkspace/linkspace/index.html">Rust docs</a><br>
</p>

<p>
The linkspace runtime opens a multi-reader, single-writer database.
One or more processes connect to it.
</p>

<p>
An application can save to the database (<a href="#lk_save">lk_save</a>).
Using queries an application can get the set of matching packets (<a href="#lk_get">lk_get</a>, <a href="#lk_get_all">lk_get_all</a>).
The application can registering a query and callback (<a href="#lk_watch">lk_watch</a>).
You can update the read transaction of your thread manually (<a href="#lk_process">lk_process</a>),
or by listening for new packets and waiting for some condition (<a href="#lk_process_while">lk_process_while</a>).
The callbacks of the watched queries are triggered whenever this update process sees a matching packet.
</p>
</div>

<div id="outline-container-lk_open" class="outline-3">
<h3 id="lk_open">lk_open</h3>
<div class="outline-text-3" id="text-lk_open">
</div>
</div>

<div id="outline-container-lk_save" class="outline-3">
<h3 id="lk_save">lk_save</h3>
<div class="outline-text-3" id="text-lk_save">
</div>
</div>

<div id="outline-container-lk_get" class="outline-3">
<h3 id="lk_get">lk_get</h3>
<div class="outline-text-3" id="text-lk_get">
</div>
</div>
<div id="outline-container-lk_get_all" class="outline-3">
<h3 id="lk_get_all">lk_get_all</h3>
<div class="outline-text-3" id="text-lk_get_all">
</div>
</div>


<div id="outline-container-lk_watch" class="outline-3">
<h3 id="lk_watch">lk_watch</h3>
<div class="outline-text-3" id="text-lk_watch">
</div>
</div>


<div id="outline-container-lk_process" class="outline-3">
<h3 id="lk_process">lk_process</h3>
<div class="outline-text-3" id="text-lk_process">
</div>
</div>

<div id="outline-container-lk_process_while" class="outline-3">
<h3 id="lk_process_while">lk_process_while</h3>
<div class="outline-text-3" id="text-lk_process_while">
</div>
</div>


<div id="outline-container-lk_close_watch" class="outline-3">
<h3 id="lk_close_watch">lk_close_watch</h3>
<div class="outline-text-3" id="text-lk_close_watch">
</div>
</div>
</div>


<div id="outline-container-Conventions" class="outline-2">
<h2 id="Conventions">Conventions</h2>
<div class="outline-text-2" id="text-Conventions">
<p class="verse">
<a href="../cargo-doc/linkspace/conventions/index.html">Rust docs</a><br>
</p>

<p>
Conventions are functions built on top of the other linkspace functions.
They provide interop for processes by encoding data into linkspace packets.
</p>

<p>
Generally they require the caller to also run <a href="#lk_process">lk_process</a> or <a href="#lk_process_while">lk_process_while</a>
</p>

<p>
One general conventions is that domains and paths starting with \xff are for meta stuff, such as status queries and packet exchange.
</p>
</div>

<div id="outline-container-lk_status_set" class="outline-3">
<h3 id="lk_status_set">lk_status_set</h3>
<div class="outline-text-3" id="text-lk_status_set">
<p>
Status queries allow us to communicate if a process exists that is handling a specific type and a specific instance.
</p>

<p>
The function signature is (<code>domain</code>, <code>group</code>, <code>obj_type</code>, <code>instance</code>).
</p>

<ul class="org-ul">
<li>A request is a packet in the form DOMAIN:[#:0]:/\fstatus/GROUP/type(/instance?) and has no data and no links.</li>
<li>A reply is of the form DOMAIN:[#:0]/\status/GROUP/type/instance with some data and at least one link.</li>
</ul>

<p>
Note that the packets are in `#:0`.
This function is only for local status updates.
</p>

<p>
The group argument does not ask inside GROUP, it only signals which group the query is about.
Other processes are meant to answer a request.
</p>

<p>
The following are statuses that the exchange process should set:
</p>

<ul class="org-ul">
<li>exchange GROUP process</li>
<li>exchange GROUP connection PUBKEY</li>
<li>exchange GROUP pull PULL PULL_HASH</li>
</ul>
</div>
</div>

<div id="outline-container-lk_status_poll" class="outline-3">
<h3 id="lk_status_poll">lk_status_poll</h3>
<div class="outline-text-3" id="text-lk_status_poll">
<p>
Request the status of a `domain group obj_type ?instance timeout`.
</p>
</div>
</div>


<div id="outline-container-lk_pull" class="outline-3">
<h3 id="lk_pull">lk_pull</h3>
<div class="outline-text-3" id="text-lk_pull">
<p>
A pull request is made by a domain application and signals the set of packets it wants.
The function takes the query and saves it as: 
<code>[f:exchange]:[#:0]:/pull/[query.group]/[query.domain]/[query.watch]</code>
</p>

<p class="verse">
Note that from a domain's perspective, there is no such thing as 'fully synchronized'.<br>
The most straight forwards way to emulate such a thing is to create 'log' packets that link to<br>
known packets from a single device's perspective.<br>
</p>

<p>
Pull queries must have the predicates 'domain:=:..' and 'group:=:..', and ':watch'
</p>

<p>
An exchange process (such as those in the tutorial <a href="../tutorial/index.html">tutorials</a>) watches these packets and attempts to fulfill it.
The exchange is only responsible for pull requests received when it is running.
The exchange can drop requests when you reuse the 'watch'.
The function returns the hash of the request.
</p>

<p>
A domain application should be conservative with its query.
Requesting too much can add overhead.
</p>
</div>
</div>

<div id="outline-container-lk_key" class="outline-3">
<h3 id="lk_key">lk_key</h3>
<div class="outline-text-3" id="text-lk_key">
<p>
Read ( or creates ) an encrypted private key from lns:[#:0]:/local/NAME.
Also writes into the local LNS lookup table such that the public key can be requested with <code>[@:NAME:local]</code>
</p>
</div>
</div>
</div>

<div id="outline-container-lns" class="outline-2">
<h2 id="lns">LNS</h2>
<div class="outline-text-2" id="text-lns">
<p>
See <a href="../../lns.html">LNS</a> for some general information.
See <a href="#ABELNS">abe#lns</a> for how to use LNS for lookup and reverse lookup.
</p>

<p>
The LNS system works by making a claim in <code>lns:[#:pub]:/claim/test/example/john</code> which we'll call <code>$Claim1</code>
A claim can have 3 types of special links.
The first link with the tag pubkey@ has as ptr the <code>pubkey</code> bytes to use when referring to <code>@:john:example:test</code>.
The first link with the tag group# has as ptr the <code>group</code> bytes to use when referring to <code>#:john:example:test</code>.
Every tag ending with '<code>^</code>' e.g. <code>root_00^</code> is an authority public key.
An authority has the right to vote for all subclaims. For example the claim <code>lns:[#:pub]:/claim/test/example/john/home/</code>
</p>

<p>
<code>$Claim1</code> becomes 'live' when a single authority of <code>claim/test/example</code> creates a vote by creating a keypoint <code>lns:[#:pub]:/claim/test/example/john</code> with
the link <code>vote:$Claim1.hash</code>. The first claim to get a majority of votes wins.
</p>
</div>
</div>



<div id="outline-container-qa" class="outline-2">
<h2 id="qa">Q&amp;A</h2>
<div class="outline-text-2" id="text-qa">
</div>


<div id="outline-container-orgc6c02a0" class="outline-5">
<h5 id="orgc6c02a0">Why Big Endian?</h5>
<div class="outline-text-5" id="text-orgc6c02a0">
<p>
The tree index is in the expected order when using the numbers as path components.
E.g. <code>lk linkpoint ::/some/dir/[now]</code> will come after <code>lk linkpoint ::/some/dir/[now:-1D]</code> because <code>now &gt; (now - one day)</code>
</p>
</div>
</div>

<div id="outline-container-org8fcb2f1" class="outline-5">
<h5 id="org8fcb2f1">Every user of my domain app needs X from my server/I want to add advertisements to my domain app.</h5>
<div class="outline-text-5" id="text-org8fcb2f1">
<p>
Hardcode a public key into the app and combine it with a group exchange service.
Either use an existing group, or use the group: their-key XOR your-key for personalized stuff
</p>
</div>
</div>

<div id="outline-container-org3e617cc" class="outline-5">
<h5 id="org3e617cc">I'm not in control of the user! / Anybody in my group can leak data from it!?</h5>
<div class="outline-text-5" id="text-org3e617cc">
<p>
I don't make the rules, I just make them obvious.
</p>
</div>
</div>

<div id="outline-container-orgda3c440" class="outline-5">
<h5 id="orgda3c440">A domain application can write outside its own domain space.</h5>
<div class="outline-text-5" id="text-orgda3c440">
<p>
Yes, the current API has no restriction.
Maybe at some point we can effectively restrict processes through wasm or some other access control.
</p>
</div>
</div>

<div id="outline-container-org027b5cb" class="outline-5">
<h5 id="org027b5cb">Why not use an SQL backend? / Why invent queries?</h5>
<div class="outline-text-5" id="text-org027b5cb">
<p>
That is a complex question.
First off, if you desire to run SQL queries it is not too difficult to stream packets into a SQL table with `lk pktf` or some custom code, and query them.
</p>

<p>
But SQL isn't magic, and its non-trivial price to pay for something that is not a great fit for a few fundamental problems including:
</p>
<ol class="org-ol">
<li>What are the tables peers should have?</li>
<li>How to constrain a query as it travels across a group?</li>
</ol>

<p>
Both can be solved in a number of ways, but most solutions are quickly going to bloat.
I've tried.
</p>

<p>
Queries have a few desirable properties.
They handle byte values, and you can concatenate them to get their common subset.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Blockchains are a subset of supernets.
They require hashes/entries to be shared, pointing to a previous block, and there are strict rules on what to accept in the chain.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">The homepage contains a list of various properties. However, there is one I lack a word for.
Both the process of database-to-view-to-database state synchronization, and dealing with (network) IO in general have this in common:
They're well-designed if they run under the assumption of incomplete, out-of-order, potentially buggy state.
In linkspace this is a requirement, and the library attempts to make it simple.
That's not to imply orchestration becomes simple, or the abstraction does not leak. I fear those are facts of life.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">To overcome this, create multiple packets and link them in a new linkpoint</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">the hash of <code>lk_datapoint(b"Hello, Sol")</code></p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2023-06-18 Sun 10:05</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>