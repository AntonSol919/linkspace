<!DOCTYPE html>
<html>
	<head>
		<title>Linkspace - a general purpose supernet</title>
		 <link rel="icon" type="image/x-icon" href="./images/logo.png">
		 <link rel="stylesheet" href="./style.css"/>
     <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source Code Pro">
	<body>
		 <a id="name" href="./index.html"><img id="logo" src="./images/logo.png"/>Linkspace</a>
		<div id="tagline">a general purpose supernet</div>
    

    <nav>
      <li>
        <a href="./index.html">Home</a>
      </li>
      <li>
        <a href="./basics.html">Basics</a>
      </li>

      <li >
        <a href="./lns.html">LNS</a>
      </li>
      <li >
        <a href="./about.html">About</a>
      </li>
      <hr>
      <li>
        <a href="https://github.com/AntonSol919/linkspace/releases">Download</a>
      </li>

      <li>
        <a href="./docs/guide/index.html" target="_blank">Guide</a>
      </li>
      <li>
        <a href="./docs/tutorial/index.html" target="_blank">Tutorials</a>
      </li>
      <li>
        <a href="https://github.com/AntonSol919/linkspace" target="_blank">Git</a>
      </li>

    </nav>
    
    <div id="main">
      <h1 id="basics">Basics</h1>
      <h2 id="the-internet-of-streams">The internet of streams</h2>
      <p>The digital world you know is built on structuring streams of
      data. At its core the internet<a href="#fn1" class="footnote-ref"
      id="fnref1" role="doc-noteref"><sup>1</sup></a> attempts to
      provide a model where:</p>
      <p>For any two connected devices running any application, there
      exists a connection to transmit data.</p>
      <p>To do this it uses the following types of packets to transmit
      data between two devices.</p>
      <div class="container">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 16%" />
      <col style="width: 22%" />
      <col style="width: 60%" />
      </colgroup>
      <thead>
      <tr class="header">
      <th></th>
      <th>Field</th>
      <th>Purpose</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td rowspan="4">Internet Packet</td>
      <td>IP ADDRESS</td>
      <td>Address for a device</td>
      </tr>
      <tr class="even">
      <td>PORT</td>
      <td>A number to address an application on a device</td>
      </tr>
      <tr class="odd">
      <td>SEQUENCE ID</td>
      <td>A number to (re)order packets when they arrive out of
      order</td>
      </tr>
      <tr class="even">
      <td>DATA</td>
      <td>Set by application</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>Packets are transmitted and - using the <code>IP address</code>
      - they reach their destination: a device such as the one you’re
      using right now. On the device an application is running that
      looks for packets with a specific <code>port</code> to arrive.</p>
      <p>In transit, a packet can get lost or corrupted. The result is
      that packets don’t arrive in the order they were sent. By adding a
      sequence number, the destination can verify all packets have
      arrived and reorder them to the order they were sent in.</p>
      <p>I imagine the proto-internet was first discovered when people
      realized that packet SEQUENCE IDs are essential complexity. When
      transmitting data, something must define the order of packets.
      Consequently the physical route each packet takes is
      irrelevant.</p>
      <p>The result is that <em>conceptually</em> each application on
      each device can talk to any other application on any other
      device.</p>
      <p>This model is ideal for phone-calls or video streams. To build
      more interesting applications we create protocols to add further
      structure to the stream of data. There are thousands of different
      protocols, but what most of them have in common is a way to
      transmit questions and answers.</p>
      <p>A couple of well known internet protocols that have this
      property are:</p>
      <table>
      <thead>
      <tr class="header">
      <th>System</th>
      <th>Question</th>
      <th>Answer</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td>DNS</td>
      <td>archive.org</td>
      <td>207.241.224.2</td>
      </tr>
      <tr class="even">
      <td>HTTP</td>
      <td>/forum/index.html</td>
      <td>Hello world!</td>
      </tr>
      <tr class="odd">
      <td>FTP</td>
      <td>/Projects/linkspace/readme.md</td>
      <td>In a supernet […]</td>
      </tr>
      <tr class="even">
      <td>SQL</td>
      <td>SELECT * from MSG where ID=1;</td>
      <td>A message in a db</td>
      </tr>
      </tbody>
      </table>
      <p>With these tools various ‘platforms’ exists so that people have
      a model for two or more devices to communicate.</p>
      <p><b>We have reached the limit of using this model of streaming
      questions/answers paradigm for multi-party communication.</b></p>
      <p>First, the stream abstraction can leak. Streams get
      disconnected, the other side hangs up, the other side is
      overloaded, etc. Then, when more than two devices are involved the
      leaks compound. Two devices go out of sync. Either somewhere in
      the system an answer becomes stale or wrong, or doesn’t scaling
      and have everyone contact a single source of truth.</p>
      <p>Alternatively you use something like a supernet.</p>
      <div class="definition">
      <p>Supernet [ˈsü-pərˌnet]<br> A self-referential multi-participant
      data organization protocol whose primary addressing method uses
      hashes instead of endpoint identifiers.</p>
      <p>e.g. git, bitcoin, linkspace</p>
      </div>
      <p>Once you start thinking in terms of supernets, it becomes clear
      that many problems with streaming questions/answers are accidental
      complexity. When a supernet is used to build an application those
      problems become irrelevant or trivial<a href="#fn2"
      class="footnote-ref" id="fnref2"
      role="doc-noteref"><sup>2</sup></a> - and we can do things that
      are practically impossible if we keep talking streams.</p>
      <h2 id="linkspace">Linkspace</h2>
      <p>Linkspace attempts to provide a model where: for any group
      running any application, there exists a space to address data<a
      href="#fn3" class="footnote-ref" id="fnref3"
      role="doc-noteref"><sup>3</sup></a>.</p>
      <p>If the current internet is essentially streams for key-value
      systems, so you can talk <em>to</em> server, then linkspace is
      essentially a shared key-value space, so groups can talk
      <em>about</em> data.</p>
      <p>A unit in linkspace is called a <strong>point</strong>. Each
      point has data, some auxiliary fields, and is uniquely identified
      by its hash.</p>
      <p>To understand what each field does lets start with a simple
      example of a message forum.</p>
      <div class="container pkt pd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 50%" />
      <col style="width: 48%" />
      </colgroup>
      <thead>
      <tr class="header">
      <th>Key</th>
      <th>Value</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt pd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 50%" />
      <col style="width: 48%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/thread/Can we use Rust?/msg</td>
      <td>I heard it is great.</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      =
      </div>
      <div class="container pkt pd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 50%" />
      <col style="width: 48%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Can we use Rust?/msg</td>
      <td>I heard it is great.</td>
      </tr>
      <tr class="odd">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>The key “image/BrokenMachine.jpg” is called a
      <strong>path</strong> and maps to [image data]. So far this should
      look familiar as it is similar to files in directories. I’ll refer
      to each entry as a <strong>point</strong>, and multiple entries as
      a <strong>set</strong>. The example shown has two sets
      <strong>merging</strong>. The result is a new set with 3
      messages.</p>
      <p>One of the most useful aspects of linkspace is a way to talk
      and think about digital communication in terms of a set of points
      instead of connections.</p>
      <p>Practically any digital communication can be understood as
      merging sets of points.</p>
      <p>Online platforms have dubbed different words for actions you
      can take: ‘<em>creating posts</em>’, ‘<em>uploading image</em>’,
      ‘<em>upvote/like a post</em>’, ‘<em>stream a video</em>’, etc.
      Fundamentally they can be understood as a frontend application
      providing an interface to <strong>merge</strong> sets of points.
      Either on your device or on theirs<a href="#fn4"
      class="footnote-ref" id="fnref4"
      role="doc-noteref"><sup>4</sup></a>.</p>
      <p>The internet we use today has a single host design. For
      instance, a web-browser or app contacts
      <code>http://www.some_platform.com</code> for the key
      <code>/image/BrokenMachine.jpg</code> to get an image.</p>
      <p>This is simple, but it has downsides.</p>
      <p>There is a misconception on what an address is<a href="#fn5"
      class="footnote-ref" id="fnref5"
      role="doc-noteref"><sup>5</sup></a>, a host can get disconnected,
      you can’t (re)share and (re)use your copy of the data, and there
      is no standard on what happens when two people create two
      different <code>image/BrokenMachine.jpg</code> but with different
      pictures.</p>
      <p>I would argue these fall under accidental complexity.</p>
      <p>Especially the last one. Once the speed of light is measurable
      in a network, it requires a specific design to avoid two or more
      computers to write to the same path.</p>
      <p>In our single host design, the data is hosted on a server and
      the person who has administrative access to that server can then
      administrate which one is the ‘real’ copy, and which one should be
      forgotten.</p>
      <p>In linkspace there is no such thing as a ‘real’ copy on a
      single host.</p>
      <p>Every path can refer to multiple points.</p>
      <p>Each point is hashed. i.e. there exists a unique 32 bytes (or
      ~77-digit number) that uniquely identifies the point<a href="#fn6"
      class="footnote-ref" id="fnref6"
      role="doc-noteref"><sup>6</sup></a> (which I’ll show as <span
      id="hh0">[HASH_0]</span> instead of typing out).</p>
      <p>It doesn’t matter when or where sets are merged - the result
      only has a single copy per message.</p>
      <div class="container pkt phd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 34%" />
      <col style="width: 31%" />
      <col style="width: 33%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt phd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 34%" />
      <col style="width: 31%" />
      <col style="width: 33%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh2">[HASH_2]</span></td>
      <td>I heard they’re better than VS</td>
      </tr>
      <tr class="odd">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh3">[HASH_3]</span></td>
      <td>Emacs with vim bindings ofcourse</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      =
      </div>
      <div class="container pkt phd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 34%" />
      <col style="width: 31%" />
      <col style="width: 33%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh2">[HASH_2]</span></td>
      <td>I heard they’re better than VS</td>
      </tr>
      <tr class="odd">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh3">[HASH_3]</span></td>
      <td>Emacs with vim bindings ofcourse</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>We can uniquely get a specific point by its <span
      id="hh0">[HASH_0]</span>, or multiple entries through a path
      “/thread/Tabs or spaces/msg”.</p>
      <p>This might seem more trouble than existing solutions like a
      filesystem or HTTP. In those, one request by name gets you a
      single result.</p>
      <p>However, this is not a real issue for two reasons.</p>
      <p>In practice it is trivial to only request ‘the latest value’ or
      ‘the latest value signed by someone you trust’.</p>
      <p>The later is especially interesting. If an application only
      requests points signed by a specific key, it effectivly
      administrates similar to how it is done in our current single
      host-administrator design. However, it has the additional property
      that it can be independent from hosting the data. i.e. in
      linkspace ‘hosting data’ and ‘content administration’ can be
      decoupled.</p>
      <div class="container pkt pkthd">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 18%" />
      <col style="width: 8%" />
      <col style="width: 20%" />
      <col style="width: 28%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[@:alice:salesexample]</td>
      <td>2015/01/29</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:alice:salesexample]</td>
      <td>2023/03/02</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt pkthd">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 18%" />
      <col style="width: 8%" />
      <col style="width: 20%" />
      <col style="width: 28%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:bob:maintenance:example]</td>
      <td>2023/03/02</td>
      <td><span id="hh3">[HASH_4]</span></td>
      <td>Hey <span id="hh1">[HASH_1]</span>! Isn’t <span
      id="hh0">this</span> from 2015?</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      =
      </div>
      <div class="container pkt pkthd">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 18%" />
      <col style="width: 8%" />
      <col style="width: 20%" />
      <col style="width: 28%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[@:alice:salesexample]</td>
      <td>2015/01/29</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:alice:salesexample]</td>
      <td>2023/03/02</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      <tr class="odd">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:bob:maintenance:example]</td>
      <td>2023/03/02</td>
      <td><span id="hh3">[HASH_4]</span></td>
      <td>Hey <span id="hh1">[HASH_1]</span>! Isn’t <span
      id="hh0">this</span> from 2015?</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>A point has two preceding fields. A <strong>group</strong> that
      signal who can read/write to the tree, and a
      <strong>domain</strong> field to indicate which application should
      read it. Essentially any pair of (domain, group) has its own
      tree.</p>
      <p>For example the <code>msg_board</code> application and the
      <code>[#:example]</code> group.</p>
      <div class="container pkt dgpkthd">
      <table style="width:97%;">
      <colgroup>
      <col style="width: 5%" />
      <col style="width: 7%" />
      <col style="width: 19%" />
      <col style="width: 15%" />
      <col style="width: 6%" />
      <col style="width: 17%" />
      <col style="width: 24%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>msg_board</td>
      <td>[#:example]</td>
      <td>/image/BrokenMachine.jpg</td>
      <td>[@:alice:salesexample]</td>
      <td>2015/01/29</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>msg_board</td>
      <td>[#:example]</td>
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:alice:salesexample]</td>
      <td>2023/03/02</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      <tr class="odd">
      <td>msg_board</td>
      <td>[#:example]</td>
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:bob:maintenance:example]</td>
      <td>2023/03/02</td>
      <td><span id="hh3">[HASH_4]</span></td>
      <td>Hey <span id="hh1">[HASH_1]</span>! Isn’t <span
      id="hh0">this</span> from 2015?</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>Note that the group and public keys are actually 32 bytes. For
      brevity I used the <a href="./lns.html">LNS</a> representation for
      <code>[@:alice:salesexample]</code> and <code>[#:example]</code>.
      LNS solves a similar problem as DNS, i.e. turning a name like
      <code>www.example.com</code> into a number like
      <code>192.168.0.1</code>.</p>
      <p>Finally, the messages we used as an example have a <span
      id="hh1">[HASH]</span> directly in their data field. This would
      not work well for most use-cases. Instead, a point in linkspace
      has a list of <a
      href="./docs/guide/index.html#lk_linkpoint">links</a> adjacent to
      the data.</p>
      <div class="container">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 23%" />
      <col style="width: 32%" />
      <col style="width: 21%" />
      </colgroup>
      <thead>
      <tr class="header">
      <th></th>
      <th>Field<a href="#fn7" class="footnote-ref" id="fnref7"
      role="doc-noteref"><sup>7</sup></a></th>
      <th>Purpose</th>
      <th>IP Packet Analogue</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td rowspan="8">Linkspace Point</td>
      <td>HASH</td>
      <td>A unique ID (Blake3)</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>GROUPID</td>
      <td>Set of recipients</td>
      <td>IP ADDRESS</td>
      </tr>
      <tr class="odd">
      <td>DOMAIN</td>
      <td>Name chosen by App developer</td>
      <td>PORT NUMBER</td>
      </tr>
      <tr class="even">
      <td>DATA</td>
      <td>Set by application</td>
      <td>DATA</td>
      </tr>
      <tr class="odd">
      <td>TIMESTAMP</td>
      <td>Microseconds since 1970-01-01</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>PATH</td>
      <td>Key to look up</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>LINKS[]</td>
      <td>list of (Tag, Hash)</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>PUBKEY &amp; SIGNATURE</td>
      <td>Optional - identifies creator</td>
      <td></td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>For the full specification of creating and writing points see
      the <a href="./docs/guide/index.html#packet_layout">guide</a></p>
      <p>There are some nuances and various advanced topics. However,
      this should be enough to reason about the basics:</p>
      <p>Users generate their identity, together they form groups and
      set up a method to exchange data.</p>
      <p>The result is that <em>conceptually</em> an application only
      needs to process the state of the trees.</p>
      <h2 id="ready-to-give-it-a-try">Ready to give it a try?</h2>
      <p>Linkspace is not an end-user application. It is a software
      library and command line tools. A GUI frontend to manage
      groups/domains/keys is outside its scope.</p>
      <p>The packet format is stable. Points created will stay readable
      in future versions. The API is mostly stable but will have some
      breaking changes and additional conventions.</p>
      <p>To give it a try you can <a
      href="https://github.com/AntonSol919/linkspace/releases">Download</a>
      the pre-build CLI and python bindings to follow along with the <a
      href="./docs/tutorial/index.html">tutorial</a> or the more
      technical <a href="./docs/guide/index.html">Guide</a>,</p>
      <p>For the adventurous there is initial support for wasm, and a
      POC HTTP bridge called <a
      href="https://github.com/AntonSol919/webbit">Webbit</a> that works
      similar to WebDAV.</p>
      <h1 id="qa">Q&amp;A</h1>
      <h3 id="who-is-linkspace-for">Who is linkspace for?</h3>
      <p>Me from 10 years ago, me today, the next generation that wants
      their internet to be better, and everyone else. In that order.</p>
      <h4 id="the-tool">The tool</h4>
      <p>If you’re just interested in the tool; linkspace can shrink a
      ‘stack’ significantly.</p>
      <p>Data formats change and grow as projects goes on. Using
      linkspace to carry the data many potentially-critical features are
      built in at the basics. Instead of risking a costly and complex
      upgrade when you need a feature yesterday, you get a lot of
      properties by default such as: uniquely addressable/cross
      referencing events, security against tampering, logging, secure
      user identities, low effort backups, etc.</p>
      <p>It is scaleable decoupled data creation, routing, storing, and
      processing; with data authenticity and user authentication to
      control access, wire up business logic, or log ‘who’ did ‘what’
      and ‘when’. Take the parts you want and leave the rest out.</p>
      <p>It even runs in the browser<a href="#fn8" class="footnote-ref"
      id="fnref8" role="doc-noteref"><sup>8</sup></a>, meaning you can
      reuse more code logic and tools.</p>
      <p>Finally, by talking <em>about</em> data there is a lot of
      potential for a ‘network effect’. e.g. a support-ticket references
      the exact IoT event, a sale can references the your exact history
      of the object, etc.</p>
      <h4 id="the-idea">The idea</h4>
      <p>I build linkspace so I (and hopefully others) can:</p>
      <ul>
      <li>define, prototype, build, and run real-serverless
      offline-first apps quickly.</li>
      <li>build an application without having to decide how to
      administrate for everyone that uses it - that responsibility sits
      with the (group of) users.</li>
      </ul>
      <p>I hope it might solve some of the worst problems with the
      current internet.</p>
      <p>Perhaps the greatest insanity of this time (and I believe its
      defining feature) is a few for-profit advertisement / propaganda
      services are the host-administrators of the digital ‘public
      squares’ for more than 2<sup>32</sup> people alive.</p>
      <p>It is questionable for people (and the groups they organize in)
      to be subjected to the interests of an unaccountable
      administrator. But I think the real impact is the medium as the
      message: You are not in control, surrender your minds for profit
      and submit to apathy.</p>
      <p>It is a staggering amount of wasted potential for people to not
      experience and learn to building something for, and with, a group
      outside the limits and interest of a
      higher-authority-incorporated.</p>
      <p>We are all lesser for it.</p>
      <p>The message of linkspace should be: You are in control, and you
      should build the best places you can.</p>
      <h3 id="is-linkspace-a-blockchain">Is linkspace a blockchain?</h3>
      <p>No.</p>
      <p>Blockchains and supernets share a common idea:</p>
      <p>Using cryptographic hashes and public keys to provide a model
      for communication data that transcends the connection used to
      share it.</p>
      <p>Blockchain use the cryptography to batch multiple events into
      ‘blocks’. As new blocks are made they are linked or ‘chained’ to
      the previous block. This creates a consensus of all events that
      happened.</p>
      <p>A blockchain’s goal is to provide a model and tools to make
      consensus simple.</p>
      <p>However, consensus on all events isn’t that useful as a
      foundational feature for the vast majority of applications.</p>
      <p>Supernets don’t bother with a global truth. Their goal is to
      work with the links between packets. Consequently, it’s not
      difficult to define a ‘blockchain’ style consensus in a general
      purpose supernet.</p>
      <h3
      id="wont-an-app-have-a-lot-of-overhead-compared-to-a-basic-web-server">Won’t
      an app have a lot of overhead compared to a basic Web server?</h3>
      <p>If all you want to do is stream one movie from a single host
      and forget it, then linkspace might be too much overhead. Few
      projects stay that simple. Most projects grow in scope: to
      identify users, save their comments, add them to groups, scale
      beyond a single server, etc.</p>
      <p>Once a full stack is build, linkspace is very small w.r.t. its
      features.</p>
      <p>As far as overhead goes, it is designed to be fast/low energy
      such that a low-end phone can use it to stream video.</p>
      <h3 id="complexity">Can you ask people to deal with the added
      complexity?</h3>
      <p>Yes.</p>
      <p>Linkspace lack 6 decades of tooling that made the internet and
      web relatively easy for users, but that can change.</p>
      <p>But is it worth it?</p>
      <p>Yes.</p>
      <p>Technically supernets better model the reality of multi party
      communication - asynchronous and authenticated<a href="#fn9"
      class="footnote-ref" id="fnref9"
      role="doc-noteref"><sup>9</sup></a> In the long run they could end
      up with less moving parts and with fewer configurations.</p>
      <p>For society it is important that anyone can take responsibility
      if they want.</p>
      <h3
      id="isnt-it-a-good-thing-that-a-host-administrates-what-i-and-others-see-online">Isn’t
      it a good thing that a host administrates what I and others see
      online?</h3>
      <p>Sure.</p>
      <p>There are different ways to do so. The straight forward
      approach is to have the application or user trust the public key
      of someone to scan and whitelist content. This emulates the
      current system of ‘admins’, while still having users give the
      option to replace them.</p>
      <p>Alternatively can be more dynamic. You could have friends or
      friends-of-friends vouch for content.</p>
      <p>I suspect the latter to become more important as AI drives the
      cost of bullshit to zero and while platforms have no incentive to
      identify the engagement and content from chatbots.</p>
      <h3
      id="wont-we-end-up-with-the-same-paradigm-of-highly-centralized-control">Won’t
      we end up with the same paradigm of highly centralized
      control?</h3>
      <p>Maybe, maybe not. If user today could walk away from a
      host-administrator without losing their history, identity, and
      links to others; then they would get a better deal then they do
      now.</p>
      <h2 id="alts">Why not [alternative]?</h2>
      <p>There are two similar types of systems that can’t do what I
      want.</p>
      <ul>
      <li>Synchronizing chain of trust: Is slow and not useful for the
      vast majority of users - (and easy to emulate in a supernet).</li>
      <li>Faster email: It’s not that fast and it is using
      server-defined authenticity - plus most of the list below.</li>
      </ul>
      <p>Other supernet-like systems are limited in some way or simply
      choose a different design:</p>
      <ul>
      <li>Too specialized. E.g. Git has a lot of plumbing for diffing
      text.</li>
      <li>Large ‘packets’ - a hash might refer to gigabytes. This
      requires multiple levels to deal with fragmentation in multiple
      ways.</li>
      <li>Either its primarily hashes, or its primarily path names.
      Linkspace has both as first class addresses.</li>
      <li>Too slow. Packet routing/parsing should be doable in just a
      few instructions - ideally possible in an integrated circuit. It
      should be fast enough to stream video without using a second
      protocol. That means no json or base64.</li>
      <li>No Groups. Setting who you share with and how is not supported
      or its little more than ‘run multiple instances’.</li>
      <li>No domains. Everything becomes one app with
      premature-bureaucracy and an ever expanding set of compatibility
      requirements that grinds development/experiments to a halt.</li>
      <li>Its focused on signatures and consensus.</li>
      <li>Poor scripting support.</li>
      <li>Excessively interwoven components. e.g. Transmitting packets
      require a fully running ‘node’ with a fixed method of exchanging
      or saving data.</li>
      </ul>
      <p>That does not mean I think alternatives are necessarily worse.
      Different systems have different strong points.</p>
      <aside id="footnotes" class="footnotes footnotes-end-of-document"
      role="doc-endnotes">
      <hr />
      <ol>
      <li id="fn1"><p>TCP/IP. I’ll be loose on definitions and
      oversimplify a lot - even use ‘internet’ instead of ‘web’. I don’t
      expect readers to know or care for the details. But if you find a
      false statement shoot me a message.<a href="#fnref1"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn2"><p>Trivial is perhaps overstating it, but take for
      example a stream getting disconnected - A supernet with a good API
      should guide a developer to take the most extreme cases of
      asynchronicity into account. i.e. slow or disconnected server
      should not break a system as it does to the majority of
      ‘platforms’. Well designed supernet applications can be truely
      offline-first and ‘serverless’.<a href="#fnref2"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn3"><p>This idea and other ideas used in linkspace aren’t
      new. But I believe linkspace is a simple and powerful synthesis
      compared to previous attempts (see <a href="#alts">alts</a>).<a
      href="#fnref3" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn4"><p>Your device immediatly forgetting those data
      points is a configuration detail.<a href="#fnref4"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn5"><p>The perception is created that the address
      ‘http://www.some_platform.com/image/BrokenMachine.jpg’ is
      addressing ‘[image data]’ - this is wrong. The address is used for
      your request to find where it needs to go, this address then
      usually replies with ‘[image data]’. A subtle but consequental
      difference. Linkspace does not have this discrepency.<a
      href="#fnref5" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn6"><p>Unique for all intents and purposes - except for
      the purpose of counting to 2^256+1.<a href="#fnref6"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn7"><p>Both TCP/IP packets and linkspace packets have
      control fields that are irrelevant to a vast majority of
      developers.<a href="#fnref7" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn8"><p>Currently only the reading, processing and writing
      packets API is supported. With the rest put on the TODO list.<a
      href="#fnref8" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn9"><p>Authenticated as in: cryptographicaly proven that
      messages were created by a user of a public key regardless how you
      got the message - I call this ‘the reality’ because a wire-dump of
      an HTTPS session is also proof that the keyholder send the
      message.<a href="#fnref9" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      </ol>
      </aside>
    </div>
    </body>
</html>
