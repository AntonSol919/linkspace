<!DOCTYPE html>
<html>
	<head>
		<title>Linkspace - a general purpose supernet</title>
		 <link rel="icon" type="image/x-icon" href="./images/logo.png">
		 <link rel="stylesheet" href="./style.css"/>
     <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source Code Pro">
	<body>
		 <a id="name" href="./index.html"><img id="logo" src="./images/logo.png"/>Linkspace</a>
		<div id="tagline">a general purpose supernet</div>
    

    <nav>
      <li>
        <a href="./index.html">Home</a>
      </li>
      <li>
        <a href="./basics.html">Basics</a>
      </li>

      <li >
        <a href="./lns.html">LNS</a>
      </li>
      <li >
        <a href="./about.html">About</a>
      </li>
      <hr>
      <li>
        <a href="https://github.com/AntonSol919/linkspace/releases">Download</a>
      </li>

      <li>
        <a href="./docs/guide/index.html" target="_blank">Guide</a>
      </li>
      <li>
        <a href="./docs/tutorial/index.html" target="_blank">Tutorials</a>
      </li>
      <li>
        <a href="https://github.com/AntonSol919/linkspace" target="_blank">Git</a>
      </li>

    </nav>
    
    <div id="main">
      <h1 id="basics">Basics</h1>
      <h2 id="the-internet-of-streams">The internet of streams</h2>
      <p>The digital world you know is build on structuring streams of
      data. At its core the internet<a href="#fn1" class="footnote-ref"
      id="fnref1" role="doc-noteref"><sup>1</sup></a> attempts to
      provide a model where:</p>
      <p>For any two connected devices running any application, there
      exists a connection to transmit data.</p>
      <p>To do this it uses the following types of packets to transmit
      data between two devices.</p>
      <div class="container">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 16%" />
      <col style="width: 22%" />
      <col style="width: 60%" />
      </colgroup>
      <thead>
      <tr class="header">
      <th></th>
      <th>Field</th>
      <th>Purpose</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td rowspan="4">Internet Packet</td>
      <td>IP ADDRESS</td>
      <td>Address for a device</td>
      </tr>
      <tr class="even">
      <td>PORT</td>
      <td>A number to address an application on a device</td>
      </tr>
      <tr class="odd">
      <td>SEQUENCE ID</td>
      <td>A number to (re)order packets when they arrive out of
      order</td>
      </tr>
      <tr class="even">
      <td>DATA</td>
      <td>Set by application</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>Packets carrying data are transmitted, and using the
      <code>IP address</code> they eventually reach their destination; a
      computer such as you’re using right now. On the computer an
      application is listening for packets with a specific
      <code>port</code> to be received.</p>
      <p>In transit, a packet can get lost or corrupted. Consequently,
      packets don’t arrive in the order they were sent. By adding a
      sequence number, we can reorder them at the destination.</p>
      <p>I imagine the prototype internet was first discovered when it
      was realized that packet SEQUENCE IDs are unavoidable complexity
      to transmit between two places without losing data, and that
      consequently the physical route each packet takes is
      irrelevant.</p>
      <p>The result is that <em>conceptually</em> each application on
      each device can talk to any other application on any other
      device.</p>
      <p>This model is ideal for phone-calls or video streams. To build
      more interesting applications we create protocols to add further
      structure to the data. There are thousands of different protocols,
      but the most common trait among them is that they define a way to
      transmit questions and answers.</p>
      <p>A couple of well known internet protocols that have this
      property are:</p>
      <table>
      <thead>
      <tr class="header">
      <th>System</th>
      <th>Question</th>
      <th>Answer</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td>DNS</td>
      <td>archive.org</td>
      <td>207.241.224.2</td>
      </tr>
      <tr class="even">
      <td>HTTP</td>
      <td>/forum/index.html</td>
      <td>Hello world!</td>
      </tr>
      <tr class="odd">
      <td>FTP</td>
      <td>/Projects/linkspace/readme.md</td>
      <td>In a supernet […]</td>
      </tr>
      <tr class="even">
      <td>SQL</td>
      <td>SELECT * from MSG where ID=1;</td>
      <td>A message in a db</td>
      </tr>
      </tbody>
      </table>
      <p>The reason for building linkspace is this:</p>
      <p><b>We have reached the limit of this streaming
      questions/answers paradigm.</b></p>
      <p>There are many difficulties with it.</p>
      <p>As with most abstraction, the details leak. Streams get
      disconnected, the other side hangs up, the other side is
      overloaded, etc.</p>
      <p>In multi party systems trying to orchestrate the
      questions/answers systems these leaks reach further. Answers
      become invalid, integrety/backup is fixed adhoc, and parties
      require expensive synchronization to agree on things<a href="#fn2"
      class="footnote-ref" id="fnref2"
      role="doc-noteref"><sup>2</sup></a>.</p>
      <p>Once you start thinking in supernets, it becomes clear that
      this is accidental and unnecessary complexity when communicating
      in a group - and that we can do things that are impossible if we
      keep talking streams.</p>
      <h2 id="linkspace">Linkspace</h2>
      <p>Linkspace attempts to provide a model where: for any group
      running any application, there exists a space to address data<a
      href="#fn3" class="footnote-ref" id="fnref3"
      role="doc-noteref"><sup>3</sup></a>.</p>
      <p>If the current internet provides streams for key-value systems,
      so you can talk <em>to</em> server,<br />
      then linkspace provides a shared key-value space, so groups can
      talk <em>about</em> data.</p>
      <p>A unit in linkspace is called a <strong>point</strong>. Each
      point has data, some auxiliary fields, and is uniquely identified
      by its hash.</p>
      <h3 id="merging-sets">Merging sets</h3>
      <p>To understand what each field does lets start with a simple
      example of a message forum.</p>
      <div class="container pkt pd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 50%" />
      <col style="width: 48%" />
      </colgroup>
      <thead>
      <tr class="header">
      <th>Key</th>
      <th>Value</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt pd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 50%" />
      <col style="width: 48%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/thread/Can we use Rust?/msg</td>
      <td>I heard it is great.</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      =
      </div>
      <div class="container pkt pd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 50%" />
      <col style="width: 48%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Can we use Rust?/msg</td>
      <td>I heard it is great.</td>
      </tr>
      <tr class="odd">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>The key “image/BrokenMachine.jpg” is called a
      <strong>path</strong> and maps to [image data]. This currently
      looks just like your files and directories. I’ll refer to each
      entry as a <strong>point</strong>, and multiple entries as a
      <strong>set</strong>. The example shown has two sets
      <strong>merging</strong>. The result is a new set with 3
      messages.</p>
      <p>One of the most useful aspects of linkspace is a way to talk
      and think about digital communication in terms of a set of points
      instead of connections.</p>
      <p>Practically any digital communication can be understood as
      merging sets of points.</p>
      <p>Online platforms have dubbed different words for actions you
      can take: ‘<em>creating posts</em>’, ‘<em>uploading image</em>’,
      ‘<em>upvote/like a post</em>’, ‘<em>stream a video</em>’, etc.
      Fundamentally they can be understood as a frontend application
      providing an interface to <strong>merge</strong> sets of points.
      Either on your computer or on their computer<a href="#fn4"
      class="footnote-ref" id="fnref4"
      role="doc-noteref"><sup>4</sup></a>.</p>
      <p>The internet we use today has a single host design. For
      instance, a web-browser or app contacts
      <code>http://www.some_platform.com</code> for the key
      <code>/image/BrokenMachine.jpg</code> to get their data.</p>
      <p>This is simple, but it has downsides.</p>
      <p>There are common misconceptions on what an address is<a
      href="#fn5" class="footnote-ref" id="fnref5"
      role="doc-noteref"><sup>5</sup></a>. A host can get disconnected,
      you can’t (re)share and (re)use your copy of the data, and every
      host has to pick a strategy when you merge two sets but they share
      the same path.</p>
      <p>I would argue these are all accidental complexity.</p>
      <p>Most noticeably the last one: How to merge two sets if both
      have <code>thread/BrokenMachine.jpg</code> but different data.
      Once the speed of light is measurable in a network, it is
      unavoidable for two computers to write to the same path without a
      costly synchronization steps.</p>
      <p>In linkspace there is no such thing as a ‘real’ copy on a
      single host.</p>
      <p>Every path refers to multiple values.</p>
      <p>Each point is hashed. i.e. there exists a unique 32 bytes (or
      ~77-digit number) that uniquely identifies the point<a href="#fn6"
      class="footnote-ref" id="fnref6"
      role="doc-noteref"><sup>6</sup></a> (which I’ll show as <span
      id="hh0">[HASH_0]</span> instead of typing out).</p>
      <p>Therefor it doesn’t matter when or where sets are merged - and
      they only leave a single copy when both have the same message.</p>
      <div class="container pkt phd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 34%" />
      <col style="width: 31%" />
      <col style="width: 33%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt phd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 34%" />
      <col style="width: 31%" />
      <col style="width: 33%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh2">[HASH_2]</span></td>
      <td>I heard they’re better than VS</td>
      </tr>
      <tr class="odd">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh3">[HASH_3]</span></td>
      <td>Emacs with vim bindings ofcourse</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      =
      </div>
      <div class="container pkt phd">
      <table style="width:99%;">
      <colgroup>
      <col style="width: 34%" />
      <col style="width: 31%" />
      <col style="width: 33%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh2">[HASH_2]</span></td>
      <td>I heard they’re better than VS</td>
      </tr>
      <tr class="odd">
      <td>/thread/Emacs or vim?/msg</td>
      <td><span id="hh3">[HASH_3]</span></td>
      <td>Emacs with vim bindings ofcourse</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>We can uniquely get a specific point by its <span
      id="hh0">[HASH_0]</span>, or multiple entries through a path
      “/thread/Tabs or spaces/msg”.</p>
      <p>This might seem more trouble than existing solutions like a
      filesystem or HTTP. In those key-value systems a single path gets
      you a single result.</p>
      <p>However, in practice it’s trivial to behave similarly by adding
      constraints to a requested set; Such as ‘only return the latest’,
      or ‘the latest signed by a specific public key’.</p>
      <p>Conversely, I would argue both filesystems and HTTP servers are
      more trouble over all. They hide that they return multiple values
      - a new value depending on when and where you make the
      request.</p>
      <p>A point also has a creation date and are
      <strong>optionally</strong> signed - such that you can identify
      who created it.</p>
      <div class="container pkt pkthd">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 18%" />
      <col style="width: 8%" />
      <col style="width: 20%" />
      <col style="width: 28%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[@:alice:salesexample]</td>
      <td>2015/01/29</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:alice:salesexample]</td>
      <td>2023/03/02</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt pkthd">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 18%" />
      <col style="width: 8%" />
      <col style="width: 20%" />
      <col style="width: 28%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:bob:maintenance:example]</td>
      <td>2023/03/02</td>
      <td><span id="hh3">[HASH_4]</span></td>
      <td>Hey <span id="hh1">[HASH_1]</span>! Isn’t <span
      id="hh0">this</span> from 2015?</td>
      </tr>
      </tbody>
      </table>
      </div>
      <div class="op">
      +
      </div>
      <div class="container pkt pkthd">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 18%" />
      <col style="width: 8%" />
      <col style="width: 20%" />
      <col style="width: 28%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>/image/BrokenMachine.jpg</td>
      <td>[@:alice:salesexample]</td>
      <td>2015/01/29</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:alice:salesexample]</td>
      <td>2023/03/02</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      <tr class="odd">
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:bob:maintenance:example]</td>
      <td>2023/03/02</td>
      <td><span id="hh3">[HASH_4]</span></td>
      <td>Hey <span id="hh1">[HASH_1]</span>! Isn’t <span
      id="hh0">this</span> from 2015?</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>A point has two preceding fields. A <strong>group</strong> that
      signal who can read/write to the tree, and a
      <strong>domain</strong> field to indicate which application should
      read it. Essentially any pair of (domain, group) has its own
      tree.</p>
      <p>For example the <code>msg_board</code> application and the
      <code>[#:example]</code> group.</p>
      <div class="container pkt dgpkthd">
      <table style="width:97%;">
      <colgroup>
      <col style="width: 5%" />
      <col style="width: 7%" />
      <col style="width: 19%" />
      <col style="width: 15%" />
      <col style="width: 6%" />
      <col style="width: 17%" />
      <col style="width: 24%" />
      </colgroup>
      <tbody>
      <tr class="odd">
      <td>msg_board</td>
      <td>[#:example]</td>
      <td>/image/BrokenMachine.jpg</td>
      <td>[@:alice:salesexample]</td>
      <td>2015/01/29</td>
      <td><span id="hh0">[HASH_0]</span></td>
      <td>[image data]</td>
      </tr>
      <tr class="even">
      <td>msg_board</td>
      <td>[#:example]</td>
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:alice:salesexample]</td>
      <td>2023/03/02</td>
      <td><span id="hh1">[HASH_1]</span></td>
      <td>Fix pls? image/BrokenMachine.jpg</td>
      </tr>
      <tr class="odd">
      <td>msg_board</td>
      <td>[#:example]</td>
      <td>/thread/Coffee machine broke!/msg</td>
      <td>[@:bob:maintenance:example]</td>
      <td>2023/03/02</td>
      <td><span id="hh3">[HASH_4]</span></td>
      <td>Hey <span id="hh1">[HASH_1]</span>! Isn’t <span
      id="hh0">this</span> from 2015?</td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>Note that the group and public keys are actually 32 bytes. For
      brevity I used the <a href="./lns.html">LNS</a> representation for
      <code>[@:alice:salesexample]</code> and <code>[#:example]</code>.
      LNS solves a similar problem as DNS, i.e. turning a name like
      <code>www.example.com</code> into a number like
      <code>192.168.0.1</code>.</p>
      <p>Finally, the messages we used as an example have a <span
      id="hh1">[HASH]</span> directly in their data field. This would
      not work well for most use-cases. Instead, a point in linkspace
      has a list of <a
      href="./docs/guide/index.html#lk_linkpoint">links</a> adjacent to
      the data.</p>
      <div class="container">
      <table style="width:98%;">
      <colgroup>
      <col style="width: 22%" />
      <col style="width: 23%" />
      <col style="width: 32%" />
      <col style="width: 21%" />
      </colgroup>
      <thead>
      <tr class="header">
      <th></th>
      <th>Field<a href="#fn7" class="footnote-ref" id="fnref7"
      role="doc-noteref"><sup>7</sup></a></th>
      <th>Purpose</th>
      <th>IP Packet Analogue</th>
      </tr>
      </thead>
      <tbody>
      <tr class="odd">
      <td rowspan="8">Linkspace Point</td>
      <td>HASH</td>
      <td>A unique ID (Blake3)</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>GROUPID</td>
      <td>Set of recipients</td>
      <td>IP ADDRESS</td>
      </tr>
      <tr class="odd">
      <td>DOMAIN</td>
      <td>Name chosen by App developer</td>
      <td>PORT NUMBER</td>
      </tr>
      <tr class="even">
      <td>DATA</td>
      <td>Set by application</td>
      <td>DATA</td>
      </tr>
      <tr class="odd">
      <td>TIMESTAMP</td>
      <td>Microseconds since 1970-01-01</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>PATH</td>
      <td>Key to look up</td>
      <td></td>
      </tr>
      <tr class="odd">
      <td>LINKS[]</td>
      <td>list of (Tag, Hash)</td>
      <td></td>
      </tr>
      <tr class="even">
      <td>PUBKEY &amp; SIGNATURE</td>
      <td>Optional - identifies creator</td>
      <td></td>
      </tr>
      </tbody>
      </table>
      </div>
      <p>For the full layout of packets see the <a
      href="./docs/guide/index.html#packet_layout">guide</a></p>
      <p>There are some nuances and various advanced topics such as:
      Paths can be any bytes, the <a
      href="./docs/guide/index.html#Query">queries</a> syntax for
      defining sets, and the convention on requesting subsets of data in
      a group by <a
      href="./docs/guide/index.html#lk_pull">pulling</a>.</p>
      <p>However, I hope this gives you enough to reason about the
      basics:</p>
      <p>Users generate an identity, groups set up a method to exchange
      data.</p>
      <p>The result is that <em>conceptually</em> an application only
      needs to process the state of the trees.</p>
      <h2 id="ready-to-give-it-a-try">Ready to give it a try?</h2>
      <p>Linkspace is not an end-user application. It is a software
      library and command line tools. A GUI frontend to manage
      groups/domains/keys is outside its scope.</p>
      <p>To give it a try you can <a
      href="https://github.com/AntonSol919/linkspace/releases">Download</a>
      the pre-build CLI and python bindings to follow along with the <a
      href="./docs/tutorial/index.html">tutorial</a> or the more
      technical <a href="./docs/guide/index.html">Guide</a>, and say hi
      on the test group.</p>
      <p>The packet format is stable. Points created will stay readable
      in future versions. The API is mostly stable but will have some
      breaking changes and additional conventions.</p>
      <h1 id="qa">Q&amp;A</h1>
      <h3 id="is-linkspace-a-blockchain">Is linkspace a blockchain?</h3>
      <p>No.</p>
      <p>Blockchains and supernets share a common idea:</p>
      <p>Using cryptographic hashes and public keys to provide a model
      of data that trancends the connection used to share it.</p>
      <p>Blockchain use the cryptography to batch multiple events into
      ‘blocks’. As new blocks are made they are linked or ‘chained’ to
      the previous block. This creates a consensus of all events that
      happened.</p>
      <p>A blockchain’s goal is to provide a model and tools to make
      consensus simple.</p>
      <p>However, consensus on all events isn’t that useful as a
      foundational feature for the vast majority of applications.</p>
      <p>Supernets don’t bother with a global truth. Their goal is to
      work with the links between packets. Consequently, it’s not
      difficult to define a ‘blockchain’ style consensus in a general
      purpose supernet.</p>
      <h3
      id="wont-an-app-have-a-lot-of-overhead-compared-to-a-basic-web-server">Won’t
      an app have a lot of overhead compared to a basic Web server?</h3>
      <p>If all you want to do is stream one movie from a single host
      and forget it, then linkspace might be too much overhead. Few
      projects stay that simple. Most projects grow in scope: to
      identify users, save their comments, add them to groups, scale
      beyond a single server, etc.</p>
      <p>Once a full stack is build, linkspace is very small w.r.t. its
      features.</p>
      <p>As far as overhead goes, it is designed to be fast/low energy
      such that a low-end phone can use it to stream video.</p>
      <h3 id="complexity">Can you ask people to deal with the added
      complexity?</h3>
      <p>Yes.</p>
      <p>Linkspace lack 6 decades of tooling that made the internet and
      web relatively easy for users, but that can change.</p>
      <p>But is it worth it?</p>
      <p>Yes.</p>
      <p>Supernets better model the reality of multi party communication
      - asynchronous and authenticated<a href="#fn8"
      class="footnote-ref" id="fnref8"
      role="doc-noteref"><sup>8</sup></a></p>
      <p>In the long run they could end up with less moving parts and
      with fewer configurations.</p>
      <p>Also important is that anyone can take responsibility. It is
      not without danger for billions of people to spend hours each day
      in a paradigm where they can not take back control over systems
      they consider the ‘public square’.</p>
      <p>My hope is to look back at this time as the era of digital
      fiefdoms. The next era should balance out the influence of
      host-administrators, and together people can define what a ‘real’
      copy is.</p>
      <h3
      id="isnt-it-a-good-thing-that-a-host-can-administrate-what-i-and-others-see-online">Isn’t
      it a good thing that a host can administrate what I and others see
      online?</h3>
      <p>I agree it is not categorically a bad thing.</p>
      <p>To have an administrator that filters the digital space there
      are a multiple options. To name a two:</p>
      <p>An application can have you trust the public key of third party
      service to whitelist content. Effectively emulating the current
      system of ‘admins’, while still having users give the option to
      replace them.</p>
      <p>Or an application can have you trust only signatures from
      friends or friends of friends. (A system that will become more
      important as AI drives the cost of bullshit to zero.)</p>
      <h3
      id="wont-we-end-up-with-the-same-paradigm-of-centralized-control">Won’t
      we end up with the same paradigm of centralized control?</h3>
      <p>Maybe, maybe not. If a user could walk away from a host server
      without much trouble, the host has to give a better deal than they
      do now.</p>
      <h2 id="alts">Why not [alternative]?</h2>
      <p>There are two types of systems I’m certain aren’t the right
      building blocks for the next digital era.</p>
      <ul>
      <li>Synchronizing chain of trust: Is slow and not useful for the
      vast majority of users - (and easy to emulate in a supernet).</li>
      <li>Faster email/Activity Pub : Its not that fast and its using
      server defined authenticity<a href="#fn9" class="footnote-ref"
      id="fnref9" role="doc-noteref"><sup>9</sup></a> - plus most of the
      list below.</li>
      </ul>
      <p>Other supernet-like systems are limited in some way or simply
      choose a different design:</p>
      <ul>
      <li>Too specialized. For example, a system like Git has a lot of
      plumbing for diffing each commit.</li>
      <li>It has either hash addresses or custom url addresses, not
      both.</li>
      <li>Too slow. Packet routing/parsing should be doable in just a
      few instructions - ideally possible in an integrated circuit. It
      should be fast enough to stream video without using a second
      protocol. That means no json or base64.</li>
      <li>No Groups. Limiting who you share with is not supported - apps
      can’t be used in a private group.</li>
      <li>No domains. Everything becomes one app.</li>
      <li>Its focused on signatures and consensus.</li>
      <li>Large ‘packets’ - a hash might refer to gigabytes. This
      requires multiple levels to deal with fragmentation in multiple
      ways.</li>
      <li>Poor scripting support.</li>
      <li>Excessively interwoven components. e.g. Transmitting packets
      require a fully running ‘node’ with a fixed method of exchanging
      or saving data.</li>
      </ul>
      <p>That does not mean I think alternatives are necessarily worse.
      Different systems have different strong points.</p>
      <aside id="footnotes" class="footnotes footnotes-end-of-document"
      role="doc-endnotes">
      <hr />
      <ol>
      <li id="fn1"><p>TCP/IP - I’ll be loose on definitions and
      oversimplify a lot. I don’t expect readers to know or care for the
      details. But if you find an incorrect statement shoot me a
      message.<a href="#fnref1" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn2"><p>Or instead of synchronization you add unique ID’s
      to each event across the network. If you chose a strong hash, and
      each event can reference others by their hash - you’ve just build
      a special purpose supernet.<a href="#fnref2" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn3"><p>This idea and other ideas used in linkspace aren’t
      new. But I believe linkspace is a simple and powerful synthesis
      compared to previous attempts (see <a href="#alts">alts</a>).<a
      href="#fnref3" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn4"><p>Your computer immediatly forgetting those data
      points is a configuration detail.<a href="#fnref4"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn5"><p>The perception is created that the address
      ‘http://www.some_platform.com/image/BrokenMachine.jpg’ is
      addressing ‘[image data]’ - this is wrong. The address is used for
      your request to find where it needs to go, this address then
      usually replies with ‘[image data]’. A subtle but a consequental
      difference. Linkspace does not have this discrepency.<a
      href="#fnref5" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn6"><p>Unique for all intents and purposes - except for
      the purpose of counting to 2^256+1.<a href="#fnref6"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn7"><p>Both TCP/IP packets and linkspace packets have
      control fields that are irrelevant to a vast majority of
      developers.<a href="#fnref7" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn8"><p>Authenticated as in: cryptographicaly proven that
      messages were created by a user of a public key regardless how you
      got the message - I call this ‘the reality’ because a wire-dump of
      an HTTPS session is also proof that the key holder send the
      message.<a href="#fnref8" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn9"><p>Yes i’m aware content hashing and publickey
      identities might one day be the default - but in so far as i’ve
      read about it its going to be extremely complex to build on, and
      apps will miss out on much of the benefit of a supernet.<a
      href="#fnref9" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      </ol>
      </aside>
    </div>
    </body>
</html>
