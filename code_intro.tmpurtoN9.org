# Created 2023-07-18 Tue 14:36
#+options: toc:nil
#+title: Quick start
#+author: R.A. Sol
#+pandoc_options: template:./template.pml
This introduction jumps headlong into linkspace using the command line tool `lk` in bash.
If you're unfamiliar with reading bash then [[file:./why.html][why]] is a better place to start.
You can follow along by [[https://github.com/AntonSol919/linkspace/releases][downloading]] the latest release. 

#+name: version
#+begin_src bash
  lk --version
#+end_src

#+results: version
#+begin_example
  linkspace-cli linkspace-cli - 0.3.1-rc1 - main - 8f0a006 - 1.72.0-nightly
#+end_example

* Point

A single unit in linkspace is called a `point`.
A point can hold just shy of 64kb.

#+name: point-hello
#+begin_src bash
  echo "Hello, Sol!" | lk point > mylog
#+end_src

#+results: point-hello

Beyond just data, there are some (optional) additional fields, such as:  

a path:
#+name: point-path
#+begin_src bash
  echo -n some data | lk point ::/my/example/path --data-stdin >> mylog
#+end_src

#+results: point-path

a timestamp that defaults to `now`:

#+name: point-create
#+begin_src bash
  lk point ::/my/example/other_path --create-int $(($(date +%s%N)/1000000)) >> mylog
#+end_src

#+results: point-create

and a signature:

#+name: point-signed
#+begin_src bash
  KEY=$(lk key --no-pubkey --no-lk --password 'my secret')
  lk point ::/my/example/path/subpath --sign --enckey "$KEY" --password 'my secret' >> mylog
#+end_src
All points are hashed using Blake3.

`pktf` formats a stream of points.

#+name: pktf
#+begin_src bash
  cat mylog | lk pktf "The hash: [hash:str] refers to a point with path '[path:str]' and data: '[data]'"
#+end_src

#+results: pktf
#+begin_example
  The hash: Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk refers to a point with path '' and data: 'Hello, Sol!
  '
  The hash: 5vp0c-HkwZh_ocESt6KmVQi5aqh1NFpcDjTjtn3vHvQ refers to a point with path '/my/example/path' and data: 'some data'
  The hash: L6u9Zgruob25lgtrpYrADuKnJctH76QJ3kK0MsjOUxE refers to a point with path '/my/example/other_path' and data: ''
  The hash: ebrC69ieHQkNaFPmUFXPwIEYxzt5MTZM4CPrEHyoags refers to a point with path '/my/example/path/subpath' and data: ''
#+end_example

`filter` to take a subset of points.
Here we take only the points with a path starting with `/my/example` and 1 additional component

#+name: filter
#+begin_src bash
  cat mylog | lk filter ::/my/example:* | lk pktf "[hash:str] [path:str]"
#+end_src

#+results: filter
#+begin_example
  5vp0c-HkwZh_ocESt6KmVQi5aqh1NFpcDjTjtn3vHvQ /my/example/path
  L6u9Zgruob25lgtrpYrADuKnJctH76QJ3kK0MsjOUxE /my/example/other_path
#+end_example

What makes a supernet is:

- A hash addressable `unit` - in linkspace the `point`
- A point references other points by hash

In linkspace these references are called `links`. Each link is a 16 byte tag and 32 byte hash value.
Tags can be anything. If less than 16 bytes are supplied it is left-padded with 0's.


#+name: links
#+begin_src bash
  HASH=($(cat mylog | lk pktf [hash:str]))
  lk point "::/my/example/link" -- "my first link:${HASH[0]}" "other link:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk" >> mylog
#+end_src

#+results: links

You can get fancy with `pktf` and `xargs`.

#+name: links-xargs
#+begin_src bash
  cat mylog | lk pktf "mytag:[hash:str]" | xargs lk point ::/my/example/link -- >> mylog
#+end_src

#+results: links-xargs

A tool like `lk collect` has a few additional options for building points linking to other points.
However, the `lk` binary is meant to do simple things.
Use the library and a better programming language when doing non-trivial stuff.

#+begin_HTML
<details>
<summary>
Click here to see a graphical representation of mylog
</summary>
#+end_HTML

#+results[cbf22962d88abcdb1aafdfd83b79d0975e5ddfec]: graph-mylog
[[file:images/mylog-dot.svg]]


#+begin_HTML
</details>
#+end_HTML

Creating points with `lk point` detects what kind you're trying to build.
But it is better to be explicit. The 3 types of points are:
`datapoint`, `linkpoint`, or `keypoint` (a signed linkpoint).

NOTE: linkpoint and keypoint do not read data from stdin by default.

#+name: point-stdin
#+begin_src bash
  echo somedata | lk linkpoint ::/my/other_path --data-stdin | lk pktf "[hash:str] = [data]"
#+end_src

#+results: point-stdin
#+begin_example
  Pxs-bCmdS6jAP0ArQKBQsYswcUwcURQdw93wPfCE0co = somedata
#+end_example

Linkspace is primarily its packet format.
Using linkspace can be as simple as a device broadcasting linkspace points.
Everything else is about making it easy to build complex things with these points.
If one of the tools is a bad fit for your use-case, then consider building and sharing your own tool.

* Database

Usually you'll want to save points to a linkspace database.

#+name: db-init
#+begin_src bash
  export LK_DIR=/tmp/linkspace ; 
  lk init ; 
  cat mylog | lk save > /dev/null ; 
#+end_src

#+results: db-init
#+begin_example
  LkInfo { dir: "/tmp/linkspace" }
#+end_example

Instead of using `save` you can set a write destinations directly.

#+name: write
#+begin_src bash
  echo hello world | lk point --write db --write file:mylog --write stdout | lk pktf [data]
#+end_src

#+results: write
#+begin_example
  hello world
#+end_example

The database is useful for two reasons:

- It has an index to quickly lookup by hash or path
- Multiple processes/threads can read, write, and **watch** for new points.

The library API has a user-driven eventloop that uses callbacks ([[file:./docs/guide/index.html#linkspace][guide]]).
The cli on the other hand is focused on streams.
The commands are `watch-log`, `watch-tree`, `watch-hash`. These are shorthand for  `watch --mode ..`.

#+name: watchtree
#+begin_src bash
  lk watch-tree ::/my:** | lk pktf "[path:str]" > ./watching &
#+end_src

#+results: watchtree
#+begin_example
  [1] 10534
#+end_example

#+name: react
#+begin_src bash
  cat ./watching
#+end_src

#+results: react
#+begin_example
  /my/example/link
  /my/example/link
  /my/example/path
  /my/example/other_path
  /my/example/path/subpath
#+end_example

Adding a new point

#+name: watch-write
#+begin_src bash
  lk linkpoint ::/my/my/my --write db
#+end_src

#+results: watch-write

Notifies watching threads.

#+name: react2
#+begin_src bash
  cat ./watching
#+end_src

#+results: react2
#+begin_example
  /my/example/link
  /my/example/link
  /my/example/path
  /my/example/other_path
  /my/example/path/subpath
  /my/my/my
#+end_example

* A general purpose supernet

To build an application pick a domain name (like you would an ip port - 16 bytes '\0' padded).
For example `imageboard`.

#+begin_verse
`pktf` is common enough to have the alias `lk p`.
#+end_verse

#+name: domain
#+begin_src bash
  lk linkpoint imageboard::/hello | lk p "[domain:str]"
#+end_src

#+results: domain
#+begin_example
  imageboard
#+end_example

The goal of linkspace is to make it simple to build applications for a network of devices.

A typical linkspace applications shouldn't have to deal with sockets.
Instead, the application should only have to define how points are linked and how to handle them not being available (yet).

#+begin_verse
That can be a challenge at first. But the end result are better applications in general.
Simple applications designed for sockets that read/write streams of data allow us to ignore asynchronicity and partial state most of the time.
Until you add a third device to a system, and things explode in complexity and all assumptions have to be re-evaluated.
#+end_verse

For example, you might want to build an application so multiple people can draw to a shared 'board'.
One option to map that idea into points is:

- Images are saved as data points
- Every link in a linkpoint is a hash to an image, and a tag holding (x,y) coordinates.

Adding an image might look something like: 

#+name: tuxpng
#+begin_src bash
  X=30 ; Y=200 ; IMG="https://upload.wikimedia.org/wikipedia/commons/3/35/Tux.svg" ; 
  curl -s $IMG | lk datapoint > tux.pkt
  IMG_HASH=$(cat tux.pkt | lk p "[hash:str]")
  lk linkpoint imageboard::/hello/tux.svg -- $(printf "%08d%08d" "$X" "$Y"):$IMG_HASH >> tux.pkt
  HASHES=($(cat tux.pkt | lk p "[hash:str]")) # store as an array
  lk save --pkts ./tux.pkt # `cat` is usually useless but can be easier to read.
#+end_src

#+results: tuxpng

Building an image requires the program to watch for new packets in `imageboard::/hello`, and on every (new) point draw over the image.

#+name: watch-tree
#+begin_src bash
  lk watch-tree "imageboard::/hello:**" --max 1 \
     | lk p "[hash:str] has the links:\n [links]" 
#+end_src

#+results: watch-tree
#+begin_example
  sEqRXSWh_TLfeb4OOXShJ2d3BRxn1TTJl42fdONUkp8 has the links:
   0000003000000200:Sz0ZZDWxKht-jbM7Tfkn0nis4tNoKNPH_kfI7JYUnY4
#+end_example

#+begin_verse
You should always quote your arguments.
Otherwise, the previous example would not have worked.
Without the quotes the characters `[lin` in "[links]" would be interpreted by the default bash shell.
#+end_verse

A link might hold a hash to a point that is not yet available on the device.
The program has to decide how to handle the situation.
For `imageboard` we'll just wait. 
Waiting can be done manually. e.g.

#+name: watch-tree-links
#+begin_src bash
  lk watch-tree "imageboard::/hello:**" --max 1 \
     | lk p "[links]" \
     | cut -d':' -f2 \
     | xargs -i lk watch-hash "{}" \
     | lk pktf "got point [hash:str] which has [data_size:str] bytes"
#+end_src

#+results: watch-tree-links
#+begin_example
  got point Sz0ZZDWxKht-jbM7Tfkn0nis4tNoKNPH_kfI7JYUnY4 which has 49983 bytes
#+end_example


Or use `lk get-links`. It has a few common strategies that might be simpler.

#+name: get-links
#+begin_src bash
  lk watch-tree "imageboard::/hello:**" --max 1 \
      | lk get-links pause \
      | lk pktf "[hash:str]"
#+end_src

#+results: get-links
#+begin_example
  Sz0ZZDWxKht-jbM7Tfkn0nis4tNoKNPH_kfI7JYUnY4
  sEqRXSWh_TLfeb4OOXShJ2d3BRxn1TTJl42fdONUkp8
#+end_example

For the imageboard applications we now have to wire up another program to merge images into a single picture.
See the tutorial for an example on doing this. 

The final piece of the puzzle is how exchanging points is organized.
Each linkpoint has a group field. A group is 32 bytes to signal the intended set of recipients.
Members ensure only members have access to the points.
By convention, the public group is:

#+name: group
#+begin_src bash
  PUB=$(echo "Hello, Sol!" | lk data | lk pktf "[hash:str]")
  lk linkpoint :$PUB:/example_path | lk p "[group:str]"
#+end_src

#+results: group
#+begin_example
  Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
#+end_example

If no group is specified (like we've been doing) the public group is used.

#+name: group-str
#+begin_src bash
  lk linkpoint ::/example_path  | lk p "[group:str]"
#+end_src

#+results: group-str
#+begin_example
  Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk
#+end_example

The other special group is `[0;32]`, also called the private group.
You can refer to it with the expression `[#:0]`.
Functions/subcommands that read/write existing points skip and/or warn whenever a point from the private group is seen unless enabled with `--private`.

#+name: private
#+begin_src bash
  lk linkpoint example:[#:0] | lk save 2>&1 # creating a packet is ok - but receving is not accepted by `lk save` without --private
#+end_src

#+results: private
#+begin_example
  error: Args { inner: ["/home/rs/Projects/linkspace/target/debug/lk", "save"] }
  Pkt(
      PrivateGroup,
  )
#+end_example

#+begin_verse
See [[file:./docs/guide/index.html#ABE][ABE]] for more on the `[..]` syntax.
#+end_verse

You can build a system to exchange points in a group from scratch.
Linkspace does not prescribe a way to do so.
Each group / network is different, and no single solution can cover every situation.

For example, you can, use `lk watch imageboard:$MYGROUP | ...` and forward the entire stream to another device using netcat/socat, ssh, email, http, a USB stick,
or any other way to exchange bytes.

There are build in tools to allow building more complex networks.

A `point` refers to the fields we've seen so far.
All these fields are included in the hash.
However, everything is done in the point packet format. This format includes the point fields, the hash, and 32 unhashed/mutable bytes. 

Filters work on these mutable bytes as well.
This let you quickly build specific network topologies.

#+begin_verse
See [[file:./docs/guide/index.html#mutable][the guide]] for the mutable field names.
#+end_verse

#+name: exchange
#+begin_src
  netcat 10.0.0.1 -p 6000 | lk route ubits0:=:0000 | lk save & # get packets from a host and set their ubits0 to 0000
  netcat 10.0.2.0 -p 6000 | lk route ubits0:=:0001 | lk save & # get packets from another host and set their ubits0 to 0001
  lk linkpoint example::/hello | lk route ubits0:=:0002 | lk save # save my packets with ubits 0002
  lk watch-log --asc example::/hello -- "ubits0:>:0000" | nc 10.0.0.1 -p 6000  & # forward all packets with ubits0 higher than 0000 back to host. 
#+end_src

#+begin_verse
The key takeaway here is - everything talks (streams of) packets. Avoid building custom serialization e.g. `struct MyStruct {customheader , packet}`.
This keeps your stream compatible with other tools.
#+end_verse


Linkspace does define some conventions.
These are functions that encoded creating/watching for point with some predefined pathname, links, and data format.
Conventions enable interoperability between multiple applications and background processes.

One such convention is the `pull` convention. This writes a query as a specific point.

#+name: pull
#+begin_src bash
  lk pull imageboard::/hello --write stdout | lk p "[path:str]\n\n[data]"
#+end_src

#+results: pull
#+begin_example
  /pull/[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]/[a:imageboard]/default

  :qid:default
  type:1:[b2:00000010]
  domain:=:[a:imageboard]
  group:=:[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]
  prefix:=:/hello
  path_len:=:[u8:1]
#+end_example

The goal of `pull` is to allow one process, e.g. an application like [[file:./docs/tutorial/imageboard.html][imageboard (bash)]] or [[file:./docs/tutorial/mineweeper-1.html][mineweeper (python)]]
to signal another process, e.g. a group exchange process like  [[file:./docs/tutorial/bash.exchange.html][bash.exchange]],
that it wants packets matching a query from the group.

Queries define a 'set of points' in linkspace.
The `filter` and `watch` commands are syntax sugar over queries.
You can add `--print-query` to those commands to see the query used.

Queries are designed such that joining two query strings the result is the common subset of both or an error if the union is empty.

#+name: q1
#+begin_src bash
  lk print-query example::/ok 
#+end_src

#+results: q1
#+begin_example
  :mode:tree-desc
  type:1:[b2:00000010]
  domain:=:[a:example]
  group:=:[b:Yrs7iz3VznXh-ogv4aM62VmMNxXFiT4P24tIfVz9sTk]
  prefix:=:/ok
  path_len:=:[u8:1]
#+end_example

#+name: q2
#+begin_src bash
  lk print-query example::/ok -- "path:=:/not_ok"
#+end_src

#+results: q2
#+begin_example
  error: Args { inner: ["/home/rs/Projects/linkspace/target/debug/lk", "print-query", "example::/ok", "--", "path:=:/not_ok"] }
  Error {
      context: "Error adding rule \'path\'",
      source: Error {
          context: "path:=:/not_ok",
          source: "prefix conflicting with path",
      },
  }
#+end_example

That's it for this quick introduction.
For a more in-depth technical guide or the library API see the [[file:./docs/guide/index.html][Guide]].
See [[file:./why.html][why]] for some of the reasoning behind linkspace.

Linkspace is free and open source under the MPL-2.0. 
Give it a try next time you want to talk about data.
